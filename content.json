{"meta":{"title":"quest233的博客","subtitle":"too naive","description":"","author":"quest_2","url":"https://quest233.github.io","root":"/"},"pages":[],"posts":[{"title":"【可能是置顶】Friends~","slug":"【可能是置顶】Friends","date":"2077-07-06T23:07:07.000Z","updated":"2021-04-21T02:48:14.109Z","comments":true,"path":"2077/07/07/【可能是置顶】Friends/","link":"","permalink":"https://quest233.github.io/2077/07/07/%E3%80%90%E5%8F%AF%E8%83%BD%E6%98%AF%E7%BD%AE%E9%A1%B6%E3%80%91Friends/","excerpt":"","text":"欢迎互换友链！ 当然还有弱小又卑微的作者的单向友链…… 这里的链接直接指向神仙们的博客吧qaq。 Friends~和我同时开始OI却比我强 inf 倍的 $ \\color{red}{R} \\color{orange}{u}\\color{gold}{i}\\color{LimeGreen}{ \\text{_} }\\color{RoyalBlue}{R}$ 每次月赛都能稳定切掉330+的 $ \\color{red}{z} \\color{orange}{j}\\color{gold}{j}\\color{LimeGreen}{ w }\\color{RoyalBlue}{s}$ 比我不知道高到哪里去的 $ \\color{red}{P} \\color{orange}{o}\\color{gold}{i}\\color{SpringGreen}{n}\\color{LimeGreen}{ t }\\color{RoyalBlue}{\\text{_}} \\color{BlueViolet}{K}\\color{DarkOrchid} {i}\\color{violet}{n}\\color{salmon}{g}$ 儒雅随和的&amp;&amp;AK期望专场的神佬 $ \\color{red}{我}\\color{orange}{知}\\color{gold}{道}\\color{LimeGreen}{了 }\\color{RoyalBlue}{王} \\color{BlueViolet}{子}$ 黑题收割者&amp;&amp;2150AC巨仙 $ \\color{red}{s} \\color{orange}{h}\\color{gold}{e}\\color{SpringGreen}{n}\\color{LimeGreen}{ m }\\color{RoyalBlue}{a} \\color{BlueViolet}{d}\\color{DarkOrchid}{o} \\color{violet}{n}\\color{salmon}{g} \\color{red}{d} \\color{orange}{o}\\color{gold}{n}\\color{SpringGreen}{g}$ 数数带师 &amp;&amp; 初三拿约的神仙 $\\color{red}{x}\\color{orange}{义}\\color{limegreen}{x}$ 同初中OI第一人 $\\color{red}{J}\\color{orange}{a}\\color{gold}{c}\\color{SpringGreen}{d}\\color{LimeGreen}{e}\\color{RoyalBlue}{r}\\color{BlueViolet}{Z}\\color{DarkOrchid}{h}\\color{violet}{a}\\color{salmon}{n}\\color{red}{g}$ 十八流城市逆袭神话 $\\color{red}{Y}\\color{orange}{i}\\color{gold}{C}\\color{SpringGreen}{h}\\color{LimeGreen}{e}\\color{RoyalBlue}{n}\\color{BlueViolet}{·}\\color{salmon}{L}$ 为收集数据屡教不改不关电脑的 $\\color{red}{x}\\color{orange}{y}\\color{LimeGreen}{f}\\color{RoyalBlue}{0}\\color{violet}{0}\\color{salmon}{7}$ 学OI三个月就爆踩我的 $\\color{red}{K}\\color{orange}{r}\\color{gold}{i}\\color{LimeGreen}{m}\\color{RoyalBlue}{s}\\color{violet}{o}\\color{salmon}{n}$ 可爱的苏维埃傲娇小猫娘 $ \\color{red}{S} \\color{orange}{c}\\color{gold}{h}\\color{SpringGreen}{w}\\color{LimeGreen}{ a }\\color{RoyalBlue}{r} \\color{BlueViolet}{z}\\color{DarkOrchid}{k} \\color{violet}{o}\\color{salmon}{p} \\color{red}{f} \\color{orange}{ \\text{_} }\\color{gold}{H}\\color{SpringGreen}{e}\\color{LimeGreen}{n}\\color{RoyalBlue}{k} \\color{BlueViolet}{a}\\color{DarkOrchid}{l} $ 萨卡兹穿刺手组长 &amp;&amp; 铁壁滴神 $\\color{red}{蒟}\\color{orange}{蒻}\\color{gold}{t}\\color{LimeGreen}{y}\\color{RoyalBlue}{y} $ 独立发明改进可持久化ODT的奆人 $\\color{red}{L}\\color{orange}{J}\\color{gold}{C}\\color{SpringGreen}{0}\\color{LimeGreen}{0}\\color{RoyalBlue}{1}\\color{BlueViolet}{0}\\color{salmon}{1}$ DS高手 &amp;&amp; 机惨讲武德点到为止的君子 $ \\color{red}{D} \\color{orange}{P}\\color{gold}{a}\\color{LimeGreen}{i}\\color{RoyalBlue}{r}$ 对STL了如指掌的C++之父 $ \\color{red}{ \\text{_} } \\color{orange}{W}\\color{gold}{a}\\color{SpringGreen}{l}\\color{LimeGreen}{l}\\color{RoyalBlue}{a} \\color{BlueViolet}{c}\\color{DarkOrchid}{e} { \\text{_} }$ 文化课作业卷怪中的卷怪 $\\color{red}{火}\\color{gold}{车}\\color{LimeGreen}{司}\\color{RoyalBlue}{机} $ 线上抓颓的恐怖教练（可恶啊，居然没有博客） $ \\color{red}{d} \\color{orange}{e}\\color{gold}{v}\\color{SpringGreen}{i}\\color{LimeGreen}{n}\\color{DarkOrchid}{w} {a}\\color{violet}{n}\\color{salmon}{g}$ 手搭博客的python专家 $ \\color{red}{E} \\color{orange}{z}\\color{gold}{i}\\color{SpringGreen}{o}\\color{LimeGreen}{ \\text{_} }\\color{RoyalBlue}{ \\text{_} } \\color{BlueViolet}{A}\\color{DarkOrchid}{u} \\color{violet}{d}\\color{salmon}{i} \\color{red}{t} \\color{orange}{o}\\color{gold}{r}\\color{SpringGreen}{e} $ XJ 第一铁憨憨边老师 $\\color{red}{O}\\color{orange}{a}\\color{gold}{k}\\color{SpringGreen}{e}\\color{LimeGreen}{n}\\color{RoyalBlue}{s}\\color{BlueViolet}{h}\\color{DarkOrchid}{i}\\color{violet}{e}\\color{salmon}{l}\\color{red}{d}$ 模拟赛随手切切的恐怖演王跳蛙 $\\color{red}{L} \\color{orange}{e}\\color{gold}{a}\\color{SpringGreen}{p}\\color{LimeGreen}{\\text{_}}\\color{DarkOrchid}{F}{r}\\color{violet}{o}\\color{salmon}{g}$","categories":[],"tags":[{"name":"water","slug":"water","permalink":"https://quest233.github.io/tags/water/"}]},{"title":"","slug":"信","date":"2021-08-12T03:43:26.584Z","updated":"2021-08-12T12:43:11.026Z","comments":true,"path":"2021/08/12/信/","link":"","permalink":"https://quest233.github.io/2021/08/12/%E4%BF%A1/","excerpt":"","text":"[[module CSS]]div#header { background: url(https://xyix.github.io/images/xj-branch.png) 0px 40px no-repeat; background-size: 100px 100px;}div#container-wrap { background: url(http://scp-wiki-cn.wdfiles.com/local--files/component%3Atheme/body_bg.png) top left repeat-x;}div#header h1 a span { font-size: 0px;}div#header h1 a:before { content: “SCP基金会XJ分部”; color: #eee;}div#header h2 span { font-size:0px; padding: 4px;}div#header h2:after { content: “为有牺牲多壮志，敢教日月换新天”; font-weight: bold; color: #f0f0c0; padding: 19px 0; text-shadow: 1px 1px 1px rgba(0, 0, 0, .8); white-space: pre;}[[/module]] [[[xj | 【】中心页]]] » [[[http://scpsandboxcn.wikidot.com/shut-down|Dr.Quest的提案]]] » 尾声 秋高气爽。我阔别【】，已有几十年了。 之所以回来，是作为老兵之一受邀入席周家人的夜宴。 【】的建筑改观不算大，依然是砖墙的高楼夹着行空的复道，令人不由慨叹政治真是割裂于物质的造物。倒是吊死过老徐和XJ-012的路灯成了纪念碑似的玩意。不过当年我们干这事的时候可没想那么多。 新政府的组建一帆风顺，延祚计划可以说大获成功，基金会的同事们也为战胜了XJ-001而欢呼雀跃。 更令人欣喜的还在后头。 延祚计划结束一个月后，或许是因为催化它们异常的外在环境的消灭，XJ-Site-13 监测到项目内的休谟水平回归到了正常值。看着一个个绿型一点一点回归到正常人类，不由得泛起洋洋得意之情。 至此，【】的收容工作总算是迎来了一个十全十美的HE。 很快，我的辞职申请也被基金会通过，一笔沉重的奖金足以供养我来得过早的退休生活。 那些孩子们呢？我从基金会辞职后就没去打听他们的情况了，只记得那年的某个午后，在知乎上刷到过这样的提问“如何评价【】中学在今年的全国信息学奥林匹克竞赛中一举拿下七个集训队名额”。 尖酸的话语，我知道提问者心里在想什么，不过这回确实没人需要再切一次蛋糕…… “为德先生敬上一杯！”大家被突然起身的我惊得一愣，随后也心领神会地一起举杯： “德先生万岁！” 一道带着火的尖啸划过夜空，随即绽开了炫目的焰色。混着嘈杂的人语传来了连绵的鞭炮声，氙气光灯在校门口闪了两闪。 新一任的周长官理了理燕尾服，提着满臂的花束，喊着”失陪失陪“便走了出去。 虽然离校多年，这点时事我还不至于不了解。 是我们学校那四个参加IOI的选手回来了。","categories":[],"tags":[]},{"title":"浅谈一类优化后的暴力——「MCOI-05」追杀 题解","slug":"浅谈一类优化后的暴力——「MCOI-05」追杀-题解","date":"2021-05-04T06:23:57.000Z","updated":"2021-05-04T10:46:30.680Z","comments":true,"path":"2021/05/04/浅谈一类优化后的暴力——「MCOI-05」追杀-题解/","link":"","permalink":"https://quest233.github.io/2021/05/04/%E6%B5%85%E8%B0%88%E4%B8%80%E7%B1%BB%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E6%9A%B4%E5%8A%9B%E2%80%94%E2%80%94%E3%80%8CMCOI-05%E3%80%8D%E8%BF%BD%E6%9D%80-%E9%A2%98%E8%A7%A3/","excerpt":"","text":"推蒟蒻 $\\color{green}{blog}$ 原题链接qaq~ 原题大 E 是有 $n$ 条大新闻，每条大新闻形如 $u$ 扣了 $v$ 一滴血，每个人有 3 滴血，如果一个人的血量为 $0$， 那么之后所有有关他的大新闻都失效。 这时候出了一个外挂er，他可以在某一时刻开挂，突然扣一个人一滴血（这个人可以是死人）。定义 $f[k]$ 为“在某一位置突然扣了某个人一滴血后，导致最后有 $k$ 人存活的方案数”，求 $f[0…m]$ 的异或和。 预处理首先我们有一个非常显然的结论：对于一个人来说，如果某一段时间他既没有去砍别人也没有被别人砍，那么他在这段时间里的任何时刻，被砍一刀导致的结果都是 等价的 。 然后我们继续分析，一个人在 3 滴血时被砍和在 2 滴血时被砍，导致的结果也是一样的——他们都会在本应还有 1 滴血的时候暴毙。 这样一来，其实我们可以把任何一个人的存活时间分成 几个区间 ，每个区间内被砍导致的结果都等价。我们整区间整区间地统计，这会使我们的代码优化很多。 先放预处理部分的瑇码~ 12345678910111213141516171819202122232425262728293031323334353637N = read();M = read();for (register int i = 1; i &lt;= M; i++) HP[i] = 3;//HP 数组存血量for (register int i = 1; i &lt;= N; i++)&#123; int x, y; x = read(); y = read(); q[i].u = x; q[i].v = y;//q 数组用来存每条大新闻 if (HP[x] &amp;&amp; HP[y])//如果这条新闻是有效的 &#123; HP[y]--; if (HP[y] == 0) &#123; die[y] = i;//die 数组存每个人是什么时候死的 &#125; &#125; if (HP[x] == 1) &#123; v[x].push_back(MP(lst[x], i - 1));//v 存每个人的等价区间们 //lst 存每个人的上一步行动是在什么时候 v[x].push_back(MP(i, i)); lst[x] = i + 1; &#125;&#125;int remain = 0;//如果没有开挂，本应有 remain 人存活for (register int i = 1; i &lt;= M; i++)&#123; if (HP[i]) remain++; if (lst[i] != N + 1)//处理一些还未封闭的等价区间 v[i].push_back(MP(lst[i], N)); if (die[i] == 0) die[i] = N + 5;//如果一直不死，就给他赋一个无限晚的死亡时间&#125; 获取答案然后我们要做的就是枚举每一个人，枚举他的每个等价区间，再把答案累计上去。 你会想，可这 $n^2$ 难道不会 T 飞🐎？ 事实证明是不会的，由于每人的区间个数之和是一个定值，这个 $n^2$ 必然是跑不满的水 $n^2$ 。 如果在某个等价区间里，这个人已经死了，那么鞭一刀尸体不会影响答案，$f[remain]+=\\texttt{区间长度}$ 。 否则，专门写一个函数 check 判断会留下几个人，函数里可以直接暴力一个一个大新闻地跑。然后 $f[check()]+=\\texttt{区间长度}$ 。 然后我们就有一份 AC 瑇码辣！!1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;#define endl &#x27;\\n&#x27;const int MAX = 1e5 + 7;const int MOD = 1e9 + 7;void print(bool a)&#123; cout &lt;&lt; (a ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl;&#125;struct atk&#123; int u, v;&#125; q[MAX];#define PII pair&lt;int, int&gt;#define MP make_pairvector&lt;PII&gt; v[MAX];int read()&#123; int num = 0, bj = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == &#x27;-&#x27;) &#123; bj = -1; &#125; ch = getchar(); &#125; while (isdigit(ch)) &#123; num = num * 10 + ch - &#x27;0&#x27;; ch = getchar(); &#125; return bj * num;&#125;int lst[MAX];int die[MAX], HP[MAX];int ans[MAX];int N, M;inline int check(int pos, int v)//在 pos 号大新闻后，v 被砍了一刀&#123; for (register int i = 1; i &lt;= M; i++) HP[i] = 3; for (register int i = 1; i &lt;= pos; i++) if (HP[q[i].u] &amp;&amp; HP[q[i].v]) HP[q[i].v]--; if (HP[v])//开挂砍一刀 HP[v]--; for (register int i = pos + 1; i &lt;= N; i++) (HP[q[i].u] &amp;&amp; HP[q[i].v]) HP[q[i].v]--; int tmp = 0; for (register int i = 1; i &lt;= M; i++) tmp += (HP[i] &gt; 0);//统计存活人数 return tmp;&#125;signed main()&#123; ...//预处理部分，在此不再重复 for (register int i = 1; i &lt;= M; i++)//枚举人 &#123; for (auto u : v[i])//枚举等价区间 &#123; if (u.first &gt; u.second) //若区间不合法则跳过（推测应该是在造区间的时候造了一些没用的区间） continue; if (die[i] &lt;= u.first)//若是鞭尸 ans[remain] += u.second - u.first + 1; else ans[check(u.second, i)] += u.second - u.first + 1; &#125; &#125; for (register int i = 0; i &lt;= M; i++) printf(&quot;%d &quot;, ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://quest233.github.io/tags/solutions/"}]},{"title":"浅谈一类矩阵乘法建模—— 【XR-1】分块 题解","slug":"浅谈一类矩阵乘法建模——-【XR-1】分块-题解","date":"2021-04-22T01:02:28.000Z","updated":"2021-04-22T01:23:37.781Z","comments":true,"path":"2021/04/22/浅谈一类矩阵乘法建模——-【XR-1】分块-题解/","link":"","permalink":"https://quest233.github.io/2021/04/22/%E6%B5%85%E8%B0%88%E4%B8%80%E7%B1%BB%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%BB%BA%E6%A8%A1%E2%80%94%E2%80%94-%E3%80%90XR-1%E3%80%91%E5%88%86%E5%9D%97-%E9%A2%98%E8%A7%A3/","excerpt":"","text":"推蒟蒻 $\\color{limegreen}{blog}$ ！ 原题链接~ 题是简单题，重在想到矩乘后怎么往下写。 题意不须讲了，很清楚而且很有意思。 转移方程稍微给一下，推导可以阅读别的题解。 设置状态 $dp_{\\ i}$ 指的是：长度为 $i$ 时可行的分块方案。 我们有: （ $x$ 指的是的可能的块长（即两人公认的其中一种块长）） dp_{\\ i}= \\sum dp_{\\ i-x}我们看到块总长是 $\\leq 1e18$ 的，连 $N$ 的空间都开不下，就别提更高维的数组了。 因为开不下，所以 $O(N)$ 递推难矣。 『递推的优化，显然矩乘。』我们尽量少算值，整出个初始状态就差不多可以了。 要推第 $i$ 项，要保证在所有可能的块长 $x$ 下，第 $i-x$ 项都已知。 因为块长不会大于 $100$ ，故我们可以先预处理到 $dp_{\\ 100}$ 。 开 $100 * 100$ 的矩阵，至少可以保证递推时每一项都能推得出来。 现在就到了矩阵乘法最重要的一部分————初始化矩阵。目前这一步的状态需要前面哪几步的状态推出？ 我们通过递推式知道了，与 $x$ 步前的状态有关系（以下的 $x$ 指代每一种可能的块长）。 我们把 $dp_{\\ i}$ 放在原始矩阵的第 $(1,1)$ 位置，那就把 $dp_{\\ i-k}$ 放在 $(k,1)$ 位置。 也就是说新的矩阵的 $(1,1)$ 位置，要由所有的 $(x,1)$ 的总和转移而来。 那转移矩阵的第一行里必然有：对于每一个可行的 $x$ ， $(1,x)$ 处为 $1$ ，其余位置为 $0$ 。 比如对于样例1， $1$ 和 $2$ 都是可行的 $x$ ，转移矩阵的第一行必如下图： \\begin{bmatrix}1&1&0&0&\\cdots &0\\end{bmatrix} 我们解决了第一行，那其他行如何处理？我们此刻的 $dp_{\\ i}$ ，在下一次（第 $i-1$ 次）转移后就将成为 $dp_{\\ (i+1)-1}$ ，所以应向后推一位，从原来的 $(1,1)$ 位置后推到 $(2,1)$ 位置。 这一过程在做其他矩乘题里必然也经常用到，对于第 $i(i\\neq 1)$ 行，我们在 $(i,i-1)$ 位置设为 $1$ ，其余位置设为 $0$ 。 这样可以做到原来在 $(1,1)$ 的第 $dp_{\\ i}$ 位在转移后移至 $(1,2)$ 。 对于后面几位亦如此。 最终成品转移矩阵如下（中间省略了一部分数值）： \\begin{bmatrix}1&1&\\cdots&0&0\\\\1&0&\\cdots&0&0\\\\0&1&\\cdots&0&0\\\\\\vdots&\\vdots&\\ddots&\\vdots&\\vdots\\\\0&0&\\cdots&1&0\\end{bmatrix} 所以 $AC$ 此题，流程如下： 预处理 $dp_{\\ 100} $ ，填入原始矩阵。 初始化转移矩阵。 矩阵快速幂。 输出最终答案矩阵的 $(1,1)$ 。 以下是代码～ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MOD = 1e9 + 7;int LEN, PR, NF;map&lt;int, int&gt; m1, m2;int N;int dp[107];/*矩阵组件*/struct matrix&#123; int num[107][107]; matrix operator*(const matrix a) const &#123; matrix c; memset(c.num, 0, sizeof(c.num)); for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; for (int k = 1; k &lt;= N; k++) &#123; c.num[i][j] = (c.num[i][j] + (num[i][k] * a.num[k][j]) % MOD) % MOD; &#125; &#125; &#125; return c; &#125;&#125; ORZ, RBQ;//ORZ----原始矩阵 RBQ----转移矩阵/*快速幂组件*/matrix quick_pow(matrix a, int p)&#123; if (p == 1) &#123; return a; &#125; matrix tmp = quick_pow(a, p / 2); if (p % 2 == 0) &#123; return tmp * tmp; &#125; else &#123; return tmp * tmp * a; &#125;&#125;signed main()&#123; memset(ORZ.num, 0, sizeof(ORZ.num)); memset(RBQ.num, 0, sizeof(RBQ.num)); cin &gt;&gt; LEN; cin &gt;&gt; PR; for (int i = 1; i &lt;= PR; i++) &#123; int num; cin &gt;&gt; num; m1[num] = 1; &#125; cin &gt;&gt; NF; for (int i = 1; i &lt;= NF; i++) &#123; int num; cin &gt;&gt; num; if (m1[num]) &#123; m2[num] = 1;//指这个块长两人是否都公认 &#125; &#125; /*初始化转移矩阵*/ for (int i = 1; i &lt;= 100; i++) &#123; if (m2[i] == 1) &#123; RBQ.num[1][i] = 1; N = i; &#125; &#125; for (int i = 1; i &lt; N; i++) &#123; RBQ.num[i + 1][i] = 1; &#125; /*预处理dp[100]*/ dp[0] = 1; for (int i = 1; i &lt; N; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; if (m2[j] == 1) &#123; dp[i] = (dp[i] + dp[i - j]) % MOD; &#125; &#125; ORZ.num[N - i][1] = dp[i]; &#125; ORZ.num[N][1] = 1; matrix ans = quick_pow(RBQ, LEN - N + 1) * ORZ; cout &lt;&lt; ans.num[1][1];&#125;","categories":[],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://quest233.github.io/tags/solutions/"}]},{"title":"浅谈一类高斯消元解异或方程组——[JSOI2012]始祖鸟 题解","slug":"浅谈一类高斯消元解异或方程组——-JSOI2012-始祖鸟-题解","date":"2021-04-20T13:03:51.000Z","updated":"2021-04-21T01:14:47.918Z","comments":true,"path":"2021/04/20/浅谈一类高斯消元解异或方程组——-JSOI2012-始祖鸟-题解/","link":"","permalink":"https://quest233.github.io/2021/04/20/%E6%B5%85%E8%B0%88%E4%B8%80%E7%B1%BB%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E5%BC%82%E6%88%96%E6%96%B9%E7%A8%8B%E7%BB%84%E2%80%94%E2%80%94-JSOI2012-%E5%A7%8B%E7%A5%96%E9%B8%9F-%E9%A2%98%E8%A7%A3/","excerpt":"","text":"推蒟蒻 $\\color{salmon}{blog}$ ！ 原题链接~ 有趣的高斯消元解异或方程组题，难点在建模。 这里默认读者都会高消（（（ 题意稍加转化：每只鸟取值 0/1 ，需要有偶数个朋友和他取值相同。 偶数且01，这不由得转化到异或的方向。 这样我们就有了一个森破的想法：（设 $pos[i]$ 为 $i$ 号鸟的取值，上游为 1 ，下游为 0；设 $A[i][j]$ 代表 $j$ 是否（0/1）是 $i$ 的朋友） (A[i][1]\\cdot pos[1])\\oplus (A[i][2]\\cdot pos[2])\\oplus \\cdots\\oplus (A[i][n]\\cdot pos[n])=0但是很显然这是错的，因为我们其实只是做到了让上游有偶数个朋友，要是这只鸟本身就在下游呢？ 我们改一改思路： 如果一只鸟有偶数个朋友，则只需满足上游有偶数个，下游必然也会有偶数个。 如果一只鸟有奇数个朋友，若当前为上游，则需要偶数个在上游；若当前为下游，则需要奇数个在上游，这样一来下游就有偶数个。 然后把每只鸟对应的方程都列出来，高消解异或方程组即可。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;#define endl &#x27;\\n&#x27;const int MAX = 2e3 + 7;const int MOD = 1e9 + 7;void print(bool a)&#123; cout &lt;&lt; (a ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl;&#125;int N;int n;struct matrix&#123; bitset&lt;MAX&gt; num[MAX]; bitset&lt;MAX&gt; &amp;operator[](int id) &#123; return num[id]; &#125; void SWAP(int x, int y) &#123; swap(num[x], num[y]); &#125; void XOR(int x, int y) //xor y to x &#123; num[x] = num[x] ^ num[y]; &#125;&#125; ORZ, RBQ;void gauss()&#123; for (int i = 1; i &lt;= N; i++) &#123; int k = i; for (int j = i; j &lt;= N; j++) &#123; if (ORZ[j][i]) &#123; k = j; break; &#125; &#125; if (ORZ[k][i] == 0) &#123; continue; &#125; ORZ.SWAP(k, i); for (int j = 1; j &lt;= N; j++) &#123; if (ORZ[j][i] &amp;&amp; j != i) &#123; ORZ.XOR(j, i); &#125; &#125; &#125;&#125;vector&lt;int&gt; v;signed main()&#123; cin &gt;&gt; N; n = N; memset(ORZ.num, 0, sizeof(ORZ.num)); for (int i = 1; i &lt;= N; i++) &#123; int tot = 0; cin &gt;&gt; tot; for (int j = 1; j &lt;= tot; j++) &#123; int k; cin &gt;&gt; k; ORZ[i][k] = 1; &#125; if (tot &amp; 1) &#123; ORZ[i][i] = 1; ORZ[i][N + 1] = 1; &#125; &#125; gauss(); for (int i = N; i &gt;= 1; i--) &#123; if (ORZ[i][i]) &#123; if (ORZ[i][N + 1]) v.push_back(i); &#125; else if (ORZ[i][N + 1]) &#123; cout &lt;&lt; &quot;Impossible\\n&quot;; return 0; &#125; &#125; cout &lt;&lt; v.size(); cout &lt;&lt; endl; for (int i : v) &#123; cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125;&#125;","categories":[],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://quest233.github.io/tags/solutions/"}]},{"title":"联合省选划水记","slug":"联合省选划水记","date":"2021-04-17T07:37:21.000Z","updated":"2021-04-17T08:12:29.592Z","comments":true,"path":"2021/04/17/联合省选划水记/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E8%81%94%E5%90%88%E7%9C%81%E9%80%89%E5%88%92%E6%B0%B4%E8%AE%B0/","excerpt":"","text":"是非正式选手啊……去玩玩，以后估计没这种机会了。 Day 0：颓了一天，直到快放学了才发现多项式板子貌似默不出来，极速敲了一点。敲的过程中感觉上了考场大力乱蒙就能过了。 听说小俄猫生病了，我今天还抱过他的手来着，看来不是很安全。 QY 在催回寝了，面瘾犯了，别的板子就不敲了。 Day 1:早上上了大巴，发现打狼的几个没坐在一起，开不成了。 小俄猫其实啥事没有，又可以大力摸摆了，今天还主动来拉我，好可爱。 脑中意淫了一下 LCT 和 SAM ，结果突然在多项式求逆上卡住了。问了一下 Rui_R 神，被他一眼秒+鄙视了。 终于到了，别的学校的考生还要从正门进，XJ 的车子却直接从侧门放进去了，整的好像我们是龙人一样。 进考场，偷偷敲缺省源，没过多久考试就开始了。 先开 T2 ，这个 $M=2$ 的 30pts 几乎和拜松差不多，敲了个差分似的东西就过了手搓的一些数据。 大力手玩了一下 $a_{i,j}=0/1$ 的情况，发现有些难搞，然后更加死命去钻了。在这里几乎浪费了五百年，等宣布放弃已经是 $9:45$ 了。 开 T1 ， $N\\leq5$ 的部分分几乎也是白送，先无脑敲了个 $dfs$ 。这时脑中灵光一现，这个东西可能是可以退火的，随即大敲特敲起来。 大体用可删堆维护了全数组的 $\\max$ 和 $\\min$ ，然后随机选择一张卡翻面。 码的过程中出现了巨大多的锅，还好一个一个全填上了。通过小样例已经 $11:00$ 了。 测中样例，一通枯燥的调参过后，最终撞出了 9445 ，但是跑一趟需要 5s+ 。 感觉自己还是卡不动，突然在 $PDF$ 里找到了这样的话： 编译命令：-O2 这也太快乐了，大口吸氧过后，中样例居然只要 0.3s ！ 用记事本打开了中样例，发现是这样的： （效果复原图） tm 这个 $M$ 明明远大于 $N$ 啊，赶紧尝试了一下其它的 $M$ ，发现在 $M$ 极小的情况下我的算法慢出天际，赶紧从头卡常了一波。 赛后发现我是憨憨，只是因为记事本显示不出换行符罢了。 已经 $11:30$ 了，我 T3 还完全没开，捞了一眼，感觉很不可做。就打了个 $\\mathcal{O}(n^5)$ （也可以称作 $\\mathcal{O}(mn^3)$ ）的暴力，骗了 16pts 。 比赛还有一个小时，去上了个厕所，发现这个 tyy 已经开始颓废了，我可不想变成这副吊样（（ 用心检查了一下前两题，造了几组数据，看上去挺安全。 这时候开始想 T2 $n,m\\leq3$ 的情况，摸了半天没啥名堂，就打算写个基于值域的思博枚举骗分。 打的过程中发现一个很恐怖的事： 我题意看错了！ 事实上是把 $b$ 数组的生成方式看错了，好在问题不大，大爆手速终于救回来了。但是没有时间优化第一个子任务了，就这样吧。 从考场出来走了一条布满警戒线的道路，感觉挺有趣。 在紫金港吃完了饭，去小卖部，他们这里居然存货有这么多方糕啊，这个方糕在学军本部都是稀缺资源。 回来的路上打了三把狼，都是法官，见识了 DPair 神的盲毒绝技（指把好人直接送出局）。 听说 hehezhou 280分，orz hehezhou 浙江队长。 听说好多人 T1 写假了，默哀，还好我一开始写的就是暴力（（ 听说 zhouakngyang 子文件夹没建，可怜 zak 痛失 E 队队长。 明天希望不要有数据结构和998吧。 D1 估分：[20,40]+[30,50]+16=[66,106] 实际：??+??+??=?? Day 2:下雨了诶，好困，昨天晚上大混战确实太激烈了。 上车，又没打成狼，想补觉，但车上太抖了，睡不着。 到考场，快速敲完缺省源，先看看题目名字，看来省选考多项式的毒奶要落空了。这个 ranklist 三个大样例都这么小，估计是道非多项式数数吧。 考试开始，ranklist 果然是一道非多项式数数，貌似是阶乘算法，好烦。 还是这个 T1 看上去可做多了，先用倍增水了一个链的部分分，又打了一个 $n^2$ 暴力，一个半小时不到拿了 50pts ，我感觉我太强了。 然后开始想 T1 正解，询问这么多，可能是把询问离线下来在序列上处理吧，感觉可以树剖。 发现这个思路真的和打某一场 XJOI 的心路历程好像啊，但就是想不起来怎么做了。 于是闷头码码码，打了三四K的时候意识到离线下来处理对回答询问貌似没有好处，心态炸裂，确认了一下我确实假了，就绑了几个暴力扔在一边。 开 T2 ，有一个 $\\mathcal{O}(n!n^n)$ 的奇妙做法，大概可以拿 $\\leq3$ 的分。 打的过程中发现高妙性质，即：每一次分配给这个队伍的分数最优为 \\max\\{\\;\\texttt{上一个队伍分配到的分数},\\texttt{当前场上最大值-}a_i\\ \\}一旦剩余可分配的分数小于这个值，那就是不行。 这样就优化到了 $\\mathcal{O}(n!n)$ ，期望过 $n\\leq 8$ 的点，实际上它 $n\\leq10$ 也跑得飞快，甚至 $n\\leq 12$ 也有机会在时限内跑出来。 T3 是真的没时间看了，听说 $m=n-1$ 的部分分还是很一眼的，听 LJC00101 神说 T3 是最简单的，有点亏。 出考场，还下着雨，吃了饭，逛了超商，紫金港还有面包房啊，里边还有标价上百块的大蛋糕，果然是龙人。 车上打了狼，除了第一把玩狼快速绑票胜利外，其他抽的都是好人迅速下饭。这个 ZMF 也太高配了，我像个小丑。 下午推多娜多娜，碰上 R18 情节直接狂按 Ctrl 走马灯，这个化学研究所怎么有三个 Boss 啊，从下午推到晚上还没有过。玩黄油都能卡关，不愧是我。 （火车司机还以为我这个黄油是没有 R18 部分的，但是事实上只是因为我卡关了，剧情推不过去） D2 估分：50+[60,80]+0=[110,130] 实际：??+??+??=?? Day 3:鸽子。","categories":[],"tags":[{"name":"water","slug":"water","permalink":"https://quest233.github.io/tags/water/"}]},{"title":"紫题算法学习实况 II","slug":"紫题算法学习实况-II","date":"2021-04-17T07:16:56.000Z","updated":"2021-04-18T08:33:51.604Z","comments":true,"path":"2021/04/17/紫题算法学习实况-II/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5-II/","excerpt":"","text":"原来那个文章里面全都是瑇码和公式，充斥了4700多行，卡到已经几乎无法编辑了，所以新开一个文章。 如果笔者有什么写得乱七八糟或者听天书的地方，可以直接评论区开D，笔者即刻更改，以免贻害后人。 2021-01-09：愉悦滚去whk，本文应该长期不更了（咕）2021-01-17：爬回机房重新阅读了一下本文，修了大量语文锅 SAM_写在最前：网上最主流的讲解方式无非是 endpos - 构建方法 - 应用，这里也不另辟蹊径，但是会扔掉一些晦涩难懂的证明，争取用阳间一点的语言说罢_ “将所有是旧串后缀且在其后面加c形成的新字符串不是旧串子串的字符串往新串的最长后缀所属节点连一条边。” 如果要求您在一张图上表示一个字符串的所有子串，那么您可能会建一棵 $\\texttt{Trie}$ 。 如图： 很有精神的一个 $\\texttt{Trie}$ ，从根结点往下，走到任意一个点的 路径 都是原串的一个子串。 但是缺点貌似也很明显，他太占空间了，这框出的这两部分是一模一样的。这是坏的。 我们意识到需要有一种好的存图规则，来尽可能优化我们的空间。 于是乎， 先 辈 们想到了一种氡氡—— $endpos$ 。 $endpos$ ？假设我有一个字符串 $\\mathtt{shenmadongdong}$ 。（这个字符串一听就很巨） 我们截取出一个子串 $\\mathtt{dong}$ ，若以一个字串的 最后一位 来表示位置的话，它出现在 $\\{10,14\\}$ 两处。 我们就将 $\\{10,14\\}$ 这样的 位置集合 称做 $\\mathtt{dong}$ 这个子串的 $endpos$ 。 未来或现在的 IOIAKer 您一定看出来了，这个 $endpos$ 有些十分美妙的性质，这里分别阐述： _以下钦定 $len_a\\leq len_b$_ 性质〇：对于一个子串的后缀们，越长的后缀所拥有 $endpos$ 集合越小，反之则反之。算不上性质的性质/jy 这不是显然的事情嘛？越长的后缀它出现的次数肯定越少哇。 $\\Box$ 性质一：如果两个子串的 $endpos$ 有相同的元素，则一个中的子串必然为另一个的后缀我们说过，一个子串的出现位置，由他的 最后一位 表示。 胡乱猜结论：只有最后 $len_a$ 位一样的两个串，才会共享一样的 $endpos$ 。 尝试证明：要是在 $len_a$ 位内出现了不同的某一字符，那么他们的最后一位必然 落不到同一个位置 ，那么他们的 $endpos$ 内的元素必然不同。 $\\Box$ （好感性啊 AwA ）。 性质二：两个子串 $a,b$ ，要么其中一个的 $endpos$ 包含另一个的，要么两者的 $endpos$ 没有交集。如果 $a$ 是 $b$ 的后缀，那么 $b$ 出现的地方 $a$ 必然也出现了，那么 $endpos(b)\\subseteq endpos(a)$ 是显然的。 如果不是，那么根据性质一，二者不会有交集。 $\\Box$ （这个就非常有理有据）（确信） 。 性质三：如果把所有 $endpos$ 集合完全相同的子串归在一个等价类里，那么每个 $endpos$ 的等价类里的子串长度连续。这个性质十分好用。这证明起来也是很 $naive$ 的。 如果存在 $a,b$ 归在同一个等价类里，且 $len_a+1&lt;len_b$ （也就是中间出现了断层）。 根据性质一， $a$ 必为 $b$ 的 后缀 。 根据性质〇，更短的后缀都和 $b$ 出现的位置 完 全 一 致 了，那更长的后缀怎么说也更应该一样了 QwQ。 但既然如此，比 $a$ 再长一位的后缀凭什么不能和 $a,b$ 在同一个等价类里？这不公平。 $\\Box$ （鬼扯证明）。 插播：$parent\\ tree$ ？虽然性质还有很多，但是这时的确就应该开始讲 $parent\\ tree$ 了，这的确符合认识算法的客观规律。 我们看 $\\mathtt{shenmadongdong}$ 中的 $\\mathtt{n}$ ，它的 $endpos$ 为 $\\{4,9,13\\}$ 。 如果我们要往它前面加一个字符，我们有 $\\mathtt{en}$ 和 $\\mathtt{on}$ 两种加法，他们的 $endpos$ 分别为 $\\{4\\}$ 和 $\\{9,13\\}$。 你灵光一现，意识到在一个字符串 前面 加一个字符，很可能就会把原来这个字符串的 $endpos$ 分割成若干份 。 我们接着在 $\\mathtt{on}$ 上加字符，此时只有一种加法 $\\mathtt{don}$ ，$endpos$ 依然是 $\\{9,13\\}$ 。 你完善了你的猜想，所谓的 “分割成若干份” 也可以指的是 一份 。当加字符后和原来还是在 同一个等价类 里的话，就会出现这种情况。 我们接着在 $\\mathtt{don}$ 上加字符，此时又有两种加法 $\\mathtt{adon}$ 和 $\\mathtt{gdon}$ ，分别有 $endpos$ 为 $\\{9\\}$ 和 $\\{13\\}$ 。 这更加证实了你的猜想，即： 『一个字符串 前面 加一个字符，将会把原来这个字符串的 $endpos$ 分割成若干（可能为一）份 』 多么伟大不朽的成就。 我们称这是『神马氡氡第一定律』 。 根据性质二，非后缀关系的两个子串 $endpos$ 无交集，所以以 等价类作为结点 ，这些分割关系构成了一些 树形结构，即一棵森林。 森林算不上 $\\mathbf{tree}$ ，我们需要一个超级根来聚合一棵树，不难想到，空串所在的等价类 正符合当超级根的要求 。因为他无处不在，所以他的 $endpos$ 是 $\\{1,2,3,4,5,6,7,8,9,10,11,12,13,14\\}$ ，相当于全集。 下属其它的 $endpos$ 集合，都是这个集合的子集。 那么我们这就构建出了一棵 $parent\\ tree$ ，对于 $\\mathtt{shenmadongdong}$ 这个仙气溢出的字符串，我们能构建这样一棵 $parent\\ tree$ ： 这里引入一个概念：我们称某个等价类中的 最长子串 指的是： （$endpos$ 符合某个等价类） 的所有子串中，长度最长的那个子串。 最短子串 的定义同理。 这里用 $\\color{purple}{\\texttt{给}}$ 指导最爱的颜色标出了“每个结点对应的等价类的 最长子串 ”。 结点中的数字表示的是 $endpos$ 集合。 性质四：如果两个等价类 $A,B$ ，在 $parent\\ tree$ 上 $B$ 是 $A$ 的父亲 ，那么 $B$ 的最长子串的长度+1，一定等于 $A$ 的最短子串的长度。奇怪的性质增加了.jpg 我们再次 YY 一下 $parent\\ tree$ 的构造规则： 在一个等价类中的某个子串前再 添加一个字符 。 不难发现，若选择的这个子串是这个等价类中的 最长子串 ，形成的字符串就必然归于其 儿子 的等价类。否则就仍在这个等价类中。 如果选择的是最长子串，那这个新形成的字符串肯定这个 儿子等价类 中 最短 的一个。 $\\Box$ 算法可行性不证了，版（zuo）面（zhe）有（tai）限（cai）。 看到这里，您必然会想：“我是来看 SAM 的，这个吊人却给我讲些什么 $parent\\ tree$ 之类的东西搞啥呢。” 我们将要构建的SAM，就和 $parent\\ tree$ 有一样的 结点 定义。 事实上，SAM 的前置知识还是很重要的，了解了这些性质就有效地避免了全文背诵的惨案。 字符串数据结构的全文背诵是最不彳亍的，因为出出来的那些题大多需要 魔改 数据结构的机体，光是全文背诵就很痛苦了。 构建一台后缀自动姬 $Step\\ 0$：有关变量首先我们需要整出一套自动姬所需的数组啊啥的。 东汉末名将赵子龙就曾说过：“能进能退 （能伸能缩），乃真正法器。” 我们需要让我们的字符串能向前扩展，也能向后扩展，以表达所有的子串。 我们已经有了在子串 前面 加字符的方法，即 $parent\\ tree$ 的构造规则。 再放送 $parent\\ tree$ ： 我们用存 $fa$ 的方式维护这棵 $parent\\ tree$ ，$fa[u]$ 里存的是它在 $parent\\ tree$ 里面的 直接父亲 。 用 $endpos$ 等价类的知识解释，就是 $u$ 等价类的 最长子串 ，它最长的那个 （不同等价类 的后缀）所在的等价类。比如上图中的 $\\mathtt{shenmadon}$ 所在等价类的 $fa$ ，就是 $\\mathtt{don}$ 所在等价类。 上面是在前面加字符的方法，那么在其后面加字符的方法呢？ 我们用 $ch[u][c]$ 来表示：在$u$ 结点 对应的等价类 的 最长子串后面 加上一个字符 $c$ ，形成的新字符串所属的等价类 对应的结点 。（参考 $\\mathtt{Trie}$ 上的连边） 你搁着读绕口令呢？/fn 你可能需要多读几遍格物致知，更口区的还没来呢。 _/ *这里讲的不好被小猫 @Schwarzkopf_Henkal D了，所以加一个例子 * /_ 举个栗子，假设我们的 $\\mathtt{shenmadon}$ 属于的等价类在 $u$ 结点，我们在后面加上 $\\mathtt{g}$ 变成 $\\mathtt{shenmadong}$ ， $\\mathtt{shenmadong}$ 归在等价类 $v$ ，那么我们有 $ch[u][‘g’-‘a’]=v$ 其实和 这道题 表达的意思差不多。 $ch$ 数组和 $parent\\ tree$ 没有什么直接关系，它不过是自动姬体内的一些连边。或者说我们要维护两个数据结构，一个是 $fa$ 维护的 $parent\\ tree$ ，一个是 $ch$ 维护的SAM姬体。 我们现在有了能伸能缩的方法，接下来就可以开始建造后缀自动姬辣！ _以下不再区分结点和结点所对应的等价类，这两个是同一个氡西_ $Step\\ 1$：构建前的准备工作我们需要明晰构建自动姬的方法为 增量法 。 简单点说就是自动姬每次吞进 一个字符 ，应对这个字符改变内部结构，再吞进下一个字符，以此往复。 每次吞字符的行为之间需要传递一些信息，除了以上提到的 $fa$ 和 $ch$ 照例保留外，还需要传递一个 $lst$ 变量，表示上一次 添加字符后的串 $s$ 所属的等价类。 显然，上一次加完字符后的串 $s$ ，一定是 $lst$ 这个等价类的 最长子串，这不难理解，毕竟 $s$ 甚至是目前所有子串中最长的一个，自然在它的类里也当人上人。 我们在最长子串 $s$ 后加上了一个字符 $c$ 形成了一个新串，根据性质四，我们知道这个新串将会归到一个 新的等价类 里。 所以我们开一个新点 $np$ ，表示 $s+c$ 所属的新等价类对应的结点。 如果我们称 $len(u)$ 为 $u$ 这个等价类 最长子串的长度 。暂时地，我们应使 $len(np)=len(p)+1$ ，因为 $np$ 目前的最长子串是由 $p$ 的最长子串加上 一个 字符 $c$ 变成的。 举个例子，我们当前构建到了 $\\mathtt{shenmad}$ ，它在 $endpos$ 集合 $\\{7\\}$ 里当人上人。 我们在它后面加一个字符 $\\mathtt{o}$ ，显然，新串 $\\mathtt{shenmado}$ 和原串已经不在同一个等价类中了，他早已成为 $\\{8\\}$ 集合的 最长子串 了。 这部分的瑇码～（人生苦短，我用结构体） 1234567891011121314151617181920212223242526272829303132struct node&#123; int len, fa; //len——最长子串长度,fa——（最长的（不同等价类的）后缀）所在的等价类 int ch[27]; node() &#123; memset(ch, 0, sizeof(ch)); len = fa = 0; &#125;&#125; T[MAX &lt;&lt; 1];int lst = 1, tot = 1;void add(int c)&#123; int p = lst;//取出当前最长子串所在等价类 int np = ++tot;//开一个新点 T[np].len = T[p].len + 1;//新等价类的len等于原等价类len+1 lst = tot;//更新最长子串所在类 ...... &#125;signed main()&#123; string s; cin &gt;&gt; s; int len = s.length(); for (int i = 0; i &lt; len; i++)//增量法 &#123; Tree.add(s[i] - &#x27;a&#x27;); &#125; ......&#125; $Step\\ 2$：遍历新串后缀，到第一个出现过的子串为止每当我们加入一个新字符，可能之前某些子串的 出现位置（即 $endpos$ 中的元素）就会变多。 具体地说，如果我们当前加到第 $n$ 位，有些新子串从来 没出现 过，需要多开一个 $\\{n\\}$ 等价类包含它们；有些新子串 曾经出现 过，它们的 $endpos$ 中就多一个 $n$ 。 我们需要找到这些新子串的出现位置。 这样的新子串满足什么性质呢？很简单，一定是 加字符之前 的原字符串的某个 后缀 ，再拼接上我们 现在加的这个字符 $c$ 。（所谓 $endpos$ 者，你甚至都不以 $c$ 为 $end$ ，凭什么让他给你贡献 $endpos$ 呢，这不公平。） 既然是后缀关系，对于拼上 $c$ 的新串，一定存在某一长度的后缀，使得长度 小于 它的其它后缀都出现过。 举个例子，我们的原字符串为 $\\mathtt{shenmadongdo}$ ，现在我们加上一个字符 $\\mathtt{n}$ ，定然只有 $\\mathtt{shenmadongdon,henmadongdon,enmadongdon,\\dots,don,on,n,}\\varnothing$ 这些串的 $endpos$ 可能会改变。 这其中，只有长度小于 $\\mathtt{don}$ 的后缀（$\\mathtt{don,on,n,}\\varnothing$）的 $endpos$ 将在原有基础上加上 $13$ ，其它的后缀都将归在 $\\{13\\}$ 这一类中。 这就需要我们从左往右遍历后缀，找到这个第一个出现过的后缀。 我们知道，根据『神马氡氡第一定律』，一个字符串 前面 加一个字符，将会把原来这个字符串的 $endpos$ 分割成若干（可能为一）份 ，在 $parent\\ tree$ 上，表现为 下分出几棵子树 。 古语有云：“水能载舟，亦可覆舟（亦可赛艇）”。 这启示我们我们以相反的方面看这一定律。（胡扯） 我们也可以说一个字符串 前面 删掉几个字符 ，在 $parent\\ tree$ 上，表现为 向上跳 $fa$（或原地不动） 。 我们称这是『神马氡氡第一引理』。 那么，一种十分女少的遍历后缀方法就呼之欲出了：在 $parent\\ tree$ 上，向上跳 $fa$ 。 我们再再放送 $parent\\ tree$ ： （越看越丑） 以 $\\mathtt{shenmadon}$ 为例，我们向上跳一级 $fa$ ，遍历到后缀 $\\mathtt{don}$ ，相当于在字符串前面删掉了 $6$ 个字符。再跳一级 $fa$ ，遍历到后缀 $\\mathtt{n}$ ，相当于在前面删掉了 $2$ 个字符。 这时，您可能会疑问，这样遍历后缀，难道不会漏掉很多在同一等价类里的后缀吗？这是好的。 我们说，遍历的作用，在于找到 第一个出现过的后缀 。 属于同一等价类的子串们，它们 $endpos$ 相同，在原串中的 出现情况 也相同。所以，我们只需查看每个等价类中的 一个串 （这里选用 最长子串 ），即可判断整个等价类是否曾经出现 。 高明！ 至于实现，看看瑇码： 1234567891011121314/*遍历后缀*/while (p &amp;&amp; !T[p].ch[c])//前面的p可以单纯地看做防止它跳出SAM//后面的则是看（p的最长子串+c字符）是否曾经出现&#123; T[p].ch[c] = np;//若未曾出现，则（p的最长子串+c）归于&#123;n&#125;这个等价类里 p = T[p].fa;//跳fa，遍历下一个后缀&#125;if (!p)//若之前是因跳出SAM而结束，那么说明（∅+c）=c 这个字符都从来没出现过&#123; T[np].fa = 1;//看来&#123;n&#125;这个集合需要连接超级根1。 return;&#125; $Step\\ 3$：自动姬的处理计划一还记得的吧，T[p].ch[c] 指向的是一个 等价类 。 假设我们已经用以上手段得到（某个长度的后缀+c）所处的 等价类（它就是上面瑇码中的 T[p].ch[c] ），能走到这里，说明这个后缀是第一个曾出现过的后缀。 设 $q=T[p].ch[c]$ ，我们需要知道 （ $p$ 的最长子串 + $c$ ） ，是否就是这个 $q$ 的 最长子串。这决定着我们该如何修改自动姬的结构。 看来我们需要 $\\mathbf{dark}$ 力分讨这个问题。 最凑巧的情况当然是（ $p$ 的最长子串 + $c$ ）就是 $q$ 的最长子串。 嘛，既然这个串是最长子串，那么根据性质二，显然，同等价类的其它子串们都将是它的 后缀 。 而我们之所以会揪出这个子串来，是因为这个最长子串的 $endpos$ 集合需要 增添 一个 $n$ 。那么根据性质一，它的 后缀 们也会增添一个 $n$ 。 那么我们直接令这整个集合 $q$ ，成为 $np$ （它对应 $\\{n\\}$ 等价类）的 $fa$ 即可。 为什么？根据『神马氡氡第一定律』，$q$ 中增添一个 $n$ ，即 $q$ 的等价类能够额外 分割 出一个 $\\{n\\}$ 等价类 ，即在 $parent\\ tree$ 上 $q$ 成为 $np$ 的 $fa$ 。 只需一步操作即可，最终的形态依然保证符合性质。这好吗？这很好。 举个例子，我们当前已经处理到了 $\\mathtt{shenmadongdon}$ ，正是大业将成的时候。此时我们应该在后面加上一个 $\\mathtt{g}$ ，经过 $Step\\ 1$ 的准备，我们开了一个新点 $np$ ，等价类为 $\\{14\\}$ ，最长子串为 $\\mathtt{shenmadongdong}$ 。 经过 $Step\\ 2$ 的遍历，我们最终在 $\\mathtt{don}$ 这个后缀所处的等价类 $p$ 上停了下来，这个 $\\mathtt{don}+\\mathtt{g}$ 之前已经出现过了。 我们把 $\\mathtt{dong}$ 所在的等价类 $ch[p][‘g’-‘a’]$ 取出来记作 $q$ ，当时这个等价类的最长子串恰好就是 $\\mathtt{dong}$ ，于是我们让 $np$ 的 $fa$ 等于 $q$ ，构建出一棵 $parent\\ tree$ ： （上面描述的操作发生在图上的最右侧，即 $\\mathtt{shenmadongdong}$ 所处等价类（$np$）的 $fa$ ，连向 $\\mathtt{dong}$ 所处等价类（$q$）） 这部分的瑇码： 1234567891011121314151617if(!p)&#123; ......&#125;//上接上文else&#123; int q = T[p].ch[c];//取出 q 这个等价类 if (T[q].len == T[p].len + 1)//这里是一个转化过的判断条件 //经过性质四的转化，这句话相当于：q的最长子串=p的最长子串+c &#123; T[np].fa = q;//q成为 np（即&#123;n&#125;）的 fa &#125; ......&#125; $Step\\ 4$：自动姬的处理计划二东坡居士曾写道：“人有悲欢离合，月有阴晴圆缺，此事古难全。” 有一说一确实，不可能每次加一个字符都能变出某个等价类的最长子串，不然您的欧气也钛好了。 我们需要进一步考虑 不是最长子串 的情况。 神 @华莱士 大佬提供了一个妙妙妙的理解方法。 我们用下三角图表示一个字符串的后缀们： 当前我们的原串是 $\\mathtt{shenmado}$ 。 图中用 $\\color{purple}{\\texttt{给}}$ 指导最喜欢的颜色标出 后缀所属的等价类 。当前这些后缀都归在同一个 $endpos=\\{8\\}$ 的等价类中。 我们此时将要添加一个字符 $\\mathtt{‘n’}$ ，根据 $Step\\ 2$ 的遍历，它停在了 $\\varnothing\\mathtt{+n}=\\mathtt{“n”}$ 这个后缀上。 按照早已设想的道路，$\\mathtt{n}$ 这个子串所在等价类的 $endpos$ 应当原先的基础上 添加 一个 $9$ ，变成 $\\{4,9\\}$ 。而其它的后缀 $\\mathtt{don,adon}$ 之类的应当归于 $\\{9\\}$ 。 对于等价类的定义，要求类内的 $endpos$ 相同，但现在我们发现这么一搞以后，现在这个等价类的 $endpos$ 不尽相同了。也就是说，我们需要把它 裂开 来，分裂成两个等价类，一部分为 $\\{9\\}$ ，另一部分为 $\\{4,9\\}$ 。（即：一部分是曾经出现过的，一部分是曾经没出现过的） 以上就是当（ $p$ 中最长子串 + $c$ ）不是 $q$ 中最长子串的大致处理提纲/cy。下面我们来康康细节。 我们分裂也不能白嫖空间啊，我们需要新创建一个结点 $nq$ ，来表示拆分出的两部分中，曾出现过 的那一部分（这里指图上的 $2$ ）。 之前的瑇码里我们看到，一个结点它有三个属性，$ch,fa,len$ ，我们来康康 $nq$ 需要具备怎样的属性。 首先看 $ch$ ，它表示的是在 后面 加字符后归在的等价类，肉眼观察法可得，$ch[nq]$ 和原来 $ch[q]$ 其实没有区别。那么 直接继承 $q$ 的 $ch$ 就是了。 为什么？ $nq$ 在分裂以前与 $q$ 的差别在且仅在于 $endpos$ ，而在后面加一个字符能转移到哪里，就不在 $endpos$ 决定的范围内了。 然后看 $len$ ，在 $Step\\ 2$ 中 $p$ 不断跳跳跳最后跳到了新串的某个 曾经出现 过的后缀。这个曾经出现的后缀属于的结点是 $q$ ，以 （当前 $p$ 的最长子串+c）的 长度 为界限，将分裂出了一块 $nq$ …… 那么显然，$nq$ 的 $len$ 等于（当前 $p$ 的最长子串+c）的长度，也就是 $len(nq)=len(p)+1$ 。 最后是 $fa$ 。$fa(q)$ 之前和 $q$ 在树上成父子关系，根据性质四，当时的 $len(fa(q))+1$ 必然等于 $minlen(q)$ ，也就是论 长度 而言，原 $len(fa(q))$ 与 $minlen(q)$ 紧密相接。 分裂后，$minlen(q)$ 必然被归到了 $nq$ 类里，所以 $nq$ 与原 $fa(q)$ 紧密相接，所以 $fa(nq)=fa(q)$。 同时，$nq$ 是从 $q$ 上 拆分 下来的，且 $nq$ 的 $len$ 小于 $q$ ，根据性质〇和一些推理， $nq$ 得变成 $q$ 的新 $fa$ 。 看上去就像一个链表的插入？ 但是我们还有一个非常严肃的问题存在，有些结点的 $ch[c]$ 指向的是 $q$ ，但是当我们分裂后，这些 $ch[c]$ 需要指向 $nq$ 。这就非常难搞，我们需要将 $ch$ 重定向 。 具体操作方法，我想先放瑇码： 12345while (p &amp;&amp; T[p].ch[c] == q)&#123; T[p].ch[c] = nq; p = T[p].fa;&#125; …… 这个靓仔是不是在哪里见过？ 我们把之前遍历后缀的瑇码部分拿出来对比： 12345while (p &amp;&amp; T[p].ch[c] == 0)&#123; T[p].ch[c] = np; p = T[p].fa;&#125; 发现相同之处了吧，这说明我们的重定向其实也同时在做一个 遍历 $p$ 的后缀 的工作。我们对这些遍历到的 后缀 进行重定向，这些后缀的 $ch[c]$ ，需要满足原先指向 $q$ 。 以上就是自动姬躯壳的全部组件，我们组装起来观赏一下完整瑇码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*Step 1*/struct node&#123; int len, fa; int ch[26]; int siz; node() &#123; siz = len = fa = 0; memset(ch, 0, sizeof(ch)); &#125;&#125; T[MAX];int tot = 1;int lst = 1;void add(int c)&#123; /*Step 2*/ int p = lst; int np = lst = ++tot; T[np].len = T[p].len + 1; while (p &amp;&amp; T[p].ch[c] == 0) &#123; T[p].ch[c] = np; p = T[p].fa; &#125; if (!p) &#123; T[np].fa = 1; &#125; else &#123; /*Step 3*/ int q = T[p].ch[c]; if (T[q].len == T[p].len + 1) &#123; T[np].fa = q; &#125; /*Step 4*/ else &#123; int nq = ++tot; T[nq] = T[q]; T[nq].len = T[p].len + 1; T[q].fa = T[np].fa = nq; while (p &amp;&amp; T[p].ch[c] == q) &#123; T[p].ch[c] = nq; p = T[p].fa; &#125; &#125; &#125;&#125;简单应用 判断一个串 $A$ 是否是另一个串 $B$ 的子串真就把 SAM 当成AC自动姬来用呗。 对 $B$ 建一棵SAM，一个一个吞进 $A$ 的字符，每吞进一个字符，在 SAM 上走对应的 $ch$ 边。（因为 $ch$ 的本质就是在一个串的后面加字符）。 没有板子。 本质不同子串个数我们知道 SAM 结点的一个很 $\\mathbf{dark}$ 的特点：它代表的是一整个 等价类，并且根据性质二，它们之间 没有交 。 这样我们大致有了个口胡想法，对 等价类大小 求和，这样可以做到不重不漏。 那么怎么求和呢，细化地说，我们如何知道一个等价类里有多少元素呢？ 根据四， $minlen(u)=maxlen(fa(u))+1$ ，又因为类内长度 连续 ，那么，类内元素个数 $n=maxlen(u)-(maxlen(fa(u))+1)+1=maxlen(u)-maxlen(u)$ 。 那么只需统计 $\\sum(maxlen(u)-maxlen(u))$ 即可～ 板子题一：P2408 不同子串个数 放一下瑇码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAX = 1e5 + 7;struct node&#123; int ch[27]; int len, fa; node() &#123; len = fa = 0; memset(ch, 0, sizeof(ch)); &#125;&#125; T[MAX &lt;&lt; 1];int sum = 0;struct SAM&#123; int tot = 1, lst = 1; /*SAM 组件*/ void add(int c) &#123; int p = lst; int np = lst = ++tot; T[np].len = T[p].len + 1; while (p &amp;&amp; T[p].ch[c] == 0) &#123; T[p].ch[c] = np; p = T[p].fa; &#125; if (p == 0) &#123; T[np].fa = 1; &#125; else &#123; int q = T[p].ch[c]; if (T[q].len == T[p].len + 1) &#123; T[np].fa = q; &#125; else &#123; int nq = ++tot; T[nq] = T[q]; T[nq].len = T[p].len + 1; T[q].fa = T[np].fa = nq; while (p &amp;&amp; T[p].ch[c] == q) &#123; T[p].ch[c] = nq; p = T[p].fa; &#125; &#125; &#125; sum += (T[np].len - T[T[np].fa].len);//统计 &#125;&#125; Tree;int N;signed main()&#123; cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) &#123; char c; cin &gt;&gt; c; Tree.add(c - &#x27;a&#x27;); &#125; cout &lt;&lt; sum &lt;&lt; endl;&#125; 板子题二：[SDOI2016]生成魔咒 同，瑇码不放了。 获取两个串的最长公共子串的长度对于其中任意一个串（称为原串）建SAM，像子串判别一样，一个一个吞进另一个串（称为匹配串）的字符。 但不同的是，子串判别是一旦没有了 $ch[c]$ 的转移就返回 0 ，而获取公共子串则是 “遇事不决先跳 $fa$ ”，相当于在前面 删掉一些字符 ，再尝试转移一下。同时根据转移到的位置，实时更新当前匹配长度 $cur$ 。 当一个字符处理完后，记当前 $cur$ 为 $maxl[i]$ ，表示从匹配串的第 $i$ 位 向前，两串最长匹配了多长。 最终的答案就是 $maxl$ 中最大的一个。 板子题：SP1811 LCS - Longest Common Substring 放一下瑇码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 3e5 + 7;struct node&#123; int len, fa; int ch[26]; node() &#123; len = fa = 0; memset(ch, 0, sizeof(ch)); &#125;&#125; T[MAX &lt;&lt; 1];int tot = 1, lst = 1;/*SAM组件*/void add(int c)&#123; int p = lst; int np = lst = ++tot; T[np].len = T[p].len + 1; while (p &amp;&amp; T[p].ch[c] == 0) &#123; T[p].ch[c] = np; p = T[p].fa; &#125; if (p == 0) &#123; T[np].fa = 1; &#125; else &#123; int q = T[p].ch[c]; if (T[q].len == T[p].len + 1) &#123; T[np].fa = q; &#125; else &#123; int nq = ++tot; T[nq] = T[q]; T[nq].len = T[p].len + 1; T[q].fa = T[np].fa = nq; while (p &amp;&amp; T[p].ch[c] == q) &#123; T[p].ch[c] = nq; p = T[p].fa; &#125; &#125; &#125;&#125;string s;string t;int ans = 0;int maxl[MAX];int main()&#123; cin &gt;&gt; s &gt;&gt; t; int len = s.length(); s = &#x27; &#x27; + s; for (int i = 1; i &lt;= len; i++) &#123; add(s[i] - &#x27;a&#x27;); &#125; len = t.length(); t = &#x27; &#x27; + t; int p = 1;//p 当前所在结点 int cur = 0;// cur 当前匹配长度 for (int i = 1; i &lt;= len; i++) &#123; int v = t[i] - &#x27;a&#x27;; if (T[p].ch[v])//能转移则转移 &#123; cur++; p = T[p].ch[v]; &#125; else &#123; while (p &amp;&amp; !T[p].ch[v])//不能转移先跳 fa &#123; p = T[p].fa; &#125; if (!p)//倘若跳到头了都不能转移 &#123; cur = 0; p = 1;//则重置之 &#125; else &#123; cur = T[p].len + 1;//否则转移 p = T[p].ch[v];//注意更新顺序 &#125; &#125; maxl[i]=cur; ans = max(ans, maxl); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 获取多串的最长公共子串首先，我们有一个非常暴力的想法，对除了第一个串以外的所有串建 SAM ， 再把第一个串当作 匹配串 ，放到这些 SAM 上去跑，一个字符处理完后，对 $maxl$ 取 $\\min$ ，最后取 $maxl$ 中的 最大值。 其次，以上是正解。 为什么？ $maxl$ 的定义是匹配串第 $i$ 位往前最长匹配到了多长。 这个氡氡显然 只与 匹配串，也就是第一个串有关。那么，在每一次跑之间，它们跑出来的信息是可以 叠加 的。 那么我们多次取 $\\min$ ，也是被允许的 QaQ 。 板子题一： LCS2 - Longest Common Substring II 板，以下是瑇码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 2e5 + 7;struct node&#123; int len, fa; int ch[26]; int siz; node() &#123; siz = len = fa = 0; memset(ch, 0, sizeof(ch)); &#125;&#125; T[MAX];int tot = 1;int lst = 1;/*SAM组件*/void add(int c)&#123; int p = lst; int np = lst = ++tot; T[np].len = T[p].len + 1; T[np].siz = 1; while (p &amp;&amp; T[p].ch[c] == 0) &#123; T[p].ch[c] = np; p = T[p].fa; &#125; if (!p) &#123; T[np].fa = 1; &#125; else &#123; int q = T[p].ch[c]; if (T[q].len == T[p].len + 1) &#123; T[np].fa = q; &#125; else &#123; int nq = ++tot; T[nq] = T[q]; T[nq].siz = 0; T[nq].len = T[p].len + 1; T[q].fa = T[np].fa = nq; while (p &amp;&amp; T[p].ch[c] == q) &#123; T[p].ch[c] = nq; p = T[p].fa; &#125; &#125; &#125;&#125;string t;//第一个串，即匹配串char s[MAX];//因为不得不用scanf输入所以被迫用char*int maxl[MAX];//t[i]向前最长匹配到多长/*多次建SAM，需要初始化*/void init()&#123; for (int i = 1; i &lt;= tot; i++) &#123; T[i] = node(); &#125; tot = lst = 1;&#125;int main()&#123; cin &gt;&gt; t; int kk = t.length(); t = &#x27; &#x27; + t; memset(maxl, 63, sizeof(maxl));//赋极大值 while (scanf(&quot;%s&quot;, s + 1) != -1)//它不说有多少个串就很烦 &#123; init(); int len = strlen(s + 1); for (int i = 1; i &lt;= len; i++) &#123; add(s[i] - &#x27;a&#x27;);//建SAM &#125; /*跳SAM，跑匹配*/ int p = 1; int cur = 0; for (int i = 1; i &lt;= kk; i++) &#123; int v = T[p].ch[t[i] - &#x27;a&#x27;]; if (v) &#123; p = v; cur++; &#125; else &#123; while (p &amp;&amp; !T[p].ch[t[i] - &#x27;a&#x27;]) &#123; p = T[p].fa; &#125; if (p == 0) &#123; p = 1; cur = 0; &#125; else &#123; cur = T[p].len + 1; p = T[p].ch[t[i] - &#x27;a&#x27;]; &#125; &#125; maxl[i] = min(maxl[i], cur);//对maxl[i]取min &#125; &#125; int ans = 0; for (int i = 1; i &lt;= kk; i++) &#123; ans = max(ans, maxl[i]);//取maxl中最大的 &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 板子题二：[SDOI2008]Sandy的卡片 对 差分数组 做多串匹配就好力。 求第 $k$ 大子串在之前的应用中，您一定已经熟练运用 SAM 暴切各种子串计数题了。（ 而求第 $k$ 大子串正是基于子串统计，您必然又能切个爽。 这一大类问题又细分成两小类：本质不同和位置不同。 我们逐一阐述。 本质不同 要求我们忽略 出现位置 的差异进行计数，对于每一位字符，根据字典序判定大小。 首先，我们需要根据SAM上 $ch$ 的转移，构建出一张 DAG 。再以 $1$ 号结点（代表空串的结点）为根，取一棵 26叉生成树 （严谨来说不是，但这样感性理解就够了）。 然后，我们要在这个树上瞎jb跳。 具体地，当我们到达了某个点，我们从 $a$～$z$ 枚举出边，若该子树所包含的子串数 小于 $k$ ，则跳过，当前 $k$ 减去该子树内子串的个数，决策下一条出边。 直到找到第一条出边，其去向子树的 $size$ 大于等于 了当前的 $k$ ，则跳向该子树，相当于当前位选择了 这条出边指向的字符 ，进入下一位的决策…… 讲得不明不白，建议作者多学点语文再来这里说话。 如果是不懂思想可以左转 《紫题算法学习实况》 $fhq-treap$ 实现查询第 $k$ 大部分（无端推销）。 建议直接看这部分的瑇码： 12345678910111213141516171819202122void dfs(int u, int k)&#123; k--;//先减去自己 if (k == 0)//若为0说明这就是第k大 return; for (int i = 0; i &lt; 26; i++)//枚举出边 &#123; if (T[u].ch[i]) &#123; if (dp[T[u].ch[i]] &lt; k)//若小于则跳过 &#123; k -= dp[T[u].ch[i]];//减去这些子串 &#125; else &#123; cout &lt;&lt; (char)(&#x27;a&#x27; + i);//该位选择了这个字符 dfs(T[u].ch[i], k);//进入下一位的决策 return; &#125; &#125; &#125;&#125; 我们注意到瑇码里有个 $dp$ 数组，他是干甚么的？根据注释可知，这代表某个 子树内子串 的数量。 但如何求 $dp$ 呢？我们用树形 $dp$ 来搞。 这就是赤裸裸的 子树和 问题，那么这个 $\\orange{\\texttt{普及-}}$ 树形dp就没有手也行了： dp_u=1+\\sum_{v\\in son(u)}dp_v下面是瑇码： 1234567891011121314151617int dp[MAX];void DP(int u)&#123; if (dp[u]) &#123; return; &#125; dp[u] = 1; for (int i = 0; i &lt; 26; i++)//遍历儿子 &#123; if (T[u].ch[i]) &#123; DP(T[u].ch[i]); dp[u] += dp[T[u].ch[i]]; &#125; &#125;&#125; 行百里者半九十，我们乘胜追击，把 位置不同 一起淦掉。 仔细观察前几题的瑇码会发现，笔者像背板似的在 SAM 还维护了一个东西： T[].siz 它是来干嘛的？ 我们先认真撕♂尻这样一个问题，我们在SAM里加点，加哪些点的时候会有新串产生，加哪些点的时候不会呢？ 加 $np$ 的时候一定是会产生新串的，这点根据定义就可知， $np$ 本身就是我们在原串后 新加字符 时的产物。 加 $nq$ 的时候呢？我们其实没有新字符吞进自动姬，只是自动姬自己内部的结点 裂开来 而已，串还是那些串，不过是分到了两个等价类罢了/kk 。 所以我们说加 $np$ 会产生新串，加 $nq$ 不会。 那么这个 T[].siz 其实就是某个点 对子串数的贡献 。我们对 T[np].siz 初始化为 $1$ ， 对 T[nq].siz 初始化为 $0$ 。 _需要注意的是 siz 不等于某结点代表的子串数，它是一种贡献，可以看作是一种 差分标记（或许可以这么理解？）_ 再放送SAM加字符瑇码，加深印象（水字数）： 123456789101112131415161718void add(int c)&#123; ...... int np = lst = ++tot; T[np].siz = 1;//mark ...... else &#123; ....... else &#123; int nq = ++tot; T[nq] = T[q]; T[nq].siz = 0;//mark ...... &#125; &#125;&#125; 这时我们再跑树形 dp ，就得换一个转移方程了。 我们需要先把每个结点 对应的子串数 获取出来，我们说 $siz$ 相当于 差分标记 其实是有原因的，见下qwq：（ $dp2$ 代表某结点（等价类）中的 子串数 ） dp2_u=T[u].siz +\\sum_{v\\in son(u)}dp2_v然后再跑常规的路径统计： dp_u=dp2_{u}+\\sum_{v\\in son(u)}dp_v好吧依然是没有手也行。 板子题一：SP7258 SUBLEX - Lexicographical Substring Search 只要求本质不同，连 siz 都不用写。 瑇码详见后面。 板子题二：[TJOI2015]弦论 抓～紧～时～间～打～板～子～ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1e6 + 7;/*SAM组件*/struct node&#123; int len, fa; int siz; int ch[26]; node() &#123; len = fa = 0; memset(ch, 0, sizeof(ch)); &#125;&#125; T[MAX];struct SAM&#123; int tot = 1, lst = 1; void add(int c) &#123; int p = lst; int np = lst = ++tot; T[np].siz = 1;//mark T[np].len = T[p].len + 1; while (p &amp;&amp; !T[p].ch[c]) &#123; T[p].ch[c] = np; p = T[p].fa; &#125; if (!p) &#123; T[np].fa = 1; &#125; else &#123; int q = T[p].ch[c]; if (T[q].len == T[p].len + 1) &#123; T[np].fa = q; &#125; else &#123; int nq = ++tot; T[nq] = T[q]; T[nq].siz = 0;//mark T[nq].len = T[p].len + 1; T[q].fa = T[np].fa = nq; while (p &amp;&amp; T[p].ch[c] == q) &#123; T[p].ch[c] = nq; p = T[p].fa; &#125; &#125; &#125; &#125;&#125; Tree;int kk = 0;namespace st1//本质不同&#123; int dp[MAX]; inline void DP(int u)//树形dp，求子树和 &#123; if (dp[u]) &#123; return; &#125; dp[u] = 1; for (register int i = 0; i &lt; 26; i++) &#123; if (T[u].ch[i]) &#123; DP(T[u].ch[i]); dp[u] += dp[T[u].ch[i]]; &#125; &#125; &#125; inline void dfs1(int u, int k)//求第k大 &#123; k--; if (k == 0) &#123; return; &#125; for (register int i = 0; i &lt; 26; i++) &#123; if (T[u].ch[i]) &#123; if (dp[T[u].ch[i]] &lt; k) &#123; k -= dp[T[u].ch[i]]; &#125; else &#123; cout &lt;&lt; (char)(&#x27;a&#x27; + i); kk = 1; dfs1(T[u].ch[i], k); return; &#125; &#125; &#125; &#125; void MAIN() &#123; DP(1); int k; cin &gt;&gt; k; dfs1(1, k + 1);//是k+1，因为这会被空串消耗一次 &#125;&#125; // namespace st1namespace st2&#123; int dp2[MAX]; struct edge &#123; int next, to; &#125; e[MAX &lt;&lt; 1]; int head[MAX], eid = 1; inline void adde(int x, int y) &#123; e[++eid].next = head[x]; e[eid].to = y; head[x] = eid; &#125; inline void DP2(int u)//树形dp，求每个结点对应子串数 &#123; dp2[u] = T[u].siz; for (register int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; DP2(v); dp2[u] += dp2[v]; &#125; &#125; int f[MAX]; inline void redfs(int u)//再次树形dp，求子树和 &#123; f[u] = dp2[u]; for (register int i = 0; i &lt; 26; i++) &#123; if (T[u].ch[i]) &#123; if (!f[T[u].ch[i]]) &#123; redfs(T[u].ch[i]); &#125; f[u] += f[T[u].ch[i]]; &#125; &#125; &#125; inline void dfs2(int u, int k)//求第k大 &#123; k -= dp2[u];//注意：这里被消耗的是 dp2[u] 这么多 if (k &lt;= 0) &#123; return; &#125; for (register int i = 0; i &lt; 26; i++) &#123; if (T[u].ch[i]) &#123; if (f[T[u].ch[i]] &lt; k) &#123; k -= f[T[u].ch[i]]; &#125; else &#123; cout &lt;&lt; (char)(&#x27;a&#x27; + i); dfs2(T[u].ch[i], k); return; &#125; &#125; &#125; &#125; void MAIN() &#123; for (register int i = 2; i &lt;= Tree.tot; i++) &#123; adde(T[i].fa, i); &#125; DP2(1); dp2[1] = 0; int k; cin &gt;&gt; k; redfs(1); if (k &gt; f[1]) &#123; cout &lt;&lt; -1; return; &#125; dfs2(1, k); &#125;&#125; // namespace st2char s[MAX];signed main()&#123; ios::sync_with_stdio(0); cin &gt;&gt; s + 1; int len = strlen(s + 1); for (register int i = 1; i &lt;= len; i++) &#123; Tree.add(s[i] - &#x27;a&#x27;); &#125; int opt; cin &gt;&gt; opt; if (opt) &#123; st2::MAIN(); &#125; else &#123; st1::MAIN(); &#125;&#125; 说句闲话：或许 “本质不同” 其实就是 “位置不同” 的 dp2=1 的特殊情况罢…… 获取循环同构的出现情况首先你需要知道甚么是循环同构，我们把一个字符串 $t$ 的 第一个字符放到最后 ，就形成了一个新串，如此往复，它一共会形成 $t.length$ 个新串。 我们把这些新串拿去在另一个串上匹配，看看能匹配上多少。 深得暴力要义的神仙一定已经准备打好多串匹配的代码了，但是除非你是松怪，否则出题人不可能不卡掉你。 我们需要 深入了解 后缀自动姬的工作机理。 我们知道跳 $fa$ 相当于在前面删字符，跳 $ch$ 相当于在后面加字符，所以…… 我知道了，但你出言不逊是 ，我们只需要玩 转 后缀自动姬的精妙结构即可，具体步骤如下： _设匹配串原长为 $n$_ 先对被匹配的串建一只 SAM 读入匹配串，用 子串判定 类似的方法，能转移则转移，不能转移就跳 $fa$ ，不断在SAM上跳结点。 把整个串都跳完以后，看看当前跳到的结点的 $len$ 是否 等于 $n$ 。若等于，则说明这是一种在原串中出现过的串，统计进贡献。 着手在末尾添加字符。照样是能转移则转移，不能转移就跳 $fa$ 。 着手删去第一个字符。如果 $n-1$ 小于 了该结点的最大长度 $len$ ，$\\mathbf{dark}$ 力跳 $fa$ ，否则啥也不干。 看看当前跳到的结点的 $len$ 是否 等于 $n$ 。若等于，则说明这是一种在原串中出现过的串，统计进贡献。 如此往复 4.5.6 三步，进行 $n-1$ 遍即可。 板子题： CF235C Cyclical Quest 太 板 了，具体实现看瑇码+注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 2e6 + 7;/*SAM组件*/struct node&#123; int len, fa; int ch[26]; int siz; node() &#123; siz = len = fa = 0; memset(ch, 0, sizeof(ch)); &#125;&#125; T[MAX];int tot = 1;int lst = 1;struct edge&#123; int next, to;&#125; e[MAX &lt;&lt; 1];int head[MAX], eid = 1;inline void adde(int x, int y)&#123; e[++eid].next = head[x]; e[eid].to = y; head[x] = eid;&#125;inline void add(int c)&#123; int p = lst; int np = lst = ++tot; T[np].len = T[p].len + 1; T[np].siz = 1; while (p &amp;&amp; T[p].ch[c] == 0) &#123; T[p].ch[c] = np; p = T[p].fa; &#125; if (!p) &#123; T[np].fa = 1; &#125; else &#123; int q = T[p].ch[c]; if (T[q].len == T[p].len + 1) &#123; T[np].fa = q; &#125; else &#123; int nq = ++tot; T[nq] = T[q]; T[nq].siz = 0; T[nq].len = T[p].len + 1; T[q].fa = T[np].fa = nq; while (p &amp;&amp; T[p].ch[c] == q) &#123; T[p].ch[c] = nq; p = T[p].fa; &#125; &#125; &#125;&#125;/*dfs处理各个等价类的出现次数*/int vis[MAX], dp[MAX];inline void dfs(int u)&#123; dp[u] = T[u].siz; for (register int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; dfs(v); dp[u] += dp[v]; &#125;&#125;inline void init()&#123; memset(vis, 0, sizeof(vis));&#125;int main()&#123; string t; cin &gt;&gt; t; int CC; cin &gt;&gt; CC; int kk = t.length(); t = &#x27; &#x27; + t; for (register int i = 1; i &lt;= kk; i++) &#123; add(t[i] - &#x27;a&#x27;);//增量法 &#125; for (register int i = 2; i &lt;= tot; i++) &#123; adde(T[i].fa, i);//连边 &#125; dfs(1); for (int C = 1; C &lt;= CC; C++) &#123; int ans = 0; string s; cin &gt;&gt; s; int len = s.length(); s = &#x27; &#x27; + s; int p = 1, cur = 0; for (register int i = 1; i &lt;= len; i++)//先跳匹配串，对应步骤2 &#123; while (p &amp;&amp; T[p].ch[s[i] - &#x27;a&#x27;] == 0) &#123; p = T[p].fa; cur = T[p].len; &#125; if (T[p].ch[s[i] - &#x27;a&#x27;]) &#123; cur++; p = T[p].ch[s[i] - &#x27;a&#x27;]; &#125; &#125; if (cur == len)//统计，对应步骤3 &#123; if (vis[p] &lt; C) &#123; ans += dp[p]; vis[p] = C;//打标记，以防重复统计 &#125; &#125; for (register int i = 1; i &lt;= len - 1; i++) &#123; while (p &amp;&amp; T[p].ch[s[i] - &#x27;a&#x27;] == 0)//末尾添加字符，对应步骤4 &#123; p = T[p].fa; cur = T[p].len; &#125; if (T[p].ch[s[i] - &#x27;a&#x27;]) &#123; cur++; p = T[p].ch[s[i] - &#x27;a&#x27;]; &#125; if (cur &gt; len &amp;&amp; --cur == T[T[p].fa].len)//前面删字符，对应步骤5 &#123; p = T[p].fa; &#125; if (cur == len)//统计，对应步骤6 &#123; if (vis[p] &lt; C)//为防止清空标记太耗时，故看标记的标号，以辨别不同的询问 &#123; ans += dp[p]; vis[p] = C; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 广义 SAM不会，不懂，不想写。（鸽子三连） $\\text{LCT}$ （动态树）“一杯茶，一包烟，一棵LCT调亿天。” 这是神马东东？一种维护树上信息的 灵活 的数据结构。（灵活，指在网上看到无数种不同的写法），其最大的特点在于能够 动态加边断边 。 您会在接下来很多地方见识到所谓“灵活”的一面。 原理？把序列上问题强行上树可以变成 毒瘤 ，相反地，把树上问题剖到序列上就会变得清新。 于是 树链剖分 横空出世，其下有重剖、长剖、虚实链剖分三类。 重剖和长剖比较守序，它们都是按树形态的 某一特征 去剖分。 到了虚实链剖分就开始放飞自我了，怎么剖分是随着人为的操作去决定的。作为一个 灵活 的数据结构， $\\text{LCT}$ 选择的就是虚实链剖分。 树剖需要一个珂爱的DS来帮助维护剖出的一条一条 链信息 ，因为我们有加边删边， 相对静态 的线段树就显得朝不保夕。我们把目光投向了平衡树。 在那么多平衡树里， $splay$ 受到了人类的青睐，它对结点的 添加、删除、移动 可以说是行云流水，流畅异常。 所以我们选中 $splay$ 作为辅助维护链信息的DS（后文称之为辅助树），而这里的 $splay$ ，瑇码更近似于《文艺平衡树》。 _闲话：其实 fhq-treap 也能做 qwq ，只是多了个 log 罢了_ 实现？接下来，我们尝试用这个 “灵活” 的 LCT ，来实现加边、删边、路径加、路径乘、路径求和。 为了装腔作势借以吓人， 我们列举一下一棵 LCT 需要打的珂怕的函数们： 正统 $splay$ 系：$iden$，$push_up$，$push_down$ $splay\\;\\times\\;LCT$ 混血 （趋近LCT国情的 $splay$ 写法改造）：$isroot$，$rotate$，$splay$ $LCT$ 本地居民：$access$，$make_root$，$split$，$find$，$link$，$cut$ 作者意识到自己LCT只会背板子，得找时间深♂入重学 回滚莫队果然还是小清新数据结构适合我。 这是神马氡氡如果我有一个区间询问，是 $\\mathcal{O}(1)$ 插入， $\\mathcal{O}(inf)$ 删除的。 普通的莫队在这里就GG了，因为他不可避免地要删除。 此时回滚莫队横空出世。 这是一种能有效鸽掉 插入/删除 之间任意一种操作的高级膜队技巧。 思想？？？删除不能，那我还不能暴力呗。 这是一个臭数组，已经被野兽先辈偷偷用 $sqrt(n)$ 分好了块： 假设我们求 $[3,5]$ 的区间众数，这玩意加入新元素很轻松，但是删除元素就有些危机。 从 $L$ 到 $R$ ，这是 $L$ （3），这是 $R$ （5）。这些边我不加，这些边我不加！ 暴力怎么做？暴力是不是？装桶，装桶，装桶，然后 $for$ 循环查询。 这个是要用的，先打好。 123456789101112131415161718192021int c[MAX];int baoli(int l, int r)&#123; int ans = 0; for (int i = l; i &lt;= r; i++) &#123; c[num[i]]++;//装桶装桶 &#125; for (int i = l; i &lt;= r; i++) &#123; if (c[num[i]] &gt; c[ans])//for循环查询 &#123; ans = num[i]; &#125; &#125; for (int i = l; i &lt;= r; i++)//珍爱生命，远离memset &#123; c[num[i]]--; &#125; return ans;&#125; 这个暴力看上去十分 naive ，接下来，回滚莫队将会展现块与块之间的信息交流的真正妙处。 对于这个 $[3,5]$ 的区间查询，我们先把两个指针，都拉到 $3$ 所在这个块的右边，夹出一块 空区间。 _注：L指针永远指向一格的左边，R指针永远指向一格的右边，以此表示[L,R]是闭的。_ 首先我们优先移动 $R$ 指针，它会不断移移移，一路上 add(++R) 。 当我们把 $R$ 移到 $5$ 的时候，我们先 在这停顿 ，记录下此时更新到的 众数 $maxx$ ，开一个变量 $store=maxx$ ，显然 $store=1$ 。 这时，我们再向左移动 $L$ 指针，它会不断移移移，一路上 add(--L) 。 等我们移到 $3$ 的时候，我们获得了对于该询问的答案，记录之。 这时我们要询问 $[4,5]$ 了，但我们意识到一个很严肃的问题：如果删了众数，我们的程序无法知道他的继承人是谁。 我们之前不是保存了一个 $store$ 表示上图当时情况下的 $maxx$ 吗，我们选择在回答完 $[3,5]$ 后 恢复 $L$ 指针到 块右边界 。 由此一来，两个指针又形成了上图的形势，我们又可以重新任用我们的 $store$ 作为 $maxx$ 了。 以下是处理询问部分的瑇码： 123456789101112131415161718/*tot——当前处理的询问排序后的编号 ，i——该询问左端点所在块 */while (R &lt; q[tot].r)//移右指针&#123; add(++R);&#125;int store = maxx;//在这停顿while (L &gt; q[tot].l)//移左指针&#123; add(--L);&#125;COUT[q[tot].id] = maxx;//保存答案maxx = store;//重新任用store作为maxxwhile (L &lt;= rm[i])//恢复现场&#123; cnt[num[L++]]--;//把被加上的cnt减回来&#125; 您可能会感到困惑，为什么又有一个 $tot$ ，又有一个 $i$ 。我们到底在枚举什么？ 其实理解了上述思想就自证不难了，我们每次需要把 $L$ 指针移到块右边界，又因膜队的精髓在于尽可能鸽掉 端点的移动 ，所以我们必然是枚举 块（i） 更河里，而 $tot$ 只是顺带着枚举一枚举。 但是还有一个问题，我们每次是把 $R$ 端点右移，我们不能左移 $R$ ，因为左移意味着 删除 ，而 $R$ 一开始又是在块的右边界上，也就默认了这个询问必然会 跨块 ，那不跨块的询问怎么办？ 别忘了我们的暴力怎么做。不跨块询问区间内元素是 $\\sqrt{N}$ 级别的，自然可以放心大胆地暴力。 所以核心瑇码就是这样的： 123456789101112131415161718192021222324252627282930313233343536int L = 1, R = 0;int tot = 1;for (int i = 1; i &lt;= B; i++)//B是块数，这里是枚举块&#123; memset(cnt, 0, sizeof(cnt)); maxx = 0;//归零面对新块 R = rm[i];//R指针放在右边界 while (block[q[tot].l] == i)//对于所有左端点在这个块里的 &#123; L = rm[i] + 1;//左端点移到右边界+1，以表空区间 if (q[tot].r - q[tot].l &lt;= M)//小于根号，暴力好耶 &#123; COUT[q[tot].id] = baoli(q[tot].l, q[tot].r); &#125; else//不再重复 &#123; while (R &lt; q[tot].r) &#123; add(++R); &#125; int store = maxx; while (L &gt; q[tot].l) &#123; add(--L); &#125; COUT[q[tot].id] = maxx; maxx = store; while (L &lt;= rm[i]) &#123; cnt[num[L++]]--; &#125; &#125; tot++; &#125;&#125; 如果您 naive 地随手上了一个奇偶排序优化，那么之前的努力全部木大。 因为右端点只许右移，所以排序时同块的询问只能以 右端点递增 排序。 我们甚至可以用回滚莫队水掉大部分普通莫队的题，复杂度也没差，几乎就是上位了。（当然询问的东西太大（比如一个栈），不能低复杂度保存和重新启用时，还是只能普通莫队） 劲爆例题：板子题：歴史の研究 比【模板】还模板的模板题。 要求的是 $\\max\\{num[i]\\cdot cnt[num[i]]\\}$ 。 这个东西好增不好删，我们着手使用只增不删回滚莫队。 $\\text{add}$ 时不断更新 $maxx$ ，回答完一个询问就直接洗地。 存在一个注意点是，这题需要离散化，而上面公式里的第一个 $num[i]$ 应是 离散化前 的原值。（可能只有我这种弱智才会因为这个犯错） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 2e5 + 7;#define int long longstruct query&#123; int l, r, id;&#125; q[MAX];int block[MAX];bool cmp(query a, query b)&#123; if (block[a.l] != block[b.l]) &#123; return a.l &lt; b.l; &#125; return a.r &lt; b.r;&#125;int N, Q;int M, B;int cnt[MAX];int num[MAX];int tmp[MAX];int sum = 0;void lsh()&#123; memcpy(tmp, num, sizeof(num)); sort(tmp + 1, tmp + 1 + N); for (int i = 1; i &lt;= N; i++) &#123; num[i] = lower_bound(tmp + 1, tmp + 1 + N, num[i]) - tmp; &#125;&#125;void add(int p)&#123; cnt[num[p]]++; sum = max(sum, tmp[num[p]] * cnt[num[p]]); //因为原数组被复制到了tmp数组里去，num[p]其实是其下标 //所以tmp[num[p]]就是原值了&#125;int c[MAX];int baoli(int l, int r)&#123; int kel = 0; for (int i = l; i &lt;= r; i++) &#123; c[num[i]]++; &#125; for (int i = l; i &lt;= r; i++) &#123; kel = max(kel, c[num[i]] * tmp[num[i]]); &#125; for (int i = l; i &lt;= r; i++) &#123; c[num[i]]--; &#125; return kel;&#125;int lm[MAX], rm[MAX];void pre()&#123; B = N / M; for (int i = 1; i &lt;= B; i++) &#123; lm[i] = rm[i - 1] + 1; rm[i] = lm[i] + M - 1; &#125; if (N % M) &#123; B++; lm[B] = rm[B - 1] + 1; rm[B] = N; &#125;&#125;int COUT[MAX];signed main()&#123; cin &gt;&gt; N &gt;&gt; Q; M = sqrt(N); for (int i = 1; i &lt;= N; i++) &#123; cin &gt;&gt; num[i]; block[i] = (i - 1) / M + 1; &#125; for (int i = 1; i &lt;= Q; i++) &#123; cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].id = i; &#125; sort(q + 1, q + 1 + Q, cmp); pre(); lsh();//离散化 /*回滚莫队板子*/ int L = 1, R = 0; int tot = 1; for (int i = 1; i &lt;= B; i++) &#123; memset(cnt, 0, sizeof(cnt)); sum = 0; R = rm[i]; while (block[q[tot].l] == i) &#123; L = rm[i] + 1; if (q[tot].r - q[tot].l &lt;= M) &#123; COUT[q[tot].id] = baoli(q[tot].l, q[tot].r); &#125; else &#123; while (q[tot].r &gt; R) &#123; add(++R); &#125; int store = sum; while (q[tot].l &lt; L) &#123; add(--L); &#125; COUT[q[tot].id] = sum; sum = store; while (L &lt;= rm[i]) &#123; cnt[num[L++]]--; &#125; &#125; tot++; &#125; &#125; for (int i = 1; i &lt;= Q; i++) &#123; cout &lt;&lt; COUT[i] &lt;&lt; endl; &#125;&#125; 板子题二：【模板】回滚莫队&amp;不删除莫队 不板的丢人模板题 要求 相距最远的相同数 的距离。 某个数的 极左/极右出现位置 ($fir[i],rig[i]$) 或许很好装，也便于 $\\mathcal{O}(1)$ 更新， $\\mathcal{O}(1)$ 算答案（ $rig[i]-fir[i]$ ）。 但是我们洗地会极其低效，何出此言？ 因为极左这个 “极” 字意味着我们不是那么容易恢复现场。举个例子：（这个数组里的臭气被稍加稀释） 回答完 $[1,6]$ 这个询问后，我们是把 $L$ 指针恢复到块右边界，一路上把 $fir[num[i]]$ 清空成 $0$ 。 但如果我们把 $fir[4]$ 清空成 $0$ ，这说明它不再出现。可事实上，$4$ 这个数却确确实实存在于 $L$ 和 $R$ 之间。 如果接下来查询的是 $[2,6]$ ，我们就出锅了，因为我们不再知道在 $3$ 号位置上还有一只 $4$ 。 意识到 $fir$ 的能力是有极限（右边界）的， 维护的数的位置 越是在 左端点所在块 外，清空效力就越鞭长莫及。 所以，我不维护啦，JOJO！ 这里就分出三种情况来： 对于所有相同数都在块内的情况，我们 $fir$ 是可以顺利完成清空的（从左往右扫，最终清空全块）。 对于一个相同数在块内，一个相同数在块外的情况，即使不小心误清空也不会出锅。反正这个数也只剩一只了，而题目要求的是相距最远的 两个，本就统计不进答案。 但有时会出现 两个相同数都在块外 的情况，所以我们需要对这种情况进行异化处理。 我们改变 极左位置（ $fir$ ） 的定义是：在 该块右边界之后 的极左位置。这样我们就可以对两个相同数 都在块外 的情况进行 块内清空后 的查询。 然而我们不能大E，这样的话，拿什么去算 两个相同数都在块内 的答案呢？ 我们致远星地发现在同一次查询中，传入 $\\text{add}$ 的 $L$ 永远 递减 ，也就是说，其实我们每次传进去的 $L$ 就已经是这个位置上的数的 极左位置 了。 那么也不需要开新数组，以下是 $\\text{add}$ 的瑇码： 123456789101112131415161718192021222324252627void add(int p, int opt)//opt——若这次移的是L则为1，反之为2&#123; if (opt == 1) &#123; if (rig[num[p]] == 0) //即使我是一个在块内的数 //但当块外没有相同数的时候，我就是极右的位置 &#123; rig[num[p]] = p; &#125; maxx = max(maxx, rig[num[p]] - p);//直接用 p 就好了 &#125; if (opt == 2) &#123; if (fir[num[p]] == 0) //因为 R 永远递增 //所以如果没有块外极左数，那么这个就是了 &#123; fir[num[p]] = p; dq.push_back(p); //dq 存一些需要清空 fir 的位置 //到时候对 dq 里的元素一一清空就是 &#125; rig[num[p]] = p;//同上的理由，直接用 p 就好了 maxx = max(maxx, rig[num[p]] - fir[num[p]]); &#125;&#125; 很好很好，那么该什么时候清空呢？我们奉行一条原则： 『块内信息在 单次询问结束 后清空，块外信息在 块内所有询问结束 后清空』 首先，对于 $fir$ 数组不用急着清空，因为这是右边界往后，块外的事了。 其次，对于不在块内的 $rig[i]$ 不用急着清空，原因同上。 换言之，我们只需在一次询问后清空在 块内 的 $rig$ 们就可以了。 等到这一块的询问们都已经完成，我们就可以清空 $fir$ 和 $rig$ ，具体要清空的位置已经装到 $dq$ 里了。之所以要存起来再清空，是因为 memset/no。 全瑇码装填： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 4e5 + 7;/*莫队组件*/struct query&#123; int l, r; int id;&#125; q[MAX];int block[MAX];bool cmp(query a, query b)&#123; if (block[a.l] != block[b.l]) &#123; return a.l &lt; b.l; &#125; if (a.r != b.r) return a.r &lt; b.r; return a.l &lt; b.l;&#125;int N, Q;int lm[MAX], rm[MAX];int B, M;void pre()&#123; M = sqrt(N); B = N / M; for (int i = 1; i &lt;= N; i++) &#123; block[i] = (i - 1) / M + 1; &#125; for (int i = 1; i &lt;= B; i++) &#123; lm[i] = rm[i - 1] + 1; rm[i] = lm[i] + M - 1; &#125; if (N % M) &#123; B++; lm[B] = rm[B - 1] + 1; rm[B] = N; &#125;&#125;/*离散化*/int tmp[MAX];int num[MAX];void lsh()&#123; memcpy(tmp, num, sizeof(num)); sort(tmp + 1, tmp + 1 + N); for (int i = 1; i &lt;= N; i++) &#123; num[i] = lower_bound(tmp + 1, tmp + 1 + N, num[i]) - tmp; &#125;&#125;/*add*/int fir[MAX], rig[MAX];vector&lt;int&gt; dq;int maxx = 0;void add(int p, int opt)&#123; if (opt == 1) &#123; if (rig[num[p]] == 0) &#123; rig[num[p]] = p; &#125; maxx = max(maxx, rig[num[p]] - p); &#125; if (opt == 2) &#123; if (fir[num[p]] == 0) &#123; fir[num[p]] = p; dq.push_back(p); &#125; rig[num[p]] = p; maxx = max(maxx, rig[num[p]] - fir[num[p]]); &#125;&#125;/*暴力怎么做？！*/int ll[MAX], rr[MAX];int baoli(int l, int r)&#123; int ans = 0; for (int i = l; i &lt;= r; i++) &#123; if (!ll[num[i]]) &#123; ll[num[i]] = i; &#125; rr[num[i]] = i; &#125; for (int i = l; i &lt;= r; i++) &#123; ans = max(ans, rr[num[i]] - ll[num[i]]); &#125; for (int i = l; i &lt;= r; i++) &#123; ll[num[i]] = rr[num[i]] = 0; &#125; return ans;&#125;int ans[MAX];int main()&#123; cin &gt;&gt; N; pre(); for (int i = 1; i &lt;= N; i++) &#123; cin &gt;&gt; num[i]; &#125; lsh(); cin &gt;&gt; Q; for (int i = 1; i &lt;= Q; i++) &#123; cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].id = i; &#125; int L = 1, R = 0; int tot = 1; sort(q + 1, q + 1 + Q, cmp); for (int i = 1; i &lt;= B; i++) &#123; R = rm[i]; maxx = 0; while (block[q[tot].l] == i) &#123; L = rm[i] + 1; if (q[tot].r - q[tot].l &lt;= M) &#123; ans[q[tot].id] = baoli(q[tot].l, q[tot].r); &#125; else &#123; while (R &lt; q[tot].r) &#123; add(++R, 2); &#125; int store = maxx; while (L &gt; q[tot].l) &#123; add(--L, 1); &#125; ans[q[tot].id] = maxx; maxx = store; while (L &lt;= rm[i]) &#123; if (rig[num[L]] == L)//清空块内rig //等价于其极右位置在该块右边界之前 &#123; rig[num[L]] = 0; &#125; L++; &#125; &#125; tot++; &#125; for (int j = 0; j &lt; dq.size(); j++)//清空fir和块外rig &#123; rig[num[dq[j]]] = 0; fir[num[dq[j]]] = 0; &#125; dq.clear(); &#125; for (int i = 1; i &lt;= Q; i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; &#x27;\\n&#x27;; &#125;&#125; 这个板题一点也不板/fn 板子题三：Rmq Problem / mex 让我 DIO 回滚莫队来切这道线段树题。 我们之前说，回滚莫队可以咕掉删除和插入中的任意一种，但是我们还没见到 咕掉插入 的回滚莫队。 那么这道就是了。 我们发现删除操作非常容易，看看新删的数是不是不出现了，如果不出现了是不是可以更新答案了。 但加入操作就面临着和 $\\color{purple}{\\texttt{給朝}}$ 一样的危机——找不到继承人。 那么加入操作不咕也得咕了。 怎么咕？我们把咕删除的回滚莫队换个皮即可。 先把之前的板子 再 放 送 ： 123456789101112131415161718192021222324252627282930313233343536int L = 1, R = 0;int tot = 1;for (int i = 1; i &lt;= B; i++)//B是块数，这里是枚举块&#123; memset(cnt, 0, sizeof(cnt)); maxx = 0;//归零面对新块 R = rm[i];//R指针放在右边界 while (block[q[tot].l] == i)//对于所有左端点在这个块里的 &#123; L = rm[i] + 1;//左端点移到右边界+1，以表空区间 if (q[tot].r - q[tot].l &lt;= M)//暴力 &#123; COUT[q[tot].id] = baoli(q[tot].l, q[tot].r); &#125; else &#123; while (R &lt; q[tot].r) &#123; add(++R); &#125; int store = maxx; while (L &gt; q[tot].l) &#123; add(--L); &#125; COUT[q[tot].id] = maxx; maxx = store; while (L &lt;= rm[i]) &#123; cnt[num[L++]]--; &#125; &#125; tot++; &#125;&#125; 可以看出我们咕删除的回滚莫队是从一个 空区间 一步一步加元素来获取到询问区间的，这个过程中只有加没有删。 那么我们咕加入的回滚莫队就是从一个 满区间 一步一步删元素来获取到询问区间的，这个过程中只有删没有加。 看上去就像这样？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748for (int i = 1; i &lt;= B; i++)&#123; mex = kk;//kk是整个数组的mex，这个可以O(n)预处理 while (R &lt; N) //移动右指针到尽头 &#123; if (num[++R] &lt;= N + 1)//mex答案一定 N+1 以下，这个随便证明 &#123; cnt[num[R]]++; &#125; &#125; while (L &lt; lm[i]) //移动左指针到左边界 &#123; del(L++); &#125; //这样一来我们框出了一个 [lm[i],N] 的区间 //可以保证这一块的所有询问一定在这个区间中发生 kk = mex; while (block[q[tot].l] == i)//大体相同 &#123; if (block[q[tot].r] == i)//和作差等价的写法，换换口味 &#123; COUT[q[tot].id] = baoli(q[tot].l, q[tot].r); &#125; else &#123; while (R &gt; q[tot].r) &#123; del(R--); &#125; int store = mex; while (L &lt; q[tot].l) &#123; del(L++); &#125; COUT[q[tot].id] = mex; mex = store; while (L &gt; lm[i]) &#123; if (num[--L] &lt;= N + 1) &#123; cnt[num[L]]++;//恢复L指针到左边界 &#125; &#125; &#125; tot++; &#125;&#125; 那么这个 $\\text{del}$ 函数里面是肾么呢？ 正如我们之前说的“康康新删的数是不是不出现了，如果不出现了是不是可以更新答案了”。这个很好写，在此不表。 还有一个问题，这个排序还能按源赖这么排吗？ 答案是否定的，因为你的 $R$ 指针将会从右往左递减，所以应在 $L$ 同块时将 $R$ 降序 排列。 那么你就可以把回滚莫队板子改几个bit直接爆切此题了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 2e5 + 7;struct query&#123; int l, r; int id;&#125; q[MAX];int block[MAX];bool cmp(query a, query b)&#123; if (block[a.l] != block[b.l]) &#123; return a.l &lt; b.l; &#125; return a.r &gt; b.r;&#125;int N, Q, M, B;int num[MAX], cnt[MAX];int mex;void del(int p)&#123; if (num[p] &lt;= N + 1) //答案上界为N+1，所以只统计到N+1 &#123; cnt[num[p]]--; if (cnt[num[p]] == 0) //如果有一个数被删没了 &#123; mex = min(mex, num[p]); //看看这个数能不能作新mex &#125; &#125;&#125;int c[MAX];int baoli(int l, int r) //暴力，交了一发没锅&#123; int ans = 0; for (int i = l; i &lt;= r; i++) &#123; if (num[i] &lt;= N + 1) &#123; c[num[i]]++; while (c[ans]) //找到下一个没出现的 &#123; ans++; &#125; &#125; &#125; for (int i = l; i &lt;= r; i++) //恢复现场 &#123; if (num[i] &lt;= N + 1) &#123; c[num[i]]--; &#125; &#125; return ans;&#125;int lm[MAX], rm[MAX];void pre() //预处理每块左右界&#123; B = N / M; //块数 for (int i = 1; i &lt;= B; i++) &#123; lm[i] = rm[i - 1] + 1; rm[i] = lm[i] + M - 1; &#125; if (N % M) //如果不能整除 &#123; B++; //开一边角块 lm[B] = rm[B - 1] + 1; rm[B] = N; &#125;&#125;int tmp[MAX];int COUT[MAX];int main()&#123; cin &gt;&gt; N &gt;&gt; Q; M = sqrt(N); for (int i = 1; i &lt;= N; i++) &#123; cin &gt;&gt; num[i]; block[i] = (i - 1) / M + 1; if (num[i] &lt;= N + 1) &#123; cnt[num[i]]++; //用于求最初mex &#125; &#125; while (cnt[mex]) &#123; mex++; //得到全局mex &#125; for (int i = 1; i &lt;= Q; i++) &#123; cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].id = i; &#125; pre(); sort(q + 1, q + 1 + Q, cmp); int L = 1, R = N; int tot = 1; int kk = mex; for (int i = 1; i &lt;= B; i++) &#123; mex = kk; while (R &lt; N) //移动右指针到尽头 &#123; if (num[++R] &lt;= N + 1) &#123; cnt[num[R]]++; &#125; &#125; while (L &lt; lm[i]) //移动左指针到 &#123; del(L++); &#125; kk = mex; while (block[q[tot].l] == i) &#123; if (block[q[tot].r] == i) &#123; COUT[q[tot].id] = baoli(q[tot].l, q[tot].r); &#125; else &#123; while (R &gt; q[tot].r) &#123; del(R--); &#125; int store = mex; while (L &lt; q[tot].l) &#123; del(L++); &#125; COUT[q[tot].id] = mex; mex = store; while (L &gt; lm[i]) &#123; if (num[--L] &lt;= N + 1) &#123; cnt[num[L]]++; &#125; &#125; &#125; tot++; &#125; &#125; for (int i = 1; i &lt;= Q; i++) &#123; cout &lt;&lt; COUT[i] &lt;&lt; endl; &#125;&#125; Polya 定理你会发现 qst 这个废物甚至连定理的名字都打不出来，好在问题不是很大。 这是神马东东Polya 定理是一种通过计算置换群来数出染色方案的一种神仙玩意，当然这只是数学菜鸡的口胡理解，也就图一乐，真要看严谨说法还得看队爷们的论文。 性感理解置换 我们把 $(^{1\\ 2\\ 3\\ 4\\ 5\\ 6}_{1\\ 3\\ 2\\ 5\\ 6\\ 4})$ 这样的上面是一个排列，下面是一个排列的东东叫做置换。 可以把他看作是一个加密规则，加密的过程相当于把一个上面的数替换成下面的数。 我们总是能从置换里找到一些循环，比如 $(^{1\\ 2\\ 3\\ 4\\ 5\\ 6}_{1\\ 3\\ 2\\ 5\\ 6\\ 4})$ 就由 $(^{1}_{1})(^{2\\ 3}_{3\\ 2})(^{4\\ 5\\ 6}_{5\\ 6\\ 4})$ 三个循环组成。 “组成”这个动词显得非常 naive ，我们一般称：这个置换是这些循环的乘积。 不动点，顾名思义，就是经过置换后不变的元素。 对于置换，我们也定义了两个置换的乘积：$P_1=\\binom{1\\ \\ 2\\ \\ 3\\ \\ 4}{a_1\\ a_2\\ a_3\\ a_4},P_2=\\binom{a_1\\ a_2\\ a_3\\ a_4}{b_1\\ b_2\\ b_3\\ b_4},P_1*P_2=\\binom{1\\ \\ 2\\ \\ 3\\ \\ 4}{b_1\\ b_2\\ b_3\\ b_4}$ 看上去就像原序列先经过 $P_1$ 加密规则加密后的密文，再用 $P_2$ 加密一遍？ 置换群就是一堆置换的集合。 Burnside 引理事实上直接背诵这个引理的内容就完全够用了，如果要去强行理解那些“稳定化子”啥的概念的话可能一不小心就会掉进群论的深渊（（ 有些题目让我们数一些对象的染色方案，这些染色方案会有一个“置换等价”的限制，即： 如果通过某种特定的变换，两组染色方案可以互相转化，则称这两个方案是本质相同的。 Burnside 引理就是用来数这种受“置换等价”限制的玩意的。 你可以在各大网站上看到这个引理名字的无数种翻译，什么“烧边”啊，“伯恩赛德”啊，为了不至于造成差异，这里直接采用英文。 在 Burnside 引理中，我们用 染色方案的置换 来表达变换的动作，那题目给出的这些变换就组成了一个置换群。 设 $G$ 是给出的置换群，$C(f)$ 是置换 $f$ 中不动点的个数，$N(G,C)$ 表示所有本质不同的染色方案种类数。 其内容如下： N(G,C)=\\dfrac{\\sum_{f\\in G}C(f)}{|G|}用人话翻译一遍，就是：染色方案的数量是 所有置换中不动点个数 的平均数。 现在您可能还是一头雾水，不妨下面我们尝试运用这一武器来数一些东西。 试看看： 有一个 $2\\times2$ 的方格，我们可以将每一格染成红色或白色，如果通过旋转一定角度，两组染色方案可以互相转化，则称这两个方案是本质相同的，求本质不同染色方案数。 本质不同波兰国旗计数 我们先把所有染色方案列出来，一共有 $2^4=16$ 种。 题目给出了置换等价的信息是旋转等价，胡乱思尻一下就知道其实只有四种可能的旋转角度（默认顺时针）：0°，90°，180°，270°。 我们把染色方案从1到16标号，用旋转90度作为栗子，我们尝试用置换来表达【旋转90度】这一动作： \\binom{1\\;2\\;3\\;4\\;5\\;6\\;7\\;8\\;9\\;10\\;11\\;12\\;13\\;14\\;15\\;16}{1\\;3\\;5\\;2\\;4\\;7\\;8\\;9\\;6\\;11\\;10\\;13\\;14\\;15\\;12\\;16}X号元素置换到Y号，就代表X号染色方案旋转90°达到Y号方案。（你也大可理解成X号是Y号方案旋转90°得来，只不过要换一种写法，不动点的个数还是一样的qaq） 那么扳手指头就知道这一置换有 2 个不动点。 把所有旋转情况的不动点个数都扳出来后，再套上珂爱的 Burnside 引理求解： N=\\dfrac{16+2+4+2}{4}=6那么本质不同的 波兰国旗 染色方案就有 6 种辣，经过手玩验证 ，这一答案是正确的。 Polya 定理刚才扳手指头的过程让我们感到苦涩（至少我打 Latex 打得很苦涩），如果我们数的不是波兰国旗而是俄罗斯国旗甚至泰国国旗，那我们的手指恐怕有些危机。 而 Polya 定理的出现挽救 OIer 于水深火热之中（（ Polya 定理并不依赖于求出置换群的过程，也就是说，我们不需要求出染色方案的置换群就可以直接数。 其内容大致如下。 我们之前是用【染色方案的置换】来表达一个动作的，但事实上，这样的数据往往是巨大多量的。 这时我们发现，在旋转过程中，染色对象内部的各个元素也存在一个置换关系，比如这样： 旋转 90° 的变换，其实对象内部存在置换 $\\binom{1\\ 2\\ 3\\ 4}{3\\ 1\\ 4\\ 2}$ 。 如果我们不求出各个染色方案之间的置换，而只关注于染色对象内部的元素的置换，就把处理的置换规模从 $M^N$ 级别转化成了 $N$ 。 我们知道一个置换可以拆分成几个循环的乘积，设 $R(f)$ 为置换 $f$ 中的循环个数（这里的置换是 对象内部元素 的置换），$M$ 为颜色数，我们有： N=\\dfrac{\\sum_{f\\in G}M^{R(f)}}{|G|}还是一样的题，我们用 Polya 定理来切这道题： 转 90° 会带来对象内元素什么样的置换？之前已经提到了，是 $\\binom{1\\ 2\\ 3\\ 4}{3\\ 1\\ 4\\ 2}$ ，这个置换中有 1 个循环。 同理，转 180° 的置换是 $\\binom{1\\ 2\\ 3\\ 4}{4\\ 3\\ 2\\ 1}$ ，这个置换中有 2 个循环。 而转 270° 有 1 个循环，转 0° 有 4 个循环。 那么答案就是： N=\\dfrac{2^1+2^2+2^1+2^4}{4}=6这和我们烧边烧出来的结果是一样的。 好耶！ 数波兰国旗非常无聊且枯燥，因为循环节用脚趾头也能数出来，接下来我们尝试数项链。 我们定义一串项链由一圈珠（柱）子串成，它满足旋转同构，即旋转一定角度后相同则本质相同。 咕咕咕！","categories":[],"tags":[{"name":"“知识”决定命运","slug":"“知识”决定命运","permalink":"https://quest233.github.io/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/"}]},{"title":"紫题算法学习实况","slug":"紫题算法学习实况","date":"2021-04-17T07:10:13.000Z","updated":"2021-08-03T02:16:32.464Z","comments":true,"path":"2021/04/17/紫题算法学习实况/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5/","excerpt":"","text":"因为进不去复赛就只能休养休养生息，整点算法学学。和同机房的神仙相比，窝挖的坑实在是太多了 $OvO$ 。 2020-10-21：竟然与he老爷讲课撞车了，两相对比显然突出窝的菜2020-11-16：CSP-S又垫底了，可以安心写博客力2020-12-26：该文章已停更，光标几乎卡的动不了了 《实况一》（本文）中包含的内容： 点分治 点分树 fhq 网络流 杜教筛 点分治“每天就是切一些 N 倍经验题，维持维持生活这样子。” 处理什么问题：大部分是树上点对距离问题，当然还有一些变形。（树论毒瘤爪巴） 如果给您一棵树，让您查询树上是否存在两点距离为 $K$ 。您没学过点分治，您怎么做？ 您说，您会暴力 $O(n^2)$ 枚举点对查询其距离！ 抱歉，点分治是可以 $O(n\\log n)$ 的。 思想是什么：现在讲一下思想。 树上两点之间，路径唯一 ，两点通向LCA的路径的并，即为两点之间的路径。 这种路径要分类无非两种：过 全树的根 结点的，和 不过根 结点的。 或者换种说法，LCA是全树的根结点的，或者不是根结点的。 （超喜欢这个字体 $AwA$ ） 分类讨论绝对是树学界存在的最恶心的玩意。不会真的有人在代码里分类讨论吧，不会吧不会吧。 我想把这两种情况 归为一类 。 大眼观察法看出 $Type\\ 2$ 在以粉色点为根的时候就可以归纳为一种 $Type\\ 1$ 。 $Type\\ 1$ 多好求，两点到 $LCA$ 距离一加就是了。 显然，我们要从根结点一层一层地递归下去求解。 获得了 $O(level\\cdot n)$ （ $level$ 是树的深度）的优秀复杂度！ 然后当场就被链卡回了 $O(n^2)$ 。 我们发现，它被卡了，究其原因就是因为树的形态太 $hentai$ 。 一棵树，存不存在距离为 $K$ 的点对，和让谁来当根有关系吗？ 没有关系。 那我们就该选一个好亿点的点来当根哇。 这个“好亿点”，具体指的就是，以它来当根，能使 树的深度最小 。 这里有一个概念叫树的重心：我们知道在一棵树上，删去一个点后，剩下的部分必然不联通。 如果一个点删去它后，剩余的几部分中 大的那一块最小 ，则我们说这个点是这个树的重心。 不难感觉到，如果以一棵树的重心为根，它的佐佑两边会最为“平衡”。 在最美好的愿景下，每层以重心作根可以做到把树二等分。 那二等分又二等分，最终能控制在 $\\log n$ 的递归层数。 获得了 $O(n \\log n)$ 的优秀复杂度！（大喜） 撒花撒花～ 劲爆习题：模板题：P3806 【模板】点分治1 ：（想不到叭，模板就是紫的 $QwQ$ ） 给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。 裸题，8说了，该说的都在注释里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1e5 + 7;const int INF = 1e9 + 7;/*前向星存图组件*/struct edge&#123; int to, next; int val;&#125; e[MAX &lt;&lt; 1];int N, M, SUM;int head[MAX], eid = 0;void adde(int x, int y, int w)&#123; e[++eid].to = y; e[eid].next = head[x]; e[eid].val = w; head[x] = eid;&#125;/*求重心组件*/int cent;//指重心的编号int size[MAX], son[MAX];//size:其子树（包括自己）的大小 son:最大儿子的大小int vis[MAX];void getroot(int u, int lst)&#123; size[u] = 1; son[u] = 0;//初始化 for (int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; if (v == lst || vis[v]) &#123; continue; &#125; getroot(v, u); size[u] += size[v]; son[u] = max(son[u], size[v]);//更新最终儿子 &#125; son[u] = max(son[u], SUM - son[u]);//可能子树外的部分更大 //SUM实时更新成当前要求重心的树的大小 if (son[u] &lt; son[cent]) &#123; cent = u;//更新 &#125;&#125;/*点分治组件*/int dis[MAX], apr[MAX], cntapr;//dis:到“当前处理到的子树”的根结点的距离//apr:一个子树级别的桶，存所有出现过的距离//cntapr:桶大小void getdis(int u, int lst)&#123; apr[++cntapr] = dis[u];//装桶 for (int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to, w = e[i].val; if (v == lst || vis[v]) &#123; continue; &#125; dis[v] = dis[u] + w;//更新距离 getdis(v, u); &#125;&#125;int query[MAX], ans[10000007], judge[10000007];//query:询问，这里采用离线回答做法//ans:对于每一个询问的答案（0/1 表示有或没有）//judge:一个整树级别的大桶queue&lt;int&gt; clear;void calc(int u)&#123; for (int i = head[u]; i; i = e[i].next)//这里是遍历每一棵子树 &#123; int v = e[i].to; if (vis[v]) &#123; continue; &#125; int w = e[i].val; dis[v] = w; cntapr = 0;//清桶 getdis(v, u);//这里是往下搜（遍历到的这棵子树） for (int j = 1; j &lt;= cntapr; j++) &#123; for (int k = 1; k &lt;= M; k++) &#123; if (query[k] - apr[j] &gt;= 0 &amp;&amp; judge[query[k] - apr[j]])//若和他拼起来能达到K的距离出现过 &#123; ans[k] = 1;//则这是可拼出K的答案 &#125; &#125; &#125; for (int i = 1; i &lt;= cntapr; i++) &#123; clear.push(apr[i]); judge[apr[i]] = 1;//装大桶 &#125; &#125; while (!clear.empty()) &#123; judge[clear.front()] = 0; clear.pop(); &#125;&#125;void solve(int u)&#123; judge[0] = 1; vis[u] = 1; calc(u); for (int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; if (vis[v]) &#123; continue; &#125; SUM = size[v]; son[0] = INF; cent = 0; getroot(v, 0);//获取新重心 solve(cent);//以重心为根递归 &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M; for (int i = 1.; i &lt; N; i++) &#123; int fr, to, val; cin &gt;&gt; fr &gt;&gt; to &gt;&gt; val; adde(fr, to, val); adde(to, fr, val); &#125; for (int i = 1; i &lt;= M; i++) &#123; cin &gt;&gt; query[i]; &#125; son[0] = SUM = N; getroot(1, 0); solve(cent); for (int i = 1; i &lt;= M; i++) &#123; if (ans[i]) &#123; cout &lt;&lt; &quot;AYE\\n&quot;; &#125; else &#123; cout &lt;&lt; &quot;NAY\\n&quot;; &#125; &#125;&#125; 次模板题：P4178 Tree 由上题的询问存在与否变成了询问 点对数 ，要求变成了 小于等于 。 点分治的板子该打还是打，但要改一下 $\\operatorname{calc}$ 函数。 上一题的策略是：存桶，查能和它拼成 $K$ 的距离是否存在。 但我们这么整是因为题目要求的是等于 $K$ ，所以能拼的距离是唯一确定哒。 可这题是不确定的，所以得换一种思路。 我们尝试把所有出现过的距离排个序，有两个指针 $L$ 和 $R$ 从数组两边往中间逐步压缩。 $L$ 指向的距离和 $R$ 指向的距离，会拼出一种可能的距离。 可以证明这样能不重不漏地拼出树上存在的每一种 两点距离 。 甚至可以在线/fad/fad 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;#define debug coutconst int MAX = 1e5 + 7;struct edge&#123; int to, next; int val;&#125; e[MAX];int head[MAX], eid = 0;void adde(int x, int y, int w)&#123; e[++eid].to = y; e[eid].next = head[x]; e[eid].val = w; head[x] = eid;&#125;int size[MAX], son[MAX], cent, vis[MAX];int N, M, SUM, K;void getroot(int u, int lst)&#123; size[u] = 1; son[u] = 0; for (int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; if (v == lst || vis[v]) &#123; continue; &#125; getroot(v, u); size[u] += size[v]; son[u] = max(son[u], size[v]); &#125; son[u] = max(son[u], SUM - son[u]); if (son[u] &lt; son[cent]) &#123; cent = u; &#125;&#125;int dis[MAX], apr[MAX], cntapr = 0;void getdis(int u, int lst)&#123; apr[++cntapr] = dis[u]; for (int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; if (v == lst || vis[v]) &#123; continue; &#125; dis[v] = dis[u] + e[i].val; getdis(v, u); &#125;&#125;int ans, query[MAX];int calc(int u, int w)&#123; dis[u] = w; cntapr = 0; getdis(u, 0); sort(apr + 1, apr + 1 + cntapr); int answer = 0; for (int l = 1, r = cntapr; l &lt; r;) &#123; if (apr[l] + apr[r] &lt;= K) //若这两种距离拼出的长度小于等于K &#123; answer += r - l; //那么r取他们之间的其他数也会小于等于K //因为排过序了，r往左移只会更小 l++; &#125; else r--;//否则就取更小的r &#125; return answer;&#125;void solve(int u)&#123; ans += calc(u, 0); vis[u] = 1; for (int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to, w = e[i].val; if (vis[v]) &#123; continue; &#125; ans -= calc(v, w); SUM = size[v]; cent = 0; getroot(v, u); solve(cent); &#125;&#125;int main()&#123; cin &gt;&gt; N; for (int i = 1; i &lt;= N - 1; i++) &#123; int fr, to, val; cin &gt;&gt; fr &gt;&gt; to &gt;&gt; val; adde(fr, to, val); adde(to, fr, val); &#125; cin &gt;&gt; K; cent = 0; SUM = son[0] = N; getroot(1, 0); solve(cent); cout &lt;&lt; ans &lt;&lt; endl;&#125; 次次模板题：[国家集训队]聪聪可可 这回求的是距离是 $3$ 的倍数的点对数。照样改 $\\operatorname{calc}$ 。 带了亿亿亿亿亿点思维，但是易见平凡（雾。 装桶的思路还是不变，但是开这么多桶贞德合理吗？ 两个数 $A,B$ 的 和 $\\bmod 3$ 余 $0$ 。则跑不出三种情况： $A \\bmod 3=0 , B \\bmod 3=0 $ $A \\bmod 3=1 , B \\bmod 3=2$ $A \\bmod 3=2 , B \\bmod 3=1$ 开三个桶来计数，$tong_0,tong_1,tong_2$分别存 $\\pmod 3=0,\\pmod 3=1,\\pmod 3=2$ 。 那么来个小加法原理就有了： ans=tong_1\\cdot tong_2\\ +\\ tong_2\\cdot tong_1\\ +\\ tong_0\\cdot tong_0小心输出格式，甚至要约分。（淦 您吊打国集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 2e4 + 7;struct edge&#123; int to, next; int val;&#125; e[MAX &lt;&lt; 1];int head[MAX], eid = 0;void adde(int x, int y, int w)&#123; e[++eid].to = y; e[eid].next = head[x]; e[eid].val = w; head[x] = eid;&#125;int N;int size[MAX], son[MAX], SUM;int vis[MAX];int cent;void getroot(int u, int lst)&#123; size[u] = 1; son[u] = 0; for (int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; if (v == lst || vis[v]) &#123; continue; &#125; getroot(v, u); size[u] += size[v]; son[u] = max(son[u], size[v]); &#125; son[u] = max(son[u], SUM - son[u]); if (son[u] &lt; son[cent]) &#123; cent = u; &#125;&#125;int ans;int tong[3], dis[MAX];void getdis(int u, int lst)&#123; tong[dis[u] % 3]++;//相应的桶++ for (int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; if (v == lst || vis[v]) &#123; continue; &#125; dis[v] = dis[u] + e[i].val; getdis(v, u); &#125;&#125;int calc(int u, int w)&#123; dis[u] = w; tong[0] = tong[1] = tong[2] = 0;//先清空 getdis(u, 0); return tong[1] * tong[2] * 2 + tong[0] * tong[0]; //如上公式算得答案&#125;void solve(int u)&#123; ans += calc(u, 0); vis[u] = 1; for (int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to, w = e[i].val; if (vis[v]) &#123; continue; &#125; ans -= calc(v, w); SUM = size[v]; cent = 0; getroot(v, u); solve(cent); &#125;&#125;void output()&#123; int G = __gcd(ans, N * N); cout &lt;&lt; ans / G &lt;&lt; &quot;/&quot; &lt;&lt; N * N / G &lt;&lt; endl;&#125;int main()&#123; cin &gt;&gt; N; for (int i = 1; i &lt;= N - 1; i++) &#123; int fr, to, val; cin &gt;&gt; fr &gt;&gt; to &gt;&gt; val; adde(fr, to, val); adde(to, fr, val); &#125; SUM = N; son[0] = SUM; getroot(1, 0); solve(cent); output();&#125; 次次次模板题：[IOI2011]Race 刚爆踩完集训队，马上就IOI了（笑） 这题和纯模板题又有差别，在距离符合的情况下要求路径上边数最少。还是改 $\\operatorname{calc}$ 。 像这种多条件下求人上人的题目，多半是平衡树或堆。 因为要求的并非 全部路径 最优的一个，而是有条件限制（距离定为 $K$ ）。 所以只能打平衡树了…… 吗？ 人生苦短，我用 $set+lower_bound$ 。遍历所有出现过的距离，查找的是能和它拼成 $K$ 的长度中边数最少的。 因为题目大毒瘤，所以加了亿点卡常。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;bits/stdc++.h&gt;using namespace std;#define PII pair&lt;int, int&gt;#define MP make_pair#define SIT set&lt;PII&gt;::iteratorconst int MAX = 2e5 + 7;inline int Min(int x, int y)&#123; return x &lt; y ? x : y;&#125;inline int Max(int x, int y)&#123; return x &gt; y ? x : y;&#125;int read()&#123; int num = 0, bj = 0; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == &#x27;-&#x27;) &#123; bj = 1; &#125; ch = getchar(); &#125; while (isdigit(ch)) &#123; num = num * 10 + ch - &#x27;0&#x27;; ch = getchar(); &#125; return bj ? -num : num;&#125;struct edge&#123; int to, next; int val;&#125; e[MAX &lt;&lt; 1];int head[MAX], eid = 0;inline void adde(int x, int y, int w)&#123; e[++eid].to = y; e[eid].next = head[x]; e[eid].val = w; head[x] = eid;&#125;int N, K, SUM;int size[MAX], son[MAX];int vis[MAX];int cent;inline void getroot(int u, int lst)&#123; size[u] = 1; son[u] = 0; for (register int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; if (v == lst || vis[v]) &#123; continue; &#125; getroot(v, u); size[u] += size[v]; son[u] = Max(son[u], size[v]); &#125; son[u] = Max(son[u], SUM - son[u]); if (son[u] &lt; son[cent]) &#123; cent = u; &#125;&#125;set&lt;PII&gt; s;int ans = 1e9 + 7;PII apr[MAX];int cntapr = 0;int dis[MAX];inline void getdis(int u, int lst, int path)&#123; if (path &gt; ans || dis[u] &gt; K) //到题解区学的剪枝，其实不难理解 &#123; return; &#125; apr[++cntapr] = MP(dis[u], path); //装桶，第一维是长度，第二维是路径上的边数。 for (register int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; if (v == lst || vis[v]) &#123; continue; &#125; dis[v] = dis[u] + e[i].val; getdis(v, u, path + 1); &#125;&#125;inline void calc(int u)&#123; s.clear(); s.insert(MP(0, 0)); for (register int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to, w = e[i].val; if (vis[v]) &#123; continue; &#125; cntapr = 0;//清空 dis[v] = w; getdis(v, u, 1); //现在 apr 数组里装得是v这棵子树上，各种新产生的路径 for (int j = 1; j &lt;= cntapr; j++) &#123; int d = apr[j].first, p = apr[j].second; //取出距离和边数 SIT pos = s.lower_bound(MP(K - d, 0)); //查能拼的长度 if (pos != s.end() &amp;&amp; pos-&gt;first + d == K) &#123; ans = Min(ans, pos-&gt;second + p);//反复取min &#125; &#125; //装进set for (int j = 1; j &lt;= cntapr; j++) &#123; s.insert(apr[j]); &#125; &#125;&#125;inline void solve(int u)&#123; cent = 0; getroot(u, u); vis[cent] = 1; calc(cent); for (register int i = head[cent]; i; i = e[i].next) &#123; int v = e[i].to; if (vis[v]) &#123; continue; &#125; SUM = size[v]; solve(v); &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; K; for (register int i = 1; i &lt;= N - 1; i++) &#123; int fr, to, val; fr = read(), to = read(), val = read(); fr++; to++;//因为这题的申必编号从0开始，所以全体编号加1处理 adde(fr, to, val); adde(to, fr, val); &#125; cent = 0; SUM = son[0] = N; solve(1); if (ans == 1e9 + 7) &#123; cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;; &#125; else &#123; cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;; &#125;&#125; 点分树（动态点分治）“我真傻，真的，我以为三倍经验黑题躺在任务列表里就迟早会被切掉，谁知道等我切掉的时候已经掉紫了。” 处理什么问题：带修树上点对距离查询。这里的“修”不会改变树的形态。 您会说：“我 $O(1)$ 修改，每次查询都 $O(n \\log n)$ 跑一遍点分治不香吗？” 这是一种 $O(q\\cdot n\\log n)$ 的优秀算(bao)法(li)。 抱歉，点分树可以达到 $O(q\\log n)$ 的效率。如果算上它上边套的别的数据结构（比如平衡树哇，堆哇），也一般能有 $O(q\\log^2 n)$ 的高性能。 思想是什么：想想您的暴力为什么会有这么大的复杂度。 找重心，回答询问，修改，又找重心，又回答询问，又修改…… 看得出，您的做法有不少重复的操作。 尝试优(tou)化(gong)算(jian)法(liao)。 询问和修改我们都不敢偷懒，只能从找重心开刀。 我们发现，因为树的形态始终不变，找到的重心永远都是那几个。 又想到，我们每一次统计答案（ $\\operatorname{calc}$ ），总是在递归重心时的 $\\operatorname{solve}$ 函数里。这是否表明一个重心点，它还能表示一些其他的有关答案的信息呢？ 必然是可以的，我们甚至还能用取重心的搜索序建出一棵树来。这棵树就称作点分树。 接下来，我们声称：两个点在原树上的距离为他们的 真实距离 。（区别于点分树上的距离） 我这是一棵树（确信），树上有 $6$ 个顶点。 我取重心 $4$ 作为根，我开一个 $tong_4$ 装以 $4$ 为根的子树中出现的 点到根的真实距离 情况。 （右边是当前 点分树 的形态） 我取重心 $2$ 为根，距离情况再装桶。 如此往复。最终得到了图上的所有信息。 这些信息是可以在 $O(n\\log n)$ 时间内得到的。下面考虑修改： 如果我们要修改原树上 $1\\ 2$ 之间的边权，从 $val=1$ 改为 $val=2$ 。哪些桶里装的值会受影响？ 大眼观察法， $tong_2$ 和 $tong_4$ 会受影响。 可见会受到修改的影响的，是这条边 在点分树上 的祖先们。 我们往下递归找重心时，记录一下每个重心是 从谁递归过来 的，记之为 $fa$ 。（一般点分树的题不用建出真正的点分树形态，比如像这里只要记录其 点分树上 的父亲 $fa$ 即可）。 向上跳 $fa$ ，每跳到一个点，修改相应的数据结构。 （像这里就是修改桶里的值～） 我们珂以保证：这样跳 $fa$ 可以只跳 $\\log n$ 次。 原因？ 点分治拥有的 $\\log n$ 的优秀递归层数，使得点分树的层数也能控制在 $\\log n$ 。 而查询更是轻松，只需直接调用数据结构里的信息就可了。 妙到家。 劲爆习题：模板题： QTREE5 - Query on a tree V 其实不是很板。/kk 修改：翻转颜色，查询：给定 $u$ ，求树上距 $u$ 最近白点。 一上来就整点“好康的”。可以充分感受点分树的恶意。(bushi 查询的是最值，那就不是开桶那么简单了。 我们要开堆。 每个点必然要开一个堆，装的是它的 点分树子树 里的点，到它的 真实距离 。（因为是最 小 值，所以开小根堆） 因为有时会有白点变成黑的，无法计入答案，所以要写一个 可删堆 $AwA$ 。 这其实算得上一种小 $trick$ ，下面有放代码的。 那么修改操作即为： 一个点 $P$ 变白了 $\\rightarrow$ 跳到其 点分树上 的父亲 $FA$ $\\rightarrow$ 往 $FA$ 的堆里塞一个表示 $P$ 到 $FA\\ $ 真实距离 的元素 $\\rightarrow$ 跳到更高一级的 $FA$ $\\rightarrow$ 塞元素 $\\rightarrow\\; \\cdots$ 一个点 $P$ 变黑了 $\\rightarrow$ 跳到其 点分树上 的父亲 $FA$ $\\rightarrow$ 在 $FA$ 的堆里删去表示 $P$ 到 $FA\\ $ 真实距离 的元素 $\\rightarrow$ 跳到更高一级的 $FA$ $\\rightarrow$ 删元素 $\\rightarrow\\; \\cdots$ 都维护了这么多东西了，那么查询操作就有 手 就 行。我们要查询一个点 $P$ 的最近白点。 扫一遍它在 点分树 上的所有祖先。为什么是点分树？因为一个点的距离信息都保存在了它点分树上祖先的堆里，所以是在点分树上跳祖先。 取出祖先 $FA$ 位置上堆的堆顶，这个堆顶就是所有过 $FA$ 的 真实路径 中最短的一条。 这个堆顶和 $P$ 到 $FA$ 的 真实距离 可以拼起来，形成一个如树上路径 $Case\\ 1$ 的两点点距。 不断上跳 $FA$ ，对点距多次取 $min$ 。最终就能得到答案辣！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;bits/stdc++.h&gt;using namespace std;#define RUN(u) for (int i = head[(u)]; i; i = e[i].next)#define GI greater&lt;int&gt;const int MAX = 1e5 + 7;const int INF = 1e9 + 7;/*存图组件*/struct edge&#123; int next; int to;&#125; e[MAX &lt;&lt; 1];int head[MAX], eid = 0;void adde(int x, int y)&#123; e[++eid].to = y; e[eid].next = head[x]; head[x] = eid;&#125;/*点分治组件*/int size[MAX], son[MAX], vis[MAX];int cent, N, Q, SUM;void get_root(int u, int lst)&#123; size[u] = 1; son[u] = 0; RUN(u) &#123; int v = e[i].to; if (v == lst || vis[v]) &#123; continue; &#125; get_root(v, u); size[u] += size[v]; son[u] = max(son[u], size[v]); &#125; son[u] = max(son[u], SUM - son[u]); if (son[u] &lt; son[cent]) &#123; cent = u; &#125;&#125;int dis[27][MAX], dep[MAX];//dis：表示某点到其fa的真实距离//第二维是指该点的编号 第一维是指“这是它的第几级祖先” //dep：表示该点在点分树上的深度，这决定了它上面有几级祖先。int fa[MAX];void getdis(int u, int lst, int stp)&#123; dis[stp][u] = dis[stp][lst] + 1; RUN(u) &#123; int v = e[i].to; if (vis[v] || v == lst) &#123; continue; &#125; getdis(v, u, stp); &#125;&#125;/*点分树组件*/void solve(int u, int stp)//stp：遍历到的点分树深度&#123; /*点分治板子*/ dep[u] = stp; vis[u] = 1; RUN(u) &#123; int v = e[i].to; if (vis[v]) &#123; continue; &#125; dis[stp][u] = 0; getdis(v, u, stp); &#125; RUN(u) &#123; int v = e[i].to; if (vis[v]) &#123; continue; &#125; cent = 0; son[0] = INF; SUM = size[v]; get_root(v, u); get_root(cent, u); fa[cent] = u;//一个点在点分树上的父亲即是它“从谁递归过来” solve(cent, stp + 1); &#125;&#125;priority_queue&lt;int, vector&lt;int&gt;, GI&gt; rema[MAX], dele[MAX];//可删堆，现在还看不出什么高妙，详情见 query//我们称rema为剩余堆，dele为删除堆int color[MAX];//颜色void update(int x)&#123; int u = x; for (int i = dep[x]; i; i--) &#123; if (color[x] == 0) &#123; rema[u].push(dis[i][x]); //若原为黑，则现在变为白，加点 &#125; else &#123; dele[u].push(dis[i][x]); //若原为白，则现在变为黑，删点 &#125; u = fa[u];//跳fa &#125; color[x] = 1 - color[x];&#125;int query(int x)&#123; int u = x, ans = INF; for (int i = dep[x]; i; i--) &#123; while (!rema[u].empty()) &#123; if (!dele[u].empty() &amp;&amp; dele[u].top() == rema[u].top()) //若一个元素同时出现在剩余堆和删除堆，则这是一个被删除过的元素。 &#123; dele[u].pop(); rema[u].pop(); //阴阳人滚出优先队列 &#125; else &#123; ans = min(ans, dis[i][x] + rema[u].top()); //反复取min break; &#125; &#125; u = fa[u]; &#125; if (ans == INF) &#123; return -1; &#125; return ans;&#125;int main()&#123; cin &gt;&gt; N; for (int i = 1; i &lt;= N - 1; i++) &#123; int fr, to; cin &gt;&gt; fr &gt;&gt; to; adde(fr, to); adde(to, fr); &#125; solve(1, 1); cin &gt;&gt; Q; for (int i = 1; i &lt;= Q; i++) &#123; int opt; cin &gt;&gt; opt; if (opt == 0) &#123; int num; cin &gt;&gt; num; update(num); &#125; else &#123; int num; cin &gt;&gt; num; cout &lt;&lt; query(num) &lt;&lt; endl; &#125; &#125;&#125; 冲高端题：[ZJOI2007]捉迷藏 是ZJOI远古题！ 显然那时候浙江省选的毒瘤综合征就已经在潜伏期了。 相比上题，没有了确定的 $u$ ，而是要在全树上查最大值。 上题要考虑的范围那么小，还仅仅卡着复杂度过题，这次有那么多条边要枚举。带毒瘤，爬了爬了。 想想有没有什么“高妙”做法。 全树最大值，所以我们需要开一个全局的大根堆，维护 点分树 上的最大 点对真实距离 。记此堆为 $\\mathtt{ALL}$ 。 上道题 “每个点开一个堆，装它的 点分树子树 里的点，到它的 真实距离 ” 的思路依然保留。记这些堆为 $\\mathtt{subtofa[1…n]}$ 但仅有一个 $\\mathtt{subtofa}$ 堆无法直接维护 $\\mathtt{ALL}$ 。我们可以再整一个堆用于过渡。 先更改 $\\mathtt{subtofa[1…n]}$ 的定义为：“每个点（称它为 $u$ ）开一个堆，装 $u$ 的 点分树子树 里的点，到 $u$ 的父亲的真实距离 ”（差别在于真实距离是到它父亲的）。 再开一个堆表示 “对于一个点 $u$ 在 点分树 中的每个儿子 $v$ ，都把 $\\mathtt{subtofa[v]}$ 中最大的一个装进这个堆里”。记这种堆为 $\\mathtt{fainsub[1…n]}$ 。 代码中的这句话可以彰显出其关系： 12fainsub[u].push(subtofa[cent].top()); //存进subtofa的最大值 而关于 $\\mathtt{fainsub}$ 和 $\\mathtt{ALL}$ ，可以看出 $\\mathtt{ALL}$ 里装的东西始终为： 每个 $\\mathtt{fainsub}$ 中，堆顶的 两个长度的和 （参考以 $Case\\ 1$ 的形式拼接两个长度，以形成一条路径） 。 更新 $\\mathtt{ALL}$ 堆的代码实现～ 12345678void ins_ALL(int u)&#123; if (fainsub[u].size() &gt;= 2) &#123; ALL.push(fainsub[u].top() + fainsub[u].second()); //ALL是自定义的“可删堆”类型，second取出的是其第二大的元素 &#125;&#125; 如果您对定义感到疑惑，这里给出一种感性理解（毕竟我也给这道题题解的各种定义看自闭过）：$\\texttt{subtofa}$ 维护的是纵向的距离最大值， $\\mathtt{fainsub}$ 维护的是横向的距离最大值。 给出一张图助于理解： 如果点 $u$ 关灯，则将像上题一样，不断跳 $fa$ ，将 $\\mathtt{subtofa[u].top()}$ 加入这个 $fa$ 的 $\\mathtt{fainsub[fa]}$ ，再将新的 $\\mathtt{fainsub[fa]}$ 装进 $\\mathtt{ALL}$ 。 若开灯，则将以上操作改为删除元素。 自认为说的很详尽了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309#include &lt;bits/stdc++.h&gt;using namespace std;#define RUN(u) for (int i = head[(u)]; i; i = e[i].next)#define GI greater&lt;int&gt;const int MAX = 1e5 + 7;const int INF = 1e9 + 7;/*存边组件*/struct edge&#123; int next; int to;&#125; e[MAX &lt;&lt; 1];int head[MAX], eid = 0;int N, Q;void adde(int x, int y)&#123; e[++eid].to = y; e[eid].next = head[x]; head[x] = eid;&#125;/*封装可删堆*/struct removable_priority_queue&#123; priority_queue&lt;int&gt; rema, dele; void remove(int x) &#123; dele.push(x); &#125; void push(int x) &#123; rema.push(x); &#125; int top() &#123; while (!rema.empty() &amp;&amp; !dele.empty() &amp;&amp; dele.top() == rema.top()) &#123; dele.pop(); rema.pop(); &#125; return rema.top(); &#125; int second() &#123; int maxx = top(); rema.pop(); int ans = top(); rema.push(maxx); return ans; &#125; int size() &#123; return rema.size() - dele.size(); &#125;&#125; subtofa[MAX], fainsub[MAX], ALL;/*用 fainsub 更新全局 ALL*/void del_ALL(int u)&#123; if (fainsub[u].size() &gt;= 2) &#123; ALL.remove(fainsub[u].top() + fainsub[u].second()); &#125;&#125;void ins_ALL(int u)&#123; if (fainsub[u].size() &gt;= 2) &#123; ALL.push(fainsub[u].top() + fainsub[u].second()); &#125;&#125;/*点分治组件*/int size[MAX], son[MAX];int cent, SUM;int vis[MAX];void getroot(int u, int lst)&#123; size[u] = 1; son[u] = 0; RUN(u) &#123; int v = e[i].to; if (v == lst || vis[v]) &#123; continue; &#125; getroot(v, u); size[u] += size[v]; son[u] = max(son[u], size[v]); &#125; son[u] = max(son[u], SUM - son[u]); if (son[u] &lt; son[cent]) &#123; cent = u; &#125;&#125;int dis[27][MAX];int color[MAX];void getdis(int u, int lst, int stp, int root)&#123; subtofa[root].push(stp); RUN(u) &#123; int v = e[i].to; if (vis[v] || v == lst) &#123; continue; &#125; getdis(v, u, stp + 1, root); &#125;&#125;int fa[MAX];void solve(int u)&#123; vis[u] = 1; RUN(u) &#123; int v = e[i].to; if (vis[v]) &#123; continue; &#125; cent = 0; son[0] = INF; SUM = size[v]; getroot(v, u); fa[cent] = u;//记录fa getdis(v, u, 1, cent); fainsub[u].push(subtofa[cent].top()); //存进subtofa的最大值 solve(cent); &#125; fainsub[u].push(0);//可以自己到自己 ins_ALL(u);&#125;/*LCA组件（蒟蒻太蔡了打了个倍增）*/int dep[MAX], lg[MAX];int father[MAX][27];void LCA_prework(int u, int lst)&#123; dep[u] = dep[lst] + 1; father[u][0] = lst; for (int i = 1; i &lt;= 17; i++) &#123; father[u][i] = father[father[u][i - 1]][i - 1]; &#125; for (int i = head[u]; i; i = e[i].next) &#123; if (e[i].to == lst) &#123; continue; &#125; LCA_prework(e[i].to, u); &#125;&#125;int LCA(int x, int y)&#123; if (dep[x] &lt; dep[y]) &#123; swap(x, y); &#125; while (dep[x] &gt; dep[y]) &#123; x = father[x][lg[dep[x] - dep[y]] - 1]; &#125; if (x == y) &#123; return x; &#125; for (int i = lg[dep[x]] - 1; i &gt;= 0; i--) &#123; if (father[x][i] != father[y][i]) &#123; x = father[x][i]; y = father[y][i]; &#125; &#125; return father[x][0];&#125;int dis_on_real(int x, int y)&#123; return dep[x] + dep[y] - dep[LCA(x, y)] * 2;&#125;/*开灯*/void turn_on(int u)&#123; del_ALL(u); fainsub[u].remove(0);//首先不能自己到自己了 ins_ALL(u); for (int now = u; fa[now]; now = fa[now])//跳fa &#123; int D = dis_on_real(u, fa[now]); del_ALL(fa[now]);//先取出第一层 if (subtofa[now].size()) &#123; fainsub[fa[now]].remove(subtofa[now].top()); //取出第二层 &#125; subtofa[now].remove(D);//铲除祸根 if (subtofa[now].size()) &#123; fainsub[fa[now]].push(subtofa[now].top());//放回 &#125; ins_ALL(fa[now]);//放回 &#125;&#125;/*关灯*/void turn_off(int u)//见上&#123; del_ALL(u); fainsub[u].push(0); ins_ALL(u); for (int now = u; fa[now]; now = fa[now]) &#123; int D = dis_on_real(u, fa[now]); del_ALL(fa[now]); if (subtofa[now].size()) &#123; fainsub[fa[now]].remove(subtofa[now].top()); &#125; subtofa[now].push(D); if (subtofa[now].size()) &#123; fainsub[fa[now]].push(subtofa[now].top()); &#125; ins_ALL(fa[now]); &#125;&#125;/*多此一举的修改函数*/void update(int u)&#123; if (color[u] == 0) &#123; turn_on(u); &#125; else &#123; turn_off(u); &#125;&#125;int black;int main()&#123; ios::sync_with_stdio(0); cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) &#123; lg[i] = lg[i - 1] + (i == (1 &lt;&lt; lg[i - 1])); &#125; for (int i = 1; i &lt;= N - 1; i++) &#123; int fr, to; cin &gt;&gt; fr &gt;&gt; to; adde(fr, to); adde(to, fr); &#125; LCA_prework(1, 0); SUM = N; cent = 0; son[0] = INF; getroot(1, 0); solve(cent); black = N; cin &gt;&gt; Q; for (int i = 1; i &lt;= Q; i++) &#123; char opt; cin &gt;&gt; opt; if (opt == &#x27;G&#x27;) &#123; if (black == 0) &#123; cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;; continue; &#125; if (black == 1) &#123; cout &lt;&lt; 0 &lt;&lt; &quot;\\n&quot;; continue; &#125; cout &lt;&lt; ALL.top() &lt;&lt; &quot;\\n&quot;; &#125; else &#123; int w; cin &gt;&gt; w; if (color[w] == 1) &#123; black++; &#125; else &#123; black--; &#125; update(w); color[w] = 1 - color[w]; &#125; &#125;&#125; 有三倍经验 $AwA$ ：Qtree4 （这题要小心带边权） QTREE4 - Query on a tree IV （我至今没卡完的常） 阴间题：[WC2014]紫荆花之恋 我 不 会（逃 以后来填坑。 无旋 $treap$“这个splay就是逊啦！” 早就学过 $splay$ ，但每次敲完都会出锅，总是要对着板子全文比较。 导致给了窝一个刻板印象：平衡树=不行。 平衡树什么时候时候才能站起来？气抖冷。 直到窝开始盘算着学无旋 $treap$ 。 这是什么：一种基于分裂合并操作的 $treap$ ，可以跑持久化，但不能很轻松地维护 $LCT$ 。 最重要的是，它很短。而且板子极为好背，针不戳。 思想是什么： 前置知识：知道普通 $treap$ 的形态与性质。考虑一棵 $treap$ ，他在 $val$ 的维度上维持二叉搜索树的性质，在 $prio$ 维度上维持堆的性质。如下图： 即： 其中序遍历为原序列的 按 $val$ 的有序排列（二叉搜索树的性质） 对于任何一棵子树，都满足 根的 $prio$ 值大于儿子的 $prio$ （堆的性质） 无旋 $treap$ 的特性：_（接下来的叙述将会围绕着如何使无旋 $treap$ 完成 ”加点、删点、查第 $k$ 大、查排名、查前驱后继“ 来展开！）_ 人群当中突然钻出来一个奆佬，表示发现了一个二叉搜索树的巧妙性质： 以任意一个 在值域当中的数 $val$ 为分割线，一定能将二叉搜索树分成 “小于等于 $val$” 与 “大于 $val$” 两部分，且这两部分分开来看也各是一棵二叉搜索树。 还是以原来这棵树为例，如果我们从 $val=5$ 切割： （更正：右半边 $val=1$ 的结点对应标号应为 $4$ ） 我们发现这一个数就把他分（ $\\operatorname{split}$ ）成了两棵二叉搜索树。 我们借助这一性质，来尝试进行一些操作。 加点：首先考虑，我们直接加点时，往往只能做到把新点挂在外围。然后再经过胡乱操作（ 如 $splay$ 中的 $\\operatorname{rotate}$ ）保送这个新点到该去的位置。 而无旋 $treap$ 则没有这样的烦恼。 倘若我们要加一个 $val=2$ 的点，我们先把原树按 $2$ $\\operatorname{split}$ 出了 $L,R$ 两棵子树。 这时，我们创造一个游离的结点，保存新元素的值。 如此实现： 1234567891011121314151617181920struct node&#123; int son[2];//左右儿子 int val;//val值 int prio;//随机赋给其的prio值，用于建出一个堆 int size;//以之为根的子树大小&#125; T[MAX];#define ls(a) T[(a)].son[0]#define rs(a) T[(a)].son[1]//宏定义int ROOT, cnt = 0;//根、当前点的编号void add(int x)//造一个游离点&#123; T[++cnt].size = 1; T[cnt].val = x; T[cnt].prio = rand(); ls(cnt) = rs(cnt) = 0;//各种初始化&#125; 此时，我们发现原来的平衡树，它裂了（悲），但问题不大，我们可以想办法合并（ $\\operatorname{merge}$ ）。 因为我们合并以后，需要仍然保持 $treap$ 的性质。故应判断需要合并的两棵树的 树根的 $prio$ 值的大小关系 。谁的 $prio$ 的更小，谁就挂在对方的下面。（怪） 这样我们先将这个游离点与左树 $\\operatorname{merge}$ ，再将左树与右树 $\\operatorname{merge}$ 即可～ （图被我弄丢了ToT ，或许可以使用上面那张图格物致知？） 那么，当我们在加点过程中，把一个不平衡的二叉搜索树 裂开来 ，再以一种平衡的方式 合并 回去，就能起到“制衡”的作用辣！$AwA$ 该部分代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void push_up(int p)//更新size&#123; T[p].size = T[ls(p)].size + T[rs(p)].size + 1;&#125;void split(int p, int x, int &amp;L, int &amp;R)//p,x:当前递归到的点、需要加的值//&amp;L,&amp;R:传进来两个地址来把最后分出的L,R树的根结点编号运出去&#123; if (!p)//递归边界 &#123; L = 0; R = 0; return; &#125; if (T[p].val &lt;= x)//判断条件，分裂（背板即可） &#123; L = p; split(rs(p), x, rs(p), R); &#125; else &#123; R = p; split(ls(p), x, L, ls(p)); &#125; push_up(p);&#125;int merge(int Lroot, int Rroot)//合并的左右树根&#123; if (!Lroot) &#123; return Rroot; &#125; if (!Rroot) &#123; return Lroot; &#125;//倘若另一边为空，则不用和空气贴贴了，直接返回 if (T[Lroot].prio &lt; T[Rroot].prio)//否则判断谁在下面 &#123; rs(Lroot) = merge(rs(Lroot), Rroot); //返回的值是两树合并后的大树的树根 push_up(Lroot); return Lroot; &#125; else &#123; ls(Rroot) = merge(Lroot, ls(Rroot)); push_up(Rroot); return Rroot; &#125;&#125;void insert(int x)&#123; int l, r; split(ROOT, x, l, r);//先裂开来 add(x);//创造游离点 ROOT = merge(merge(l, cnt), r); //先合并左树和新点，再合并左树和右树&#125; 删点：不会真的有人删点是去把目标结点清空的吧，不会吧不会吧。 $splay$ 删点的做法是把它 $\\operatorname{rotate}$ 到根然后往虚空里一丢。 可无旋 $treap$ 之所以叫“无旋”，就是因为它没有旋转的操作。 我们充分利用无旋 $treap$ 的特性，大力将要删的结点 $u$ 从全树上 $\\operatorname{split}$ 出来，再将 除去 $u$ 的剩余几部分 大力 $\\operatorname{merge}$ 回去。最终就能收获一个不带 $u$ 的新树辣！ 图示如下 $AwA$ ：（假设我们现在要删值为 $x=6$ 的点） 先裂开来。再排除 $val=x=6$ 的 $3$ 号点，进行如此合并。 这部分的代码实现～ 12345678void erase(int x)&#123; int l, r, tmp; split(ROOT, x, l, tmp);//先将大于x的部分split出来 split(l, x - 1, l, r);//再将小于x的部分split出来 r = merge(ls(r), rs(r));//为防止R的儿子分崩离析，先合并其儿子 ROOT = merge(merge(l, r), tmp);//按顺序合并&#125; 为什么只用担心 $R$ 的儿子分崩离析？ 因为他的位置很尴尬，他的左儿子可能会被 $x-1$ 的一刀砍断，右儿子可能会被 $x$ 的一刀砍断。（惨 R 惨） 查第 $k$ 大：因为这是一棵二叉搜索树，所以用脚想都知道一种可行的方法是中序遍历再查。 而且这种方法复杂度还不赖，甚至有 $O(n)$ ！（暴力之耻） 可是你清醒一点，这是一棵平衡树，他的常数不可谓不小。 再者说之后我们的 $pre$ 和 $nxt$ 函数也要用到它（好像有点剧透？）。 我们希望找到一个复杂度优秀的做法。 我们突然想到，我们 $treap$ 的结点信息里，似乎还保存了一个 $size$ 变量。 $\\color{black}\\mathtt{D}\\color{red}\\mathtt{Pair}$ 神说过，优化的第二种方式是 “可并的操作一起处理” 。 如果我们明明知道左子树里根本没有 $k$ 这么多个元素，也就不可能存在第 $k$ 大的数。那我们凭什么往里面去递归。 这 给 了我们一个启发，根据 $size$ 确定递归范围，逐层找到对应位置。 代码实现如下～ 1234567891011121314int getkth(int p, int K)&#123; if (K &lt;= T[ls(p)].size)//如果左子树里的的确确有k这么多的元素 &#123; return getkth(ls(p), K);//就找这其中的第k个 &#125; if (K == T[ls(p)].size + 1)//如果发现当前就是你要找的那个 &#123; return p;//返回 &#125; return getkth(rs(p), K - T[ls(p)].size - 1); //否则，左子树把k消耗掉了T[ls(p)].size，自己又消耗掉了1 //则在右子树里查第k - T[ls(p)].size - 1位&#125; 获取元素排名：这一操作用的不多，随便口胡一下（逃 我们把一个元素以它的 $val$ 值 $split$ 出来。这时人群当中钻出来一个 $dalao$ ，他说：“我知道了，$L$ 树里的元素全都是比它小的！” u1s1，qs。 有 $T[ls(p)].size$ 这么多的元素比它小，那么显而易见地，这个元素的排名就是 $T[ls(p)].size+1$ 。 别忘了 $\\operatorname{merge}$ 回去。 代码如下～ 12345678int getrank(int p, int K)&#123; int l, r; split(ROOT, K - 1, l, r);//按k-1 split出来 int ans = T[l].size + 1;//获得排名 ROOT = merge(l, r);//合并回去 return ans;//返回值&#125; 查前驱：我们之前提（剧透）到查前驱也是要用到查 $k$ 小值这一操作，想必各位一定已经YY出了做法了吧。 实则很简单，我们查前驱，实则就是要找小于 $x$ 的元素中，最大的一个，我们把小于 $x$ 的部分 $\\operatorname{split}$ 出来后，取出这一部分的第 $T[L].size$ 位元素就可了。 别忘了 $\\operatorname{merge}$ 回去。 12345678int pre(int x)&#123; int l, r; split(ROOT, x - 1, l, r);//将小于x的部分分离出来 int ans = T[getkth(l, T[l].size)].val;//取第T[l].size位 ROOT = merge(l, r); return ans;&#125; 查后缀：后缀与前驱同理，不多加赘述： 12345678int nxt(int K)&#123; int l, r; split(ROOT, K, l, r);//将大于x的部分分离出来 int ans = T[getkth(r, 1)].val;//取第1位 ROOT = merge(l, r); return ans;&#125;得，这就是无旋 $treap$ 吗，i了i了。 劲爆习题:模板题：【模板】普通平衡树 板子题首当其 冲 ！ 要求的就是之前的六个操作，码一遍就 VAN 事了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include &lt;bits/stdc++.h&gt;using namespace std;#define ls(a) T[(a)].son[0]#define rs(a) T[(a)].son[1]const int MAX = 1e5 + 7;int N, ROOT, cnt = 0;struct node&#123; int son[2]; int fa; int val; int prio; int size;&#125; T[MAX];/*创造新点*/void add(int x)&#123; cnt++; T[cnt].size = 1; T[cnt].val = x; T[cnt].prio = rand(); ls(cnt) = rs(cnt) = 0;&#125;/*整合子树信息*/void push_up(int p)&#123; T[p].size = T[ls(p)].size + T[rs(p)].size + 1;&#125;/*分裂*/void split(int p, int x, int &amp;L, int &amp;R)&#123; if (!p) &#123; L = 0; R = 0; return; &#125; if (T[p].val &lt;= x) &#123; L = p; split(rs(p), x, rs(p), R); &#125; else &#123; R = p; split(ls(p), x, L, ls(p)); &#125; push_up(p);&#125;/*合并*/int merge(int Lroot, int Rroot)&#123; if (!Lroot) &#123; return Rroot; &#125; if (!Rroot) &#123; return Lroot; &#125; if (T[Lroot].prio &lt; T[Rroot].prio) &#123; rs(Lroot) = merge(rs(Lroot), Rroot); push_up(Lroot); return Lroot; &#125; else &#123; ls(Rroot) = merge(Lroot, ls(Rroot)); push_up(Rroot); return Rroot; &#125;&#125;/*插入操作*/void insert(int x)&#123; int l, r; split(ROOT, x, l, r); add(x); ROOT = merge(merge(l, cnt), r);&#125;/*删除操作*/void erase(int x)&#123; int l, r, p; split(ROOT, x, l, p); split(l, x - 1, l, r); r = merge(ls(r), rs(r)); ROOT = merge(merge(l, r), p);&#125;/*查第K大*/int getkth(int p, int K)&#123; if (K &lt;= T[ls(p)].size) &#123; return getkth(ls(p), K); &#125; if (K == T[ls(p)].size + 1) &#123; return p; &#125; return getkth(rs(p), K - T[ls(p)].size - 1);&#125;/*获取排名*/int getrank(int p, int K)&#123; int l, r; split(ROOT, K - 1, l, r); int ans = T[l].size + 1; ROOT = merge(l, r); return ans;&#125;/*获取前驱*/int pre(int K)&#123; int l, r; split(ROOT, K - 1, l, r); int ans = T[getkth(l, T[l].size)].val; ROOT = merge(l, r); return ans;&#125;/*获取后继*/int nxt(int K)&#123; int l, r; split(ROOT, K, l, r); int ans = T[getkth(r, 1)].val; ROOT = merge(l, r); return ans;&#125;int main()&#123; srand(20050418);//窝npy的生日ww int Q; cin &gt;&gt; Q; while (Q--) &#123; int opt, num; cin &gt;&gt; opt; if (opt == 1) &#123; cin &gt;&gt; num; insert(num); &#125; if (opt == 2) &#123; cin &gt;&gt; num; erase(num); &#125; if (opt == 3) &#123; cin &gt;&gt; num; cout &lt;&lt; getrank(ROOT, num) &lt;&lt; endl; &#125; if (opt == 4) &#123; cin &gt;&gt; num; cout &lt;&lt; T[getkth(ROOT, num)].val &lt;&lt; endl; &#125; if (opt == 5) &#123; cin &gt;&gt; num; cout &lt;&lt; pre(num) &lt;&lt; endl; &#125; if (opt == 6) &#123; cin &gt;&gt; num; cout &lt;&lt; nxt(num) &lt;&lt; endl; &#125; &#125;&#125;EX-模板题 ：【模板】文艺平衡树 CSP到了，我向佛祖许愿，希望我的平衡树能实现区间翻转。 佛说：“我的正解是 $splay$ ，那你这在无旋 $treap$ 上如何实现？” 我说：“无旋 $treap$ 的区间处理能力之强。它可以用两次 $\\operatorname{split}$ 轻松取出一段区间。” “ splay 做得到吗？”（拉狗行为） 佛说：“你翻转了区间，那你这还能叫二叉搜索树吗，你的 $\\operatorname{split}$ 不是废了？” 我说：“我的 $\\operatorname{split}$ 是按 $size$ 分裂的，这样才可以确定这个区间在原序列上的位置。”（详见代码） 佛说：“不行，单单只是取出一段区间来个 ODT 也能做到，你有什么好说的。” 我说：“那就打一下 $tag$ 。同一区间翻转两次=全部木大。” 佛说：“不行，我这是一棵平衡树，又不是什么线段树。” 我说：“那我就把标记，打在 分离出来的区间 的根上，到时候标记下传的时候只需要一番大力 $swap$ 。” 佛说：“不行，我还是不知道怎么打标记。” 我说：“那就来一张图演示一下这一流程。” （本图不代表最终要操作的序列，但不影响观看） 佛说：“不行，我不知道什么时候该下传标记。” 我说：“打过线段树的都知道，不到 修改 或 查询 的时候是不用 $push_down$ 的。这里也是如此。” “修改是没有什么用得上下传标记的地方的，毕竟每次我们分离出一段区间的时候，往往只是在这里打个 $tag$ 。从来没有 影响过其他地方 的 $tag$ 。” “而查询，基于 『二叉搜索树的中序遍历是它所代表的原序列』 这一重要思想，我们应该在输出的时候 $push_down$ 就可以了。 佛说：“不行，那你这 $push_down$ 函数里面要干什么事情。” 我说：“我们观察到，翻转一个区间，可以看作是一个位置为对称轴，将一段区间 左右翻转 得来。” “知道了这一个条件，我们有了一种强烈的意识，在平衡树上交换一个结点的 左右两孩子 ，等价于在序列上将一个元素的 左右两边交换 。” 佛说：“我不信。” 我说：“手模一下不是有手就行？” “我们先把6号结点的 $tag$ 先处理了，再把标记往下传，递归进行 ‘交换左右儿子’ 这一动作直到叶子结点不就是了。” 佛说：“不行，我是伸手党，我要看代码。” 我说：“彳亍。” 1234567891011void push_down(int p)&#123; if (T[p].tag == 0) &#123; return; &#125; swap(ls(p), rs(p));//交换左右两儿子 T[ls(p)].tag ^= 1;//下传标记 T[rs(p)].tag ^= 1; T[p].tag = 0;//清空标记&#125; 佛哭了，说：”这样就能AC了。“ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;bits/stdc++.h&gt;using namespace std;/*无旋treap基础组件，因码风而异*/#define ls(a) T[(a)].son[0]#define rs(a) T[(a)].son[1]const int MAX = 1e5 + 7;int ROOT;struct node&#123; int val; int son[2]; int size; int tag; long long prio;&#125; T[MAX];void push_up(int p)&#123; T[p].size = T[ls(p)].size + T[rs(p)].size + 1;&#125;/*下传标记*/void push_down(int p)&#123; if (T[p].tag == 0) &#123; return; &#125; swap(ls(p), rs(p)); T[ls(p)].tag ^= 1; T[rs(p)].tag ^= 1; T[p].tag = 0;&#125;int cnt;/*创造一个新结点*/void add(int x)&#123; T[++cnt].val = x; T[cnt].prio = rand(); T[cnt].size = 1; ls(cnt) = rs(cnt) = 0;&#125;/*分离*/void split(int p, int x, int &amp;L, int &amp;R)&#123; push_down(p); if (!x) &#123; L = 0; R = p; return; &#125; if (T[ls(p)].size &lt; x)//这样才能精准定位在原序列上 &#123; L = p; split(rs(p), x - T[ls(p)].size - 1, rs(p), R); &#125; else &#123; R = p; split(ls(p), x, L, ls(p)); &#125; push_up(p);&#125;/*合并*/int merge(int Lroot, int Rroot)&#123; if (!Lroot || !Rroot) &#123; return Rroot + Lroot; &#125; push_down(Lroot); push_down(Rroot); if (T[Lroot].prio &gt;= T[Rroot].prio) &#123; rs(Lroot) = merge(rs(Lroot), Rroot); push_up(Lroot); return Lroot; &#125; else &#123; ls(Rroot) = merge(Lroot, ls(Rroot)); push_up(Rroot); return Rroot; &#125;&#125;/*插入，其实是用来初始化 treap 用的*/void insert(int p, int x)&#123; int l = 0, r = 0; split(ROOT, p - 1, l, r); add(x); // cout &lt;&lt; cnt &lt;&lt; endl; ROOT = merge(merge(l, cnt), r);&#125;/*翻转*/void reverse(int l, int r)&#123; int p1 = 0, p2 = 0, p3 = 0; split(ROOT, r, p1, p2);//右边断开，剩下的装在p1里 split(p1, l - 1, p1, p3);//左边断开，剩下的装在p3里 //这时我们取出的区间，其实就是以p3为根这棵树 T[p3].tag ^= 1;//打tag ROOT = merge(merge(p1, p3), p2);//合并回去&#125;/*中序遍历输出*/void print(int p)&#123; if (p == 0) &#123; return; &#125; push_down(p); print(ls(p)); cout &lt;&lt; T[p].val &lt;&lt; &#x27; &#x27;; print(rs(p));&#125;int N, M;int main()&#123; srand(20050418);//窝npy的生日qwq cin &gt;&gt; N &gt;&gt; M; for (int i = 1; i &lt;= N; i++) &#123; insert(i, i);//初始化 &#125; while (M--) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; reverse(l, r); &#125; print(ROOT);&#125; 次模板题： [NOI2004]郁闷的出纳员 一道深刻考验选手对无旋 $treap$ 内层原理的（毒瘤）好题。 这题要求：1.全局加减 $k$ ，2.删去小于 $val$ 的所有元素 ，3.插入一个元素 ， 4.查询第 $k$ 大。 首先一眼发现，因为加减都是全局加减，所以根本没有必要真的加在每一个元素上，随手开个 $delta$ ，表示 全局的改变量 。 而剩下与数值有关的，只有一个 “删去小于 $val$ 的所有元素” 操作了。 因为我们手上有 $delta$ ，我们可以顺理成章地把这一操作看作 “删去小于 $val-delta$ 的所有元素” 。 _（以元素值为参考系（误），元素值增加了delta，可以看作是这个val减小了delta）_ “真正的勇士，敢于面对直接枚举元素的复杂度。”（$\\times$） “真正的勇士，敢于面对 TLE 0 。”（$\\surd$） 你意识到无旋 $treap$ 的 $\\operatorname{split}$ 的作用就是将原树分成 “ 小于等于 $val$ ” 与 “ 大于 $val$ ” 两部分。 那我们以 $val-delta$ 分，不就可以让我们分离出来的左树，装的都是小于 $val-delta$ 的元素了？ 分离完了以后直接使 全树的 ROOT 等于右树的根 ，相当于把左树里这些小于 $val$ 的数全部逐入虚空。 这样便可实现删点。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;bits/stdc++.h&gt;using namespace std;#define ls(a) T[(a)].son[0]#define rs(a) T[(a)].son[1]const int MAX = 1e5 + 7;int N, ROOT, cnt = 0, delta = 0;//delta为改变量struct node&#123; int son[2]; int fa; int val; int prio; int size;&#125; T[MAX];/*创造新点*/void add(int x)&#123; cnt++; T[cnt].size = 1; T[cnt].val = x; T[cnt].prio = rand(); ls(cnt) = rs(cnt) = 0;&#125;/*整合子树信息*/void push_up(int p)&#123; T[p].size = T[ls(p)].size + T[rs(p)].size + 1;&#125;/*分裂*/void split(int p, int x, int &amp;L, int &amp;R)&#123; if (!p) &#123; L = 0; R = 0; return; &#125; if (T[p].val &lt;= x) &#123; L = p; split(rs(p), x, rs(p), R); &#125; else &#123; R = p; split(ls(p), x, L, ls(p)); &#125; push_up(p);&#125;/*合并*/int merge(int Lroot, int Rroot)&#123; if (!Lroot) &#123; return Rroot; &#125; if (!Rroot) &#123; return Lroot; &#125; if (T[Lroot].prio &lt; T[Rroot].prio) &#123; rs(Lroot) = merge(rs(Lroot), Rroot); push_up(Lroot); return Lroot; &#125; else &#123; ls(Rroot) = merge(Lroot, ls(Rroot)); push_up(Rroot); return Rroot; &#125;&#125;/*插入操作*/void insert(int x)&#123; int l, r; split(ROOT, x, l, r); add(x); ROOT = merge(merge(l, cnt), r);&#125;/*删除左树*/int deleteall(int x)&#123; int l, r, tmp; split(ROOT, x - 1, l, r); int ans = T[l].size; ROOT = r;//以右树为根 return ans;//返回丢弃的元素数，即T[l].size&#125;/*查第k大*/int getkth(int p, int k)&#123; if (T[ls(p)].size &gt;= k) &#123; return getkth(ls(p), k); &#125; if (T[ls(p)].size + 1 == k) &#123; return p; &#125; return getkth(rs(p), k - T[ls(p)].size - 1);&#125;int main()&#123; srand(20050418); int sumout = 0;//总共被丢掉的人数 int N, LIM;//LIM，下界 cin &gt;&gt; N &gt;&gt; LIM; for (int i = 1; i &lt;= N; i++) &#123; char opt; cin &gt;&gt; opt; if (opt == &#x27;I&#x27;) &#123; int num; cin &gt;&gt; num; if (num &lt; LIM) &#123; continue; &#125; insert(num - delta); //相对地，插入的num也会减小delta &#125; if (opt == &#x27;A&#x27;) &#123; int num; cin &gt;&gt; num; delta += num; &#125; if (opt == &#x27;S&#x27;) &#123; int num; cin &gt;&gt; num; delta -= num; sumout += deleteall(LIM - delta); //相对地，插入的LIM也会减小delta &#125; if (opt == &#x27;F&#x27;) &#123; int num; cin &gt;&gt; num; if (T[ROOT].size &lt; num) &#123; cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;; continue; &#125; cout &lt;&lt; T[getkth(ROOT, T[ROOT].size - num + 1)].val + delta &lt;&lt; endl; //相应地，查到的第k大也要+delta &#125; &#125; cout &lt;&lt; sumout &lt;&lt; endl;&#125; 网络流基础建模——最大流这里讲的不是实现，只是一些套路。 \\color{red}{\\texttt{FBI WARNING:}}\\color{red}{\\texttt{警告：以下内容可能涉及口胡、强迫症、及光敏性癫痫（划）}}\\color{red}{\\texttt{请18岁以下儿童在成年人陪同下观看}} 都0202年了，不会真有人认为网络流都是套路题吧？ 哦是我啊那没事了。 套路一：构建超级源汇：有的题目，他告诉你谁和谁之间有阿巴阿巴的路径，但硬是不告诉你谁是源，谁是汇。 这时候，朴素的最大流思想可能就会陷入僵局。 但是我们有超级源汇的思想。 我们 创建一个新点 ，称其为源。 向所有该连的点连边。 汇的思想同理。 建一张图就像这样： 可以看出，这一思想用于处理 “你……，他……，而我……，我们都有全局的贡献” 的问题。 下面来看这个命题： _RUI_R有了去NOI和APIO的资格，zjjws有了去WC和APIO的资格，而我有了去加里敦参加夏令营的资格，我们都有对XJ的贡献。试问，如果一个人只能去打一场比赛，XJ能收获多少参赛名额。_ 一眼看出，这是典型的多源多汇模型。 把每个人和自己能参加的比赛连边，这时相当于是跑一个 二分图最大匹配 。 而我们要以网络流的思想解决，则需要 开一个超级源，向所有人连边，开一个超级汇，让所有比赛向它连边 。 这里超级源连出去的边容量为1，即 限制了每个人最多 只能打一场比赛 ，也就是 从一个人流出的流量最多为1 。 这启发我们，超级源汇在连边时可以有意无意地起到 限流 作用。 劲爆例题：飞行员配对方案问题 典型的二分图最大匹配，一边是英国飞行员，一边是外国飞行员，如果俩人能打配合，就在俩人之间连边。 随手像上面那样建一张图。 这时我们发现，外国飞行员也是人，他也只能和一个人进行配对。 外国飞行员 使用分身术，出现了一个新的 外国飞行员 所有右边的点向超级汇的连边，容量改为 $1$ 。 这样我们就建出了一张图，在这张图上跑一个最大流就珂以了。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;using namespace std;/*dinic组件*/#define int long longconst int MAX = 107;const int INF = 1e18;int N, M;struct edge&#123; int next, to, val;&#125; e[MAX * MAX &lt;&lt; 1];int head[MAX], eid = 1;void adde(int x, int y, int w)&#123; e[++eid].next = head[x]; e[eid].to = y; e[eid].val = w; head[x] = eid;&#125;int S, T;int dep[MAX];int flag = 0;queue&lt;int&gt; q;#define RUN(u) for (int i = head[(u)]; i; i = e[i].next)void bfs()&#123; memset(dep, 0, sizeof(dep)); dep[S] = 1; while (!q.empty()) &#123; q.pop(); &#125; q.push(S); while (!q.empty()) &#123; int u = q.front(); q.pop(); RUN(u) &#123; int v = e[i].to; if (dep[v] || e[i].val == 0) &#123; continue; &#125; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; if (dep[T]) &#123; flag = 1; &#125;&#125;int dfs(int u, int in)&#123; if (u == T) &#123; return in; &#125; int out = 0; RUN(u) &#123; int v = e[i].to; if (dep[v] != dep[u] + 1 || e[i].val == 0) &#123; continue; &#125; int tmp = dfs(v, min(in, e[i].val)); e[i].val -= tmp; e[i ^ 1].val += tmp; in -= tmp; out += tmp; &#125; if (out == 0) &#123; dep[u] = 0; &#125; return out;&#125;signed main()&#123; int num; cin &gt;&gt; N &gt;&gt; num; int fr, to; S = 0;//超级源定为0号 T = num + 1;//超级汇定为num+1号 /*反正只要是个用不上的点就可以了*/ while (cin &gt;&gt; fr &gt;&gt; to &amp;&amp; fr != -1 &amp;&amp; to != -1) &#123; adde(fr, to, 1);//能配合的俩人连一条边 adde(to, fr, 0); &#125; for (int i = 1; i &lt;= N; i++) &#123; adde(S, i, 1);//超级源向英国飞行员连边 adde(i, S, 0); &#125; for (int i = N + 1; i &lt;= num; i++) &#123; adde(i, T, 1);//外国飞行员向超级汇连边 adde(T, i, 0); &#125; int ans = 0; /*奇怪的dinic，写法因人而异*/ while (1) &#123; flag = 0; bfs(); if (flag == 0) &#123; break; &#125; ans += dfs(S, INF); &#125; cout &lt;&lt; ans &lt;&lt; endl; for (int i = 2; i &lt;= eid; i++, i++) &#123; if (e[i].to != S &amp;&amp; e[i ^ 1].to != S &amp;&amp; e[i].to != T &amp;&amp; e[i].to != T) //输出方案 //这里的做法是遍历每一条边，查他是否有残量 &#123; if (e[i ^ 1].val) &#123; cout &lt;&lt; e[i ^ 1].to &lt;&lt; &#x27; &#x27; &lt;&lt; e[i].to &lt;&lt; endl; &#125; &#125; &#125;&#125; 套路二：最大流改最小割：窝非常擅长鸽。 有的题目，他告诉你选了阿巴阿巴就不能选阿巴阿巴。 这时候，朴素的最大流思想可能就会陷入僵局。 但是神仙们证出了最大流等于最小割。 这个问题就转化成了，我 放弃选一些东西，使我剩下的收益最大 。 考虑全图中从源点到汇点的一条路径，假设这条路径是由 好几段拼成 的。 我想把它割断至无法通流，则必然是割断其中的 某一段 。这个“割断”的过程，实则就是相当于 放弃了这一段的收益 。 而这条路径上的其它几段得以保留，所以我能获得剩下的这些收益。 这时，存在两条路径从源点通往汇点的路径，我们要把他们割断，一种可行的做法是割断 $value_{\\ 5}$ 使剩下4个 $value$ 得以保留。 当然，还存在一种做法是割断 $value_1,value_3$ 使剩下三个得以保留。 此外，在有的题目中，有的利益是固定利益，是无法丢弃的，这时，我们就可以将这条边的容量设为 INF 。 可以看出，最小割模型非常善于处理 “可以……，但是你得……，这一切值得吗？”的问题。 下面来看这个命题： _“我告诉你，但是你得跟我搞姬，这一切值得吗？”_ 我们可以看出这里存在一个约束关系， “ 我可以得到题解，但是我有翻车的危险，即‘失去了安全’ ”。 那么很显然我们可以建出一张图，像这样： 颜色好评，如果我们选择了题解，那么我们就会失去开车的安全；反之同理。 劲爆例题：方格取数问题 首先，一眼看出模型，“我可以选这个点，但是我就选不了周围这些点了，这一切值得吗？”。 那么我们随便挑出两个相邻的方格，都可以建出这样的图。 表示要么选 $val_1$ ，要么选 $val_2$ 。 如果我们对于每一个点建一张如上例的图，最终的成品就是这个玩意。 这时我们发现，这张图根本没有源和汇。/jk 但是我们的内心毫无波澜，甚至一眼出了 超级源汇 的思想。 可超级源汇的模型也不是用脚造的，我们需要决定 谁去连源，谁去连汇 。 想起了之前飞行员配对的做法，我们可以把这些点分出一张 二分图 。 二分图的要求是同一部分内 无连边 。正难则反，什么点之间有连边？显然是相邻的点。 那么，无连边的部分，必然是那些不相邻的。 这时，我们就可以用黑白染色的方式，建出如下的图。 此时，随便挑出一条路径来，依然满足 最小割 的样式，可以在这上面跑最大流，来求出这一 最小的舍弃价值 。 而我们收获的价值，就是 所有价值总和-舍弃的价值 。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAX = 1e5 + 7;const int INF = 1e18;/*dinic组件*/struct edge&#123; int next, to; int val;&#125; e[MAX &lt;&lt; 1];int head[MAX], eid = 1;void adde(int x, int y, int w)&#123; e[++eid].next = head[x]; e[eid].to = y; e[eid].val = w; head[x] = eid;&#125;int dep[MAX];int flag = 0;queue&lt;int&gt; q;int S, T;#define RUN(u) for (int i = head[u]; i; i = e[i].next)void bfs()&#123; memset(dep, 0, sizeof(dep)); dep[S] = 1; while (!q.empty()) &#123; q.pop(); &#125; q.push(S); while (!q.empty()) &#123; int u = q.front(); q.pop(); RUN(u) &#123; int v = e[i].to; if (e[i].val == 0 || dep[v]) &#123; continue; &#125; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; if (dep[T]) &#123; flag = 1; &#125;&#125;int dfs(int u, int in)&#123; if (u == T) &#123; return in; &#125; int out = 0; RUN(u) &#123; int v = e[i].to; if (e[i].val == 0 || dep[v] != dep[u] + 1) &#123; continue; &#125; int tmp = dfs(v, min(in, e[i].val)); if (in == 0) &#123; return out; &#125; e[i].val -= tmp; e[i ^ 1].val += tmp; in -= tmp; out += tmp; &#125; if (out == 0) &#123; dep[u] = 0; &#125; return out;&#125;int M, N;int idx(int x, int y)//获取一个方格的编号&#123; return (x - 1) * N + y;&#125;signed main()&#123; cin &gt;&gt; M &gt;&gt; N;//这道题对N,M的定义是和常识相反的 //申必题（bushi int sum = 0; S = 0, T = 107 * 107 + 1; for (int i = 1; i &lt;= M; i++) &#123; for (int j = 1; j &lt;= N; j++) &#123; int num; cin &gt;&gt; num; sum += num; if ((i + j) &amp; 1)//若行+列=奇则染白，连源点 &#123; adde(S, idx(i, j), num); adde(idx(i, j), S, 0); /*向上下左右四个方向连边*/ if (i &gt; 1) &#123; adde(idx(i, j), idx(i - 1, j), INF); adde(idx(i - 1, j), idx(i, j), 0); &#125; if (i &lt; M) &#123; adde(idx(i, j), idx(i + 1, j), INF); adde(idx(i + 1, j), idx(i, j), 0); &#125; if (j &gt; 1) &#123; adde(idx(i, j), idx(i, j - 1), INF); adde(idx(i, j - 1), idx(i, j), 0); &#125; if (j &lt; N) &#123; adde(idx(i, j), idx(i, j + 1), INF); adde(idx(i, j + 1), idx(i, j), 0); &#125; &#125; else//若行+列=偶则染黑，连汇点 &#123; adde(idx(i, j), T, num); adde(T, idx(i, j), 0); &#125; &#125; &#125; int ans = 0; while (1) &#123; flag = 0; bfs(); if (flag == 0) &#123; break; &#125; ans += dfs(S, INF); &#125; cout &lt;&lt; sum - ans &lt;&lt; endl;//收益为总价值-割&#125;套路二-进阶：其他黑白染色模型：上文的方格取数问题，可以归为一种黑白染色模型中的典型。 而解决这种问题，其要义在于构建一种可行的方式，将所有玩意分成两堆，使得任何 黑点与白点之间都没有直接连边 。 听上去很 $simple$ ，实际上的确很 $naive$ 。 就随便挑一道题来看叭～ _以下只阐述如何染色，其他实现细节在此不提_ 骑士共存问题 就用题目上的原图好了。 我们发现 $S$ 在一个黄点，而他的下一步必然是一个红点。（由图可知） 那么我们像方格取数一样，按 （行+列）的奇偶性 黑白染色即可。 甚至还能白嫖双倍经验 。 \\那个表情是超链接…… 长脖子鹿放置 长脖子鹿不会被别马腿因为长脖子鹿只有鹿腿哈哈哈哈哈哈哈 其实一点也不好笑 这道题面里还是有图，我们还是征用题面里的图。 可以看到这里，一个白点会跳到另一个白点上。我们之前（行+列）奇偶性染色法就不行了。 但我们会想出新方法切了这道题。 因为长脖子鹿跳一下是 $2\\times 4$ 的，我们发现，行和列加的都是偶数， 不影响其奇偶性 。 也就是说，奇行和偶行之间不会有连边。 所以我们将 奇行染黑，偶行染白 即可。 王者之剑 高质量好题/se/se/se（指题面 王固然是天下第一，但是这道题出题人也是脑洞真的大。 我们看见，每隔两秒周围四个地方的宝石都会消失。而这两秒之内我们能干什么，一秒踩在一块有宝石的砖上吸走了宝石，下一秒在一块空砖上赶路前往下一个有宝石的地方。 也就是说，我们吸走了一个地方的宝石， 周围四个位置 都是必然拿不到了的。 然后，就变成方格取数问题了？？？ 我直接震惊。 有一道叫 [国家集训队]部落战争 的题，看上去很像黑白染色，事实上他是最小路径覆盖问题。我们之后会提到。 套路一+套路二=套路三：最大权闭合子图模型“有的题目，他告诉你必须得选阿巴阿巴才能选阿巴阿巴。有时候选阿巴阿巴可能带来负收益。” 这和套路二的最小割模型没有什么区别，如果你是语文王子，你会发现上面这句话其实和套路二表达的是同一个意思。 只不过让人以为这里仿佛有负边权，然后自闭。 我们换一种说法：对于一个正收益的东西，我们要么 得到这个价值 ，要么 省下“得到这个价值”所需要的钱 。 由此一来，最小割的思想就呼之欲出力。 即：要么获得价值 $value$ ，要么赚回花费 $cost$ 。 由于一个正收益的物品，可能需要很多种的 前置花费 ，同时，一个负收益的物品可能同时成为很多物品的 前置花费 。 所以我们常常会用到超级源汇的思想 $qwq$ 。 不难看出，最大权闭合子图模型适合解决 “tyy讲题” 类型的题。 （生动比喻了有一大堆前置知识的数论 浅 谈） 我们来看下面这个命题： tyy在讲课，今天他要讲的是杜教筛和min25，其中，杜教筛需要莫反和积性函数的前置知识，min25需要多项式和积性函数的前置知识，学这些前置知识需要你爆掉一定的肝，但是学一个新科技筛法又可以恢复一定的肝，求自己最大收益。 一眼发现有 “前置知识” 这一 有 趣 的玩意。 我们把杜教筛单独拉出来看，有下面的最小割模型： （颜色好评） 表示我们要么去学杜教筛 $val_{mifafa}$ ，要么省下 $cost_{mobius}+cost_{multi}$ 的花费。 而放之全图就像这样： 迫真英语翻译。 这样，我们就可以跑出全图的最小割辣。 但是，我们此时不能直接用总价值减去最小割来求解。 我们此前称学习前置知识的价值，是 我们省下了多少肝 。 可我们什么也不学，他又不会白送我们这些肝。换言之，这些肝本就不是我们应得的。 我们本该得的，是学这些筛法所收获的科技知识。 明明是你自己要偷懒护肝的。 所以我们应该用所有筛法的收益之和，减去最小割，这才是我们最终的答案。 ans=val_{mifafa}+val_{min25}-smallest\\_cut劲爆例题：拍照 一眼看出，我可以获得拍一张照的价值，但是我有带几个人的前置条件。 这很容易就转化为了 最大权闭合子图 的模型。 用脚也可以造出同上例一样的图。 （其实用本题样例建出来的图和上一张图是一模一样的。） 然后按部就班做就VAN事了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;using namespace std;/*dinic组件*/#define int long longconst int MAX = 107 * 107;const int INF = 1e18;struct edge&#123; int to, next, val;&#125; e[MAX];int head[MAX], eid = 1;void adde(int x, int y, int w)&#123; e[++eid].to = y; e[eid].next = head[x]; e[eid].val = w; head[x] = eid;&#125;int dep[MAX];queue&lt;int&gt; q;int flag = 0;int S, T;#define RUN(u) for (int i = head[(u)]; i; i = e[i].next)void bfs()&#123; memset(dep, 0, sizeof(dep)); dep[S] = 1; while (!q.empty()) &#123; q.pop(); &#125; q.push(S); while (!q.empty()) &#123; int u = q.front(); q.pop(); RUN(u) &#123; int v = e[i].to; if (dep[v] || !e[i].val) &#123; continue; &#125; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; if (dep[T]) &#123; flag = 1; &#125;&#125;int N, M;int dfs(int u, int in)&#123; if (u == T) &#123; return in; &#125; int out = 0; RUN(u) &#123; int v = e[i].to; if (dep[v] != dep[u] + 1 || e[i].val == 0) &#123; continue; &#125; int tmp = dfs(v, min(in, e[i].val)); e[i].val -= tmp; e[i ^ 1].val += tmp; in -= tmp; out += tmp; &#125; if (out == 0) &#123; dep[u] = 0; &#125; return out;&#125;signed main()&#123; cin &gt;&gt; M &gt;&gt; N; S = 0, T = N + M + 1;//超级源汇 int sum = 0;//正收益之和 for (int i = 1; i &lt;= M; i++) &#123; int num; cin &gt;&gt; num;//照片价值，由源点连边，累加进sum sum += num; int l; adde(S, i, num); adde(i, S, 0); while (cin &gt;&gt; l &amp;&amp; l) &#123; adde(i, l + M, INF);//向前置条件连边 adde(l + M, i, 0); &#125; &#125; for (int i = 1; i &lt;= N; i++) &#123; int num; cin &gt;&gt; num;//前置花费，向汇点连边 adde(i + M, T, num); adde(T, i + M, 0); &#125; int ans = 0; while (1) &#123; flag = 0; bfs(); if (flag == 0) &#123; break; &#125; ans += dfs(S, INF); &#125; cout &lt;&lt; sum - ans &lt;&lt; endl;//跑最小割，出结果&#125; 套路四：拆点“有的题目，他告诉你他要最大收益，但是一个物品只能用阿巴阿巴次。或者他要最小割，但是割的是点，不是边。” 这是，朴素的最大流/最小割就会陷入僵局。 但是拆点是一个好 办 法。 拆点的要义是：把一个点拆成 入点 和 出点 两个点，在这两个点之间连上一条 一定容量 $limit$ 的边。 这样，任何时候，通过这个点的流量都只会控制在 $limit$ 之内。 老百度网盘了 具化到图上，如果我们需要控制通过一个点的流量永远不超过 $limit$ ，则有： $in$ 和 $out$ 都是从同一个点上拆出来的，我们让通过这个点的流量不超过 $limit$ ，实际上就可以把 $in$ 和 $out$ 之间这条边的容量限为 $limit$ 。 不难看出，拆点模型适合处理“购买超级会员享受8倍速度” 的百度云 限流 行为。 来看下面这个命题： XJ地形可以简化成一张有向无环图。在结点处，会站有值周班同学检查。此时，在他面前跑过的人 禁止超过 $W_i$ 。现在给出每个结点处的检查情况，试求最多有多少学生能在去食堂的路上跑步。 原题链接【12：20】（还没有数据） 很显然，这里有明显的限流现象。（ 指站在一旁看着高一学生 rush ） 从一个检查点到另一个检查点是随便你怎么跑的，从XJ中学12:20时的情况便可知晓。 言外之意是， 边 上的限流为 $inf$ 。 而对于一个点上的限流，我们把一个点拆成一个出点和一个入点，两点之间连长度为 人数限制 的一条边。 这样，我们就能建出这样一张图： 在这张图上，我们就可以做到通过每个检查点的人数不超过 $limit$ 人。 可以注意到的是，图上源连的是入点，汇连的是出点，前一个点的出点连的是后一个点的入点。 而这张图上的最大流，就是本题的答案。 劲爆习题：[USACO5.4]奶牛的电信Telecowmunication 之前是拆点求最大流，而现在是拆点求最小割。 不能割边，则把所有边的边权设成 $inf$ ，这是无可厚非的。 因为我们割的是点，而点在网络流上不好处理，所以我们把一个点拆成两个点，两点之间连容量为 $1$ 的边。 为什么连边权为 $1$ 呢？ 我们割一条这种边，相当于我们拆了一台电脑。（可怜的 FarmerJohn /dk） 而题目要求的是拆电脑的数量，那么设边权为 $1$ ，可以正好反映拆的数量。 答案即为全图的最小割。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAX = 1e5 + 7;const int INF = 1e18;/*dinic组件*/struct edge&#123; int next, to; int val;&#125; e[MAX &lt;&lt; 1];int head[MAX], eid = 1;void adde(int x, int y, int w)&#123; e[++eid].next = head[x]; e[eid].to = y; e[eid].val = w; head[x] = eid;&#125;int dep[MAX];int flag = 0;queue&lt;int&gt; q;int S, T;#define RUN(u) for (int i = head[u]; i; i = e[i].next)void bfs()&#123; memset(dep, 0, sizeof(dep)); dep[S] = 1; while (!q.empty()) &#123; q.pop(); &#125; q.push(S); while (!q.empty()) &#123; int u = q.front(); q.pop(); RUN(u) &#123; int v = e[i].to; if (e[i].val == 0 || dep[v]) &#123; continue; &#125; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; if (dep[T]) &#123; flag = 1; &#125;&#125;int dfs(int u, int in)&#123; if (u == T) &#123; return in; &#125; int out = 0; RUN(u) &#123; int v = e[i].to; if (e[i].val == 0 || dep[v] != dep[u] + 1) &#123; continue; &#125; int tmp = dfs(v, min(in, e[i].val)); if (in == 0) &#123; return out; &#125; e[i].val -= tmp; e[i ^ 1].val += tmp; in -= tmp; out += tmp; &#125; if (out == 0) &#123; dep[u] = 0; &#125; return out;&#125;int N, M;int com[MAX];signed main()&#123; cin &gt;&gt; N &gt;&gt; M; cin &gt;&gt; S &gt;&gt; T; S += N; //对于一个点 i ，我们钦定 i 为其入点，i+N 为其出点 //那么这里直接从源点的出点 (S+N) 开始。 for (int i = 1; i &lt;= M; i++) &#123; int fr, to; cin &gt;&gt; fr &gt;&gt; to; adde(fr + N, to, INF); //两点之间连边，fr_out 连向 to_in adde(to, fr + N, 0); adde(to + N, fr, INF);//双向边 adde(fr, to + N, 0); &#125; for (int i = 1; i &lt;= N; i++) &#123; adde(i, i + N, 1);//自己的出点入点连边 adde(i + N, i, 0); &#125; int ans = 0; while (1) &#123; flag = 0; bfs(); if (flag == 0) &#123; break; &#125; ans += dfs(S, INF); &#125; cout &lt;&lt; ans &lt;&lt; endl;//最小割出结果&#125; 套路一+套路四=套路四点五：网络流与LIS有的题目，他让你求 LIS 的条数 ，或者让你求删去哪个数会使 LIS 的值改变 。 这里的 LIS 实则是泛指所有转移方程为 $dp[i]=dp[j]+1$ 形式的 $dp$ 。 为什么称其为四点五是因为这一类型的题太少了，但是的的确确是一种新模型。给他一个面子。 我们直接丢出例题：最长不下降子序列问题 问题一：求一个序列上 LIS 的长度。 问题二：试求一个序列上 LIS 的条数。其中元素不能多次使用。 问题三：试求一个序列上 不同的 LIS 的条数。其中 $1$ 号和 $N$ 号元素可以多次使用。 末 日 三 问 在《导弹拦截》那里 打过炮 的人应该会知道，LIS 有一个 $O(n\\log n)$ 的优秀做法。 不会也没有关系，因为这道题只能用 $O(n^2)$ 做法。 求 LIS 的 $n^2$ 做法，状态转移方程如下： dp_{\\ i}=\\max\\{dp_{\\ j}\\}+1\\ (num_i>num_j)$dp_i$ 代表：到 $i$ 位置时的最长上升子序列。 我们之所以用这种 $n^2$ 方法，是因为我们要知悉每一个位置对应的 $dp$ 值。 一个 $dp$ 值为 $x$ 的位置，肯定能建出一条长为 $x$ 的路径，它是一条以 这个位置为结束 的 上升子序列 。 而这条路径上的每一条边，必然从 $dp$ 值 低的位置 连向 高的位置 。 这很好证明。如果从高的位置 $i$ 连向低的位置 $j$ ，有 $dp_i&gt;dp_j$ ： $i$ 之前必然拖着一条长为 $dp$ 的 上升序列 。而 $dp$ 值低顶多只顶得住 $dp_j$ 的长度，却承受不住 $dp_i$ 。（破路） 我们便可以以此，用 $dp$ 值分层，建出一张分层图： 我们推知这条序列的 LIS=3 。 也就是说，数一数这张图上有几条长为 $3$ 的路径，其中一个点只可以使用一次。（唐突数数） 这时，我们可以 转动脑髓，发动眼光 ，自己去构造网络流图，使得这一答案能被跑出。 因为是限制了通过 点 的流量，所以我们应该用套路四中的 拆点。把一个点拆成一个入点和一个出点，两点之间连容量为 $1$ 的边，表示限流为 $1$ 。 因为元素和元素之间没有什么限制，所以其他边容量为 $inf$ 。 而 $dp=1$ 和 $dp=LIS$ 的元素可能有多个，所以需要用到 超级源汇 的思想。将 $dp=1$ 的连源， $dp=LIS$ 的连汇。 最后跑最大流出答案。 而第三问，则只需要将 $1$ 号和 $N$ 号元素出入点之间的容量设为 $inf$ 即可。 实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAX = 5e5 + 7;const int INF = 1e18;/*dinic组件*/struct edge&#123; int next, to; int val;&#125; e[MAX &lt;&lt; 1];int head[MAX], eid = 1;int cur[MAX];void adde(int x, int y, int w)&#123; e[++eid].next = head[x]; e[eid].to = y; e[eid].val = w; head[x] = eid;&#125;int dep[MAX];int flag = 0;queue&lt;int&gt; q;int S, T;#define RUN(u) for (int i = head[u]; i; i = e[i].next)void bfs()&#123; memset(dep, 0, sizeof(dep)); dep[S] = 1; while (!q.empty()) &#123; q.pop(); &#125; q.push(S); while (!q.empty()) &#123; int u = q.front(); q.pop(); RUN(u) &#123; int v = e[i].to; if (e[i].val == 0 || dep[v]) &#123; continue; &#125; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; if (dep[T]) &#123; flag = 1; &#125; memcpy(cur, head, sizeof(head));//这时笔者使用了弧优化 //可以去学一下&#125;int dfs(int u, int in)&#123; if (u == T || !in) &#123; return in; &#125; int out = 0; for (int i = cur[u]; i; i = e[i].next) &#123; cur[u] = i; int v = e[i].to; if (e[i].val == 0 || dep[v] != dep[u] + 1) &#123; continue; &#125; int tmp = dfs(v, min(in, e[i].val)); e[i].val -= tmp; e[i ^ 1].val += tmp; in -= tmp; out += tmp; if (in == 0) &#123; return out; &#125; &#125; if (out == 0) &#123; dep[u] = 0; &#125; return out;&#125;int N;int dp[MAX], num[MAX], len = 1;//num序列上的元素值，len最长上升子序列的长度signed main()&#123; cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) &#123; cin &gt;&gt; num[i]; &#125; for (int i = 1; i &lt;= N; i++) &#123; dp[i] = 1; &#125; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= i - 1; j++) &#123; if (num[j] &lt;= num[i]) &#123; dp[i] = max(dp[i], dp[j] + 1); //n方出答案 &#125; &#125; len = max(len, dp[i]); &#125; cout &lt;&lt; len &lt;&lt; endl; if (len == 1)//特判len=1 &#123; cout &lt;&lt; N &lt;&lt; endl; //即每个元素都是一个LIS sort(num + 1, num + 1 + N); int tot = unique(num + 1, num + 1 + N) - num - 1; //因为第三问要求的是不同的LIS //故须去重后输出 cout &lt;&lt; tot &lt;&lt; endl; return 0; &#125; S = 0, T = N * 2 + 1; for (int i = 1; i &lt;= N; i++) &#123; /*建各种边*/ adde(i, i + N, 1); adde(i + N, i, 0); if (dp[i] == 1) &#123; adde(S, i, INF); adde(i, S, 0); &#125; if (dp[i] == len) &#123; adde(i + N, T, INF); adde(T, i + N, 0); &#125; for (int j = i + 1; j &lt;= N; j++) &#123; if (dp[i] + 1 == dp[j] &amp;&amp; num[j] &gt;= num[i]) &#123; adde(i + N, j, 1); adde(j, i + N, 0); &#125; &#125; &#125; int ans = 0; while (1) &#123; flag = 0; bfs(); if (flag == 0) &#123; break; &#125; ans += dfs(S, INF); &#125; cout &lt;&lt; ans &lt;&lt; endl;//出第二问答案 memset(head, 0, sizeof(head));//清空 eid = 1; S = 0, T = N * 2 + 1; /*重新建边*/ for (int i = 1; i &lt;= N; i++) &#123; /*出入点之间*/ if (i == 1 || i == N) &#123; adde(i, i + N, INF); adde(i + N, i, 0); &#125; else &#123; adde(i, i + N, 1); adde(i + N, i, 0); &#125; &#125; for (int i = 1; i &lt;= N; i++) &#123; for (int j = i + 1; j &lt;= N; j++) &#123; /*dp值低的连向高的*/ if (dp[i] + 1 == dp[j] &amp;&amp; num[j] &gt;= num[i]) &#123; adde(i + N, j, 1); adde(j, i + N, 0); &#125; &#125; &#125; for (int i = 1; i &lt;= N; i++) &#123; /*源汇连边*/ if (dp[i] == 1) &#123; if (i == 1 || i == N) &#123; adde(S, i, INF); adde(i, S, 0); &#125; else &#123; adde(S, i, 1); adde(i, S, 0); &#125; &#125; if (dp[i] == len) &#123; if (i == i || i == N) &#123; adde(i + N, T, INF); adde(T, i + N, 0); &#125; else &#123; adde(i + N, T, 1); adde(T, i + N, 0); &#125; &#125; &#125; ans = 0; while (1) &#123; flag = 0; bfs(); if (flag == 0) &#123; break; &#125; ans += dfs(S, INF); &#125; cout &lt;&lt; ans &lt;&lt; endl;//出第三问答案&#125; 套路五：最小路径覆盖问题有的题目，它给了你一张DAG，要求你用最少的路径去覆盖它上面的每一个点。 听上去有、抽象，看来出题人也是 抽象人 。 我们通过画图来解释这一问题： 这是一张普通的 DAG 。 我们每次选择一条任意长度的路径，并将路径上的所有点染色。 如下是一种方法： RT，粉、黄、蓝三条路径使得所有点被染色。这时我们使用的路径数量=3。 然而但凡有一点脑子的人都能看出，这条黄色路径是完全不需要的，我们用2条路径照样可以覆盖，如图： 而最小路径覆盖问题，就是解决“ 找到用最少路径覆盖全图的方案 ”这一问题的。 我们如何用网络流实现这一过程？这就要用到 最小路径覆盖模型 力。 先假设你是一个铁憨憨。你把每个点都用一条长度为 $1$ 的路径给覆盖了。 这时来了个 神仙 ，看到你的覆盖方案，非常 $angry$ ，把你代码给删了。 她说你怎么这么蔡，很多点明明可以合并以减少路径数。 你感到非常委屈，说凭什么。 她扔出一个定理：“一张图中，如果一个点只能用在一条路径上， 路径数=点数-点之间匹配数 。” “这个很好证明。因为当点之间没有边时，每个点都需要一条路径去覆盖他， 路径数=点数 ；一旦有一条边（x，y）时，相当于能把这两个点合在一起，用 一条路径 去覆盖他们俩，所以 路径数=点数-1 ；以此类推。” 你惊了，“那不就转化成了一道最大匹配了嘛。” 的确，但是这里依然分不出二分图来。我们需要 奇技淫巧 。 把一个点拆成入点和出点，永远是入点向对应的出点连边，就可以保证建出一张二分图来： 这是之前那张 DAG 建出来的图。 我们需要的是匹配数，所以图上所有入点和出点之间连的边，容量均为 $1$ ；超级源和超级汇连出的边，容量也均为 $1$ 。 这样跑最大流的答案就是 最大匹配数的数值 辣！ 所以这就是一道最大匹配题了。 这便是最小路径覆盖的基本算法。 不口嗨了，直接上例题：这时，我们想起了之前提到的一道在讲黑白染色时提到的 不讲武德的 题目： [国家集训队]部落战争 你以为这是一道黑白染色，只是跳的规则不固定了而已？ 那还是大意了呀。 黑白染色题（如方格取数），并没有要求每个点都要被取中。而这里需要。 我们从上往下推进，因为不能回头，所以我们的推进从最顶上一行开始，到最底下一行结束。 而这个推进的过程，要 覆盖所有的点 。 这时，便可以用到之前的最小路径覆盖模型了。 先画 DAG ，点与点之间，可达即连边。 再套最小路径覆盖即可。 （实则这两步可以合成一步做） 希望国集好自为之，不要搞窝里斗。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long/*dinic组件*/const int MAX = 5e5 + 7;const int INF = 1e18;struct edge&#123; int next, to; int val;&#125; e[MAX &lt;&lt; 1];int head[MAX], eid = 1;int cur[MAX];void adde(int x, int y, int w)&#123; e[++eid].next = head[x]; e[eid].to = y; e[eid].val = w; head[x] = eid;&#125;int dep[MAX];int flag = 0;queue&lt;int&gt; q;int S, T;#define RUN(u) for (int i = head[u]; i; i = e[i].next)void bfs()&#123; memset(dep, 0, sizeof(dep)); dep[S] = 1; while (!q.empty()) &#123; q.pop(); &#125; q.push(S); while (!q.empty()) &#123; int u = q.front(); q.pop(); RUN(u) &#123; int v = e[i].to; if (e[i].val == 0 || dep[v]) &#123; continue; &#125; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; if (dep[T]) &#123; flag = 1; &#125; memcpy(cur, head, sizeof(head));&#125;int dfs(int u, int in)&#123; if (u == T || !in) &#123; return in; &#125; int out = 0; for (int i = cur[u]; i; i = e[i].next) &#123; cur[u] = i; int v = e[i].to; if (e[i].val == 0 || dep[v] != dep[u] + 1) &#123; continue; &#125; int tmp = dfs(v, min(in, e[i].val)); e[i].val -= tmp; e[i ^ 1].val += tmp; in -= tmp; out += tmp; if (in == 0) &#123; return out; &#125; &#125; if (out == 0) &#123; dep[u] = 0; &#125; return out;&#125;int N, M, R, C;int idx(int x, int y)//在棋盘上获取结点编号&#123; return (x - 1) * M + y;&#125;int Map[57][57];signed main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; R &gt;&gt; C; S = 0, T = N * M * 2 + 1; int tot = 0; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= M; j++) &#123; char c; cin &gt;&gt; c; if (c == &#x27;.&#x27;) &#123; tot++;//tot记录需要覆盖的点的个数 &#125; Map[i][j] = (c == &#x27;.&#x27; ? 1 : 0); adde(S, idx(i, j), 1);//超级源连所有入点 adde(idx(i, j), S, 0); adde(idx(i, j) + N * M, T, 1);//超级汇连所有出点 adde(T, idx(i, j) + N * M, 0); &#125; &#125; int dis[5][2] = &#123;0, 0, R, C, R, -C, C, R, C, -R&#125;; //跳跃规则 for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= M; j++) &#123; if (Map[i][j] == 0) &#123; continue; &#125; for (int k = 1; k &lt;= 4; k++) &#123; int ii = i + dis[k][0], jj = j + dis[k][1]; if (ii &lt;= 0 || ii &gt; N || jj &lt;= 0 || jj &gt; M || Map[ii][jj] == 0) &#123; continue; &#125; adde(idx(i, j), idx(ii, jj) + N * M, INF); adde(idx(ii, jj) + N * M, idx(i, j), 0); //可达即连边 &#125; &#125; &#125; int ans = 0; while (1) &#123; flag = 0; bfs(); if (flag == 0) &#123; break; &#125; ans += dfs(S, INF); &#125; cout &lt;&lt; tot - ans &lt;&lt; endl;//最少路径数=总点数-匹配点数&#125; EX-套路五：其他有趣（？）的最小路径覆盖问题泛讲：天底下哪有裸的网络流，从来都是老阴比居多。 这一现象在“最小路径覆盖问题”上得到了充分的体现。 因为最小路径覆盖的板子局限性太高了，所以他的 变体 也就特别的多。 这就和 “因为NEKOPARA官方给时雨的戏份太少，导致时雨的本子特别多” 是一个道理。 我们挑几个范例，来剖析一下出题人的良（sang）苦（xin）用（bing）心（kuang）： 魔术球问题 你的正解不是搜索，ko no 网络流 da ！ 首先，我们制定一个总体的计划，逐个地放小球，直到放不下了为止。这时就是答案。 其次，我们想想这是怎么套上最小路径覆盖的。我们把每个球看作一个点，把两个 相加之和为完全平方数 的小球，所对应的点之间连边。 这也代表着我们以数 $a$ 为某柱子的顶端，我们就 可以 去转移到下一个与 $a$ 有连边 的数 $b$ 。 建出一张图来就像这样： 当我们把 $1$ 放在一个柱子的顶端，在他的上面，我们可以去放 $3$ ，也可以去放 $8$ 。 在图上，相当于我们在 $1$ 这个位置，可以走到 $3$ 也可以走到 $8$ 。 就这样走着走着最终会走出一条路径，这条路径上的每两个邻点之间都 有边相接 ，意味着相加为完全平方数。 这样的一条路径正好对应了一根柱子。 那做法就很显然了，一个一个加小球，连边，当加某一个小球时，跑出的最小路径覆盖条数 超过了柱子数 ，那这就是答案。 青春猪头tyy的下半身不会梦见操场的柱子 [JSOI2016]飞机调度 网络瘤少有的黑题，其实还是好打的。 是什么让我们想到这是一道 “最小路径覆盖问题” ？ 题解（闭嘴） 题目中提到“可以增开任意架飞机”，而求的是“最少使用的飞机数”，一个飞机会经过许多点……这使我们想到“最小路径覆盖”。 “最小路径覆盖”需要有 DAG ，否则就是白给。 谁设为点，是机场吗，呐？ 一个机场可能多次接收航班，多次送出航班，也就是说一个机场可能会经过多次，这违背了我们DAG的初心。 那到底什么是 一次性 的。 在这道题里，只有航班是一次性的了，将其设为点。 谁设为边，点与点之间的转移曰边，我们这里定义：同一架飞机 飞完一趟航班以后飞另一趟 ，这两趟航班之间就可以连边。 在什么条件下，一架飞机可以飞完一趟以后飞另一趟？ 在前一次飞完以后，能够在 下一趟开点 之前，赶到下一趟的 出发站 。我们就可以在这两趟航班之间连上边。 而这个判断里面，每一个需要的值都是可求的。 那么有人又要问了：可是题目并没有给出从一个机场赶到另一个机场所需的时间啊！ 既然题目给了你这么多航班信息，你就不会用 $floyed$ 传递一下闭包 吗。 至此此题就转化成一道最小路径覆盖问题力。 套路六：虚点的构建：这并不构成一种模型，但是这类型的题挺 多 的，所以单独开出来讲。 所谓虚点者，就是这并不代表某一个元素，而是代表一种 限制条件 或者 额外加成 。 比如我们说，如果有两个物品 $a$ 和 $b$ ，每个物品有两种状态 $1$ 和 $2$ ，每个状态有不同的价值。 同时，如果我们同时选了 $a1$ 和 $b1$ ，就可以额外获得值为 $c1$ 的价值；如果我们同时选了 $a2$ 和 $b2$ ，就可以额外获得值为 $c2$ 的价值。 首先我们需要创建一个虚点，代表 $c1$ 。 这时，因为我们有 “你可以选状态1，但你就选不了状态2了，这一切，值得吗” 。 所以我们应该上最小割！将所有状态 $1$ 连向源，所有状态 $2$ 连向汇！ 其次，如果我们选择不割 $a1$ 和 $b1$ ，就能 保留 $c1$ 。 所以 $c1$ 与 “ $a1$ 和 $b1$ ” 不应站在割边的对立面上。而是当 能保留a1,b1的条件满足时，一样可以保留c1 。 胡乱 思考得知， $c1$ 应该是从源出来而流向 $a1,b1$ 的。 那建出全图就是这样： 还挺好看。 手模几种情况即可验证这张图。 之后就是跑一个最小割的事。 可以看出，建立虚点的套路适用于 “集齐X个干员，组建幻神阵容，获得羁绊 buff” 的隔膜行为。 下面来康例题：[国家集训队]happiness 为甚么又是国集…… 这道题的限制条件有亿点多，但是好在数据范围极小。 本着神仙 shadowice1984 “大了三分，小网络流；不小不大，斜率优化” 的箴言。我们尝试建图跑。 对于任意两个相邻的人，他们同选某一门会有额外 $buff$ ，这说明我们要建关于 $buff$ 的虚点。 之后的事就很简单了，对于每一种 $buff$ 都建虚点，最后跑最小割即可。 图过于气 势 恢 宏，这里就不放了。 代码放一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int LAR = 10000;const int MAX = 5e5 + 7;const int INF = 1e18;/*网络流板子*/struct edge&#123; int next, to; int val;&#125; e[MAX &lt;&lt; 1];int head[MAX], eid = 1;int cur[MAX];void adde(int x, int y, int w)&#123; e[++eid].next = head[x]; e[eid].to = y; e[eid].val = w; head[x] = eid;&#125;int dep[MAX];int flag = 0;queue&lt;int&gt; q;int S, T;#define RUN(u) for (int i = head[u]; i; i = e[i].next)bool bfs()&#123; memset(dep, 0, sizeof(dep)); dep[S] = 1; while (!q.empty()) &#123; q.pop(); &#125; q.push(S); while (!q.empty()) &#123; int u = q.front(); q.pop(); RUN(u) &#123; int v = e[i].to; if (e[i].val == 0 || dep[v]) &#123; continue; &#125; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; memcpy(cur, head, sizeof(head)); return dep[T] != 0;&#125;int dfs(int u, int in)&#123; if (u == T || !in) &#123; return in; &#125; int out = 0; for (int i = cur[u]; i; i = e[i].next) &#123; cur[u] = i; int v = e[i].to; if (dep[v] != dep[u] + 1) &#123; continue; &#125; int tmp = dfs(v, min(in, e[i].val)); if (!tmp) &#123; continue; &#125; e[i].val -= tmp; e[i ^ 1].val += tmp; in -= tmp; out += tmp; if (in == 0) &#123; return out; &#125; &#125; if (out == 0) &#123; dep[u] = 0; &#125; return out;&#125;/*几个数组分别对应该位置选文、选理、相邻都选文、相邻都选理*/int A[107][107];int B[107][107];int C[107][107];int D[107][107];int N, M;int idx(int x, int y)//取标号&#123; return (x - 1) * M + y;&#125;signed main()&#123; cin &gt;&gt; N &gt;&gt; M; int sum = 0; S = 0, T = 5 * N * M + 1; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= M; j++) &#123; cin &gt;&gt; A[i][j]; sum += A[i][j]; adde(S, idx(i, j), A[i][j]); adde(idx(i, j), S, 0);//文连源 &#125; &#125; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= M; j++) &#123; cin &gt;&gt; B[i][j]; sum += B[i][j]; adde(idx(i, j), T, B[i][j]); adde(T, idx(i, j), 0);//理连汇 &#125; &#125; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= M; j++) &#123; cin &gt;&gt; C[i][j]; sum += C[i][j]; int u = 2 * N * M + idx(i, j);//虚点标号 adde(S, u, C[i][j]);//价值 adde(u, S, 0); adde(u, idx(i, j), INF);//当然他自己也要选文 adde(idx(i, j), u, 0); /*虚点连向四个方向的点*/ if (j - 1 &gt; 0) &#123; adde(u, idx(i, j - 1), INF); adde(idx(i, j - 1), u, 0); &#125; if (j + 1 &lt;= M) &#123; adde(u, idx(i, j + 1), INF); adde(idx(i, j + 1), u, 0); &#125; if (i - 1 &gt; 0) &#123; adde(u, idx(i - 1, j), INF); adde(idx(i - 1, j), u, 0); &#125; if (i + 1 &lt;= N) &#123; adde(u, idx(i + 1, j), INF); adde(idx(i + 1, j), u, 0); &#125; &#125; &#125; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= M; j++) &#123; cin &gt;&gt; D[i][j]; sum += D[i][j]; int u = 4 * N * M + idx(i, j);//虚点标号 adde(u, T, D[i][j]);//价值 adde(T, u, 0); adde(idx(i, j), u, INF);//当然他自己也要选理 adde(u, idx(i, j), 0); /*向四个方向连边*/ if (j - 1 &gt; 0) &#123; adde(idx(i, j - 1), u, INF); adde(u, idx(i, j - 1), 0); &#125; if (j + 1 &lt;= M) &#123; adde(idx(i, j + 1), u, INF); adde(u, idx(i, j + 1), 0); &#125; if (i - 1 &gt; 0) &#123; adde(idx(i - 1, j), u, INF); adde(u, idx(i - 1, j), 0); &#125; if (i + 1 &lt;= N) &#123; adde(idx(i + 1, j), u, INF); adde(u, idx(i + 1, j), 0); &#125; &#125; &#125; int ans = 0; while (bfs()) &#123; ans += dfs(S, INF); &#125; cout &lt;&lt; sum - ans &lt;&lt; endl;//总价值-最小割&#125;套路七：二分与枚举：有的题目，他条件一点都不 给 ，或者他 给 得不够多。 如果我们用传统的套路，我们会寸步难行。 这时，我们如果尝试用 枚举/二分 的做法，相当于自己凭空创造了一个条件，这样我们就可以完成一些 板子的套用 模型的构造。 我们可以根据这个条件来建图跑，如果跑出的答案不满足要求，则 调整图的形态 再跑。 我们有时只需要改动一些边的参数，但像我这种蒟蒻只会大力重新建图。（这就是我常数特别大的原因之一） _有关更优秀地改动边，这里埋下一个伏笔。_ 您是否还记得之前的一道《魔术球问题》，那题中，我们不断放新球的过程，实际上就属于套路七中的 枚举 环节。 这一套路思想就这，重在运用。 劲爆例题[POI2005]KOS-Dicing 这题说要让“最多的最少”，想到了二分。 赢最多的人赢多少场，这是有边界的。 我们就可以随手二分赢最多的人的胜场。 那图呢？ 我们看到，一场比赛只能有一个 人赢 。（雾） 所以表示比赛的点向参与的两者各连 流量为 1 的边。源点向所有比赛连 流量为 1 的边。 而我们二分到一个人最多赢 $mid$ 场。也就是一个人连向汇点最大为 $mid$ 。 跑出最大流如果 $\\geq$ 比赛数，说明是 可行的 。尝试用更小的 $mid$ 。 最终会二分出一个答案。 输出方案就看比赛连向谁的那条边是满流即可，谁是满流谁是人赢. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAX = 5e5 + 7;const int INF = 1e18;/*dinic组件*/struct edge&#123; int next, to; int val;&#125; e[MAX &lt;&lt; 1];int head[MAX], eid = 1;int cur[MAX];void adde(int x, int y, int w)&#123; e[++eid].next = head[x]; e[eid].to = y; e[eid].val = w; head[x] = eid;&#125;int dep[MAX];int flag = 0;queue&lt;int&gt; q;int S, T;#define RUN(u) for (int i = head[u]; i; i = e[i].next)bool bfs()&#123; memset(dep, 0, sizeof(dep)); dep[S] = 1; while (!q.empty()) &#123; q.pop(); &#125; q.push(S); while (!q.empty()) &#123; int u = q.front(); q.pop(); RUN(u) &#123; int v = e[i].to; if (e[i].val == 0 || dep[v]) &#123; continue; &#125; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; memcpy(cur, head, sizeof(head)); return dep[T] != 0;&#125;int dfs(int u, int in)&#123; if (u == T || !in) &#123; return in; &#125; int out = 0; for (int i = cur[u]; i; i = e[i].next) &#123; cur[u] = i; int v = e[i].to; if (dep[v] != dep[u] + 1) &#123; continue; &#125; int tmp = dfs(v, min(in, e[i].val)); if (!tmp) &#123; continue; &#125; e[i].val -= tmp; e[i ^ 1].val += tmp; in -= tmp; out += tmp; if (in == 0) &#123; return out; &#125; &#125; if (out == 0) &#123; dep[u] = 0; &#125; return out;&#125;int N, M;int a[MAX], b[MAX];int akioi[MAX], tot = 0;//akioi 数组记录（表示 “这场比赛流向参赛者” 的边）的编号/*二分函数*/bool judge(int x)&#123; memset(head, 0, sizeof(head));//暴力清空 eid = 1; S = 0, T = 20000 + N + 1; /*建边*/ for (int i = 1; i &lt;= M; i++) &#123; adde(S, i, 1); adde(i, S, 0);//源连向比赛 adde(i, a[i] + 20000, 1); akioi[i] = eid; //记录下这条边的编号，以后输出方案要用 adde(a[i] + 20000, i, 0); adde(i, b[i] + 20000, 1); adde(b[i] + 20000, i, 0);//比赛连向参赛者 &#125; for (int i = 1; i &lt;= N; i++) &#123; adde(i + 20000, T, x); adde(T, i + 20000, 0);//参赛者连向汇 &#125; int ans = 0; while (bfs()) &#123; ans += dfs(S, INF); &#125; if (ans &gt;= M) &#123; return 1; &#125; return 0;&#125;signed main()&#123; cin &gt;&gt; N &gt;&gt; M; for (int i = 1; i &lt;= M; i++) &#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; &#125; /*二分*/ int l = M / N, r = M, ans = M; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (judge(mid)) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; cout &lt;&lt; l &lt;&lt; endl; //以这个数为答案再跑一遍，生成方案 judge(l); for (int i = 1; i &lt;= M; i++) &#123; if (e[6 * (i - 1) + 4].val == 0)//查询其是否满流 //（若流向一个人的边的容量变成了0，则它满流） &#123; cout &lt;&lt; 1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125; &#125;&#125;套路INF：其他不常见技巧 拓扑去环： 试想如果我们建出来的图中有环，跑网络流会得到什么结果。 可能是 $RE$ ，可能是 $TLE$ ，可能是 $WA$ ，总之跑不出正确答案。 有的题目中，环是可以被直接忽略的。这时我们就可以先跑 拓扑排序 ，把环找出来，在之后建模时直接忽略即可。 比如下面这道题： [NOI2009]植物大战僵尸 首先，这题基础建模思路就很难想到。（毒瘤题实锤） 对题目中的题意一通抽丝剥茧，我们发现，一个植物要能被吃，需要满足这两个前置条件。（看图） 它右边的都被吃完了（参考这里的大嘴花在坚果墙左边导致不能被吃）。 能攻击到这一位置的植物都被吃完了 （参考这里的坚果墙的位置被大嘴花攻击导致不能被吃 停，你刚刚说了 “前置” 是吧。 然后 最大权闭合子图 的模型不就呼之欲出了？ 植物 $i$ 的价值设为 $val_i$ ，正权连源，表示收益，负权连汇，表示花费。 如果一个植物 $j$ 保护着 $i$ ， $i$ 向 $j$ 连边 （这里包含了 j 在 i 右侧 和 j 攻击到 i 的位置 两种情况） 答案就是跑出的总的最大收益。 然后，我们会发现一个残酷的事实，如果你是僵尸，大嘴花和坚果墙你一个都吃不到。（惨） 他们互相保护，在我们建出的图上就形成了一个环。如果我们直接跑会爆炸。 这时我们就需要 拓扑去环 了。 在建网络流模型之前，我们需要反向建一张图，能被遍历到的结点证明它不在环上，我们用这种点再来建我们用来跑网络流的图。 之后跑最大权闭合子图即可。 退流： _伏笔消除_ 如果我们要在一张跑完网络流的图上，稍作删边，再跑下一次网络流的话，我们可能要暴力重建。 但是其实这并不需要这么高的复杂度， 退流 就是一种高效解决删边重跑的方法。 笔者突然对自己的认知产生了迷惑，先咕。 那网络流部分就告一段落辣。 杜教筛sto $\\color{black}{\\texttt{M}\\color{red}{\\texttt{iFaFaOvO}}}$ orz 杜教筛是一种高端筛法，用以快速处理积性函数的前缀和。 以前 $\\color{purple}{\\texttt{给}}$ 指导讲过这一高端科技，但是那时候的我连数论分块都没搞清楚，更别说杜教筛了。 昨天入的坑，今天来整理一下 $QvQ$ 。 原理？假设我们要来筛一个函数 $f$ 。 我们设另一个积性函数 $g$ ，然后把他们俩 卷 起来，得到一个 $h$ 。 也就是 $f*g=h$ 。 再设一个 $sumf$ 表示 $g$ 的前缀和。 以上是杜教筛的一些弹药。 关于 $h$ 的前缀和，展开做钬钊氪镭 卷 积的形式有： \\sum^{n}_{i}h(i)=\\sum^{n}_{i}\\sum_{d|n} g(d)f(\\frac{n}{d})\\Leftrightarrow \\sum^{n}_{i}h(i)={\\color{red}{ \\sum_{d}^{n}} } g(d)\\sum^{\\color{red}{\\lfloor\\frac{n}{d}\\rfloor}}_{i} f(i)\\quad\\texttt{提出并枚举d}\\Leftrightarrow \\sum^{n}_{i}h(i)={\\color{red}{ \\sum_{d}^{n}} } g(d){\\color{royalblue}{sumf(\\lfloor\\frac{n}{d}\\rfloor)}}\\quad\\texttt{将后半部分预处理}\\Leftrightarrow \\sum^{n}_{i}h(i)={\\color{green}{sumf(n)\\cdot g(1)}}+{ \\sum_{d\\color{green}{=2}}^{n} } g(d){\\color{royalblue}{sumf(\\lfloor\\frac{n}{d}\\rfloor)}}\\quad\\texttt{提出d=1}\\Leftrightarrow {\\color{green}{sumf(n)\\cdot g(1)}}={ \\sum^{n}_{i}h(i)-\\sum_{d\\color{green}{=2}}^{n} } g(d){\\color{royalblue}{sumf(\\lfloor\\frac{n}{d}\\rfloor)}}\\quad\\texttt{一通移项}当前的这个式子启发我们，当我们易求 $h$ 的前缀和时，只需获得一个 $sumf(\\lfloor\\frac{n}{d}\\rfloor)$ ，就能光速整除分块推知 $sumf(n)$ 。 数论函数的选择随缘乱凑（不是） 回归算法本身，我们需要的 $g$ ，要求是和 $f$ 卷 起来以后得到一个易求前缀和的 $h$ 。 所以我们需要通晓一些互 卷 关系： $\\mu*1=\\epsilon\\quad$这个很simple吧，$\\mu$ 的一条性质 $\\varphi*1=id\\quad$ 这个看上去也很simple，$\\texttt{\\color{black}{R}\\color{red}{ui_R}}$神写过一篇文章证过。 $\\muid=\\varphi\\quad$ 上一条柿子佐佑同 *卷 $\\mu$ 即可 $f(i)=\\sum_{i}^{n}(i\\cdot\\varphi(i)),fid=n^2\\quad$ 卷 积拆开来发现会把$f$ 里的 $i$ 消掉得 $\\sum_{d|n}n\\cdot\\varphi(d)$，然后套 $\\varphi1=id$ $f(i)=\\sum^n_i(i^k\\cdot\\varphi(i)),f*id=n^{k+1}\\quad$ 上一个柿子的一个推论 劲爆例题 【模板】杜教筛（Sum） 首当其 冲 的必然是模板。 题目要求 $\\mu$ 和 $\\varphi$ 的前缀和，我们分别来思♂尻一番。 思♂尻用什么东西来 卷 $\\mu$ ，要求和 $\\mu$ 卷 完以后要得到一个 易于计算前缀和 的氡氡。 通过 翻博客 慎重考虑后，我们选择用 $1$ 去 卷 它，因为 $\\mu*1=\\epsilon$ ，而 $\\epsilon$ 的前缀和必然是 1。 所以瑇入 $g=1,h=\\epsilon$ 我们有： {sum\\mu(n)\\cdot 1}={ \\sum^{n}_{i}\\epsilon(i)-\\sum_{d=2}^{n} } sum\\mu(\\lfloor\\frac{n}{d}\\rfloor)这样我们就解决了 $\\mu$ 。 那 $\\varphi$ 呐？ 其实也很套路，因为 $\\varphi*1=id$ ，而 $id$ 的前缀和，高斯哥哥已经帮我们推出公式了，是 $n\\cdot(n+1)\\div2$ 。 所以瑇入 $g=1,h=id$ 我们有： {sum\\varphi(n)\\cdot 1}={ \\sum^{n}_{i}i-\\sum_{d=2}^{n} } sum\\varphi(\\lfloor\\frac{n}{d}\\rfloor)下面是瑇码，具体实现细节在注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 6e6 + 7;vector&lt;int&gt; v;//质数表（STL严重瘾君子）int mu[MAX];long long phi[MAX];bool flag[MAX];int summ[MAX];//mu前缀和long long sump[MAX];//phi前缀和void pre()//先线性预处理一部分的 phi 和 mu&#123; mu[1] = 1; phi[1] = 1; for (int i = 2; i &lt;= 6e6; i++) &#123; if (!flag[i]) &#123; phi[i] = i - 1; mu[i] = -1; v.push_back(i); &#125; int M = v.size(); for (int j = 0; j &lt; M &amp;&amp; i * v[j] &lt;= 6e6; j++) &#123; flag[i * v[j]] = 1; if (i % v[j] == 0) &#123; phi[i * v[j]] = 1LL * phi[i] * v[j]; break; &#125; mu[i * v[j]] = -mu[i]; phi[i * v[j]] = 1LL * phi[i] * phi[v[j]]; &#125; &#125; for (int i = 1; i &lt;= 6e6; i++) &#123; summ[i] = summ[i - 1] + mu[i]; sump[i] = sump[i - 1] + 1LL * phi[i];//求出一部分前缀和 &#125;&#125;unordered_map&lt;int, int&gt; m1;unordered_map&lt;long long, long long&gt; m2;//这两个map用来保存一些已经求好的前缀和（类似记忆化）int DJSmu(int x)&#123; if (x &lt;= 6e6) &#123; return summ[x];//小于6e6的预处理过了 &#125; if (m1[x]) &#123; return m1[x];//已经求过的可以记忆化 &#125; int ans = 1;//epsilon前缀和 for (long long i = 2/*从2开始*/, j; i &gt;= 0 &amp;&amp; i &lt;= x; i = j + 1) &#123; j = x / (x / i); ans -= (j - i + 1) * DJSmu(x / i);//每次数论分块，减去mu的前缀和，而这个前缀和可以递归搞一搞 &#125; return m1[x] = ans;//记忆化&#125;long long DJSphi(long long x)&#123; if (x &lt;= 6e6) &#123; return sump[x]; &#125; if (m2[x]) &#123; return m2[x]; &#125; long long ans = (x) * (x + 1) / 2;//id前缀和 for (long long i = 2, j; i &lt;= x; i = j + 1) &#123; j = x / (x / i); ans -= (j - i + 1) * DJSphi(x / i);//减去phi前缀和 &#125; return m2[x] = ans;&#125;int main()&#123; int T; cin &gt;&gt; T; pre(); int x; while (T--) &#123; cin &gt;&gt; x; cout &lt;&lt; DJSphi(x) &lt;&lt; &#x27; &#x27; &lt;&lt; DJSmu(x) &lt;&lt; &#x27;\\n&#x27;; &#125;&#125; _PS：小心爆精（不然就像我一样的下场）_ *象棋与马 题面要素溢出。 不难发现，如果一种跳跃规则是可达所有点的，那么它唯一的要求就是有能力达到 相邻格，如 $(0,0)$ 达到 $(0,1)$ 。 我们意识到，这一步骤其实相当于能否从 $(0,0)$ ，向各个方向瞎jb跳一跳，最后达到 $(0,1)$ 。 设我们一步能跳 $(x,y)$ ，那么 本质不同 （唐突本质不同）的行走方案有四种： (x,y) (y,x) (-x,y) (−y,x)（在纵轴上走负方向其实可以看作走负数次正方向） 那么我们有： \\begin{cases}ax+by-cx-dy=0\\\\ay+bx+cy+dx=1\\end{cases}也就是说我们瞎跳过程中，有 $a$ 次 $(x,y)$ 的跳跃， $b$ 次 $(y,x)$ 的跳跃， $c,d$ 同理。 开始 $\\mathbf{dark}$ 力合并两个柿子，提出 $x,y$ 来。 x(a+b-c+d)+y(a+b+c-d)=1设 $a+b=A,c-d=B$ ，转化式子 x(A-B)+y(A+B)=1格物致知这个柿子，我们意识到 $x,y$ 一定得 互质 （一旦二者有非1的公约数，则结果必然 也有 这个公约数）。 此外，二者必须 奇偶性互异 ，否则结果 必然为偶 。 因此，二者必然一奇一偶。 设此时答案是 $f(x)$ ，先记着，因为我们限定了 $x$ 的奇偶性，相当于砍掉了一半的答案，所以最后答案 $ans(x)=2\\cdot f(x)$。 抓～紧～时～间～容～斥～ f(x)=\\sum^{x}_{i}\\sum^{y}_{j}[i\\perp j,i j \\texttt{奇偶性互异}]=\\sum^{x}_{i}\\sum^{i}_{j}[i\\perp j,i\\texttt{为偶}\\texttt{（因为两者互质所以j为偶甚至不用写）}]+{\\sum^{x}_{i}\\sum^{i}_{j}[i\\perp j,i\\texttt{为奇},j \\texttt{为偶}]}他欧拉反 演 起来了： f(x)=\\sum^{x}_{i}\\varphi(i)[i\\texttt{为偶}]+\\sum^{x}_{i}\\frac{\\varphi(i)}{2}[i\\texttt{为奇}]ans(x)=\\sum^{x}_{i}2\\varphi(i)[i\\texttt{为偶}]+\\varphi(i)[i\\texttt{为奇}]因此，我们收获了一个看上去很彳亍的式子，但这还不够，$x\\leq10^{11}$。 提出一个 $\\varphi(i)$ 来： ans(x)=\\sum^{x}_{i}\\varphi(i)[i\\texttt{为偶}]+\\varphi(i)=\\sum^{x}_{i}\\varphi(i)[i\\texttt{为偶}]+\\sum^{x}_{i}\\varphi(i)=ans(\\frac{x}{2})+\\sum^{x}_{i}\\varphi(i)后半段可以 杜教筛 ，前半段 递归求解 即可。 按 $\\color{purple}{\\texttt{给指导}}$ 的话说，这种“自递归函数”是未来数论出题的热点。 （这并不影响数论毒瘤爪巴） 瑇码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#define ull unsigned long long#define ll long longconst int MAX = 2e7 + 7;ll phi[MAX];ll sum[MAX];bool flag[MAX];vector&lt;ll&gt; v;void pre()&#123; phi[1] = 1; for (ll i = 2; i &lt;= 2e7; i++) &#123; if (flag[i] == 0) &#123; phi[i] = i - 1; v.push_back(i); &#125; ll M = v.size(); for (ll j = 0; j &lt; M &amp;&amp; v[j] * i &lt;= 2e7; j++) &#123; flag[i * v[j]] = 1; if (i % v[j] == 0) &#123; phi[i * v[j]] = phi[i] * v[j]; break; &#125; phi[i * v[j]] = phi[i] * phi[v[j]]; &#125; &#125; for (ll i = 1; i &lt;= 2e7; i++) &#123; sum[i] = (sum[i - 1] + phi[i]); &#125;&#125;unordered_map&lt;ll, ull&gt; m;ull DJS(ll x)&#123; if (x &lt;= 2e7) &#123; return sum[x]; &#125; if (m.count(x)) &#123; return m[x]; &#125; ull ans = (__int128)(x &amp; 1LL ? ((x + 1) / 2LL * x) : (x / 2LL * (x + 1))); for (ll i = 2, j; i &lt;= x; i = j + 1) &#123; j = x / (x / i); ans -= 1LL * (DJS(x / i) * (1LL * j - 1LL * i + 1LL * 1)); &#125; return m[x] = ans;&#125;ull solve(ll x)&#123; if (x &lt;= 1) &#123; return 0; &#125; return solve(x / 2) + DJS(x);&#125;signed main()&#123; int T; cin &gt;&gt; T; pre(); while (T--) &#123; ull a; cin &gt;&gt; a; cout &lt;&lt; solve(a) &lt;&lt; endl; &#125;&#125; 咕咕咕！","categories":[],"tags":[{"name":"“知识”决定命运","slug":"“知识”决定命运","permalink":"https://quest233.github.io/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/"}]},{"title":"晾衣架学习笔记","slug":"晾衣架学习笔记","date":"2021-04-17T07:05:41.000Z","updated":"2021-04-17T08:14:16.357Z","comments":true,"path":"2021/04/17/晾衣架学习笔记/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E6%99%BE%E8%A1%A3%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"这个东西不和那些紫题算法放在一起，因为生成函数好多都是黑题。 这篇文章的风格大概是 『题目+ 口胡 解法+启发』 ，在阅读这些乱七八糟的东西之前，可能需要一点点的 $door$ 项式基础（大概学到 $\\exp$ 就够了？）。 伟大的 $\\mathbf{Pólya}$ 生前曾经说过： 『生成函数就像装东西的袋子，我们如果拿着一个个东西会很尴尬，（有了生成函数）我们就只需要拿一个东西——袋子』 生成函数如同晾衣架，他把一个个数晾在系数上，我们需要的不是晾衣架本身，而是晾着的衣服们。 那么我们可以随便开一道题来爽一爽。 [集训队作业2013]城市规划x义x 神仙名著《生成函数再入门》的第一题。 题目大E是有标号无向连通图计数。 我们开两个数组 $f[n]$ 表示 $n$ 个点的有标号无向 联通 图的个数， $g[n]$ 表示 $n$ 个点的有标号无向 不管联不联通 图。 很显然， $f[n]$ 就是我们想要的答案。 而 $g[n]$ 是很好求的，考虑任意两点间的边 连或不连 即可，有 $g[n]=2^{\\binom{n}{2}}$ 。 $f$ 和 $g$ 之间有什么微妙关系呢？ 接下来的操作有两条路可走，但它们是殊途同归的，建议两个都看一看。 暴推式子出口方向：一个 $n$ 个点的 不管联不联通 图一定是 【$1$ 号点所在的大小为 $k$ 个点的 联通 图】和【剩余 $n-k$ 个点的 不管联不联通 图】合起来得到的。 我们称 $1$ 号点所在的大小为 $k$ 个点的 联通 图为 【 $1$ 号联通图 】。 而那些在【 $1$ 号联通图】里的（除 $1$ 号点外）其它 $k-1$ 个点则也需在所有 $n-1$ 个点中进行一番选择，需要多乘一个 $\\tbinom{n-1}{k-1}$。 也就是： g[n]=\\sum_{k=0}^{n} \\tbinom{n-1}{k-1}\\cdot f[k]\\cdot g[n-k]组合数暴拆之： \\frac{g[n]}{(n-1)!}=\\sum_{k=0}^n \\frac{f[k]}{(k-1)!}\\cdot \\frac{g[n-k]}{(n-k)!}活得像个 $\\text{EGF}$ 。设： H=\\sum_{i=1}^{n}\\frac{g[i]}{(i-1)!}x^iF=\\sum_{i=0}^{n}\\frac{f[i]}{(i-1)!}x^iG=\\sum_{i=0}^{n}\\frac{g[i]}{i!}x^i结合上式，有 $H=F G$ ，即 $F=H G^{-1}$ ，那么只要会求逆即可。 $\\exp$ 组合意义出口方向：很显然，一个 不管联不联通 图是由若干个 联通图 组成的，也就是把 $n$ 个点划分到几个集合中，每个集合是一个 联通图 。 那么就是【集合划分计数】了，这是 $\\exp$ 的组合意义。 即可科技。 设 $F$ 是 $f[i]$ 的 $\\text{EGF}$ ，$G$ 是 $g[i]$ 的 $\\text{EGF}$ ，也就有！ G=e^FF=\\ln G那么只要会多项式劳茵即可。 先辈在召唤： 数东西普遍可以开两个数组，一个数组和答案 直接相关 ，一个数组 极为易求 ，两数组之间又有可行的 转移 即可。 拆组合数 可以把卷积中看上去很烦的系数溶进 $\\text{EGF}$ 里 $\\text{exp}$ 的组合意义是把 有标号 小球划分到几个箱子里，不能空箱 The Child and Binary Treex义x 神仙名著《生成函数再入门》的第二题。 这道题的通过人数就比上一题明显少了，或许是上一题露出了数数深渊的冰山一角。 大E是给定可选权值的集合，求构造一棵 点有点权 ， 权值和为 $S$ 的二叉树的方案数。 首先，思尻一下，若可选的权值不限，求 $K$ 个元素总权值为 $S$ 的方案数，怎么搞？ 这是母函数板子。参考配硬币。 我们设 $f[i]$ 表示权值和为 $i$ 的方案数，有： f[S]=\\sum_{i=0}^S f[i]* f[S-i]加了可选的权值限制呢？ 多加了一个 $g[i]$ ，表示权值 $i$ 是否（1/0）可选。 那么有： f[S]=\\sum_{i=1}^{S}g[i]\\sum_{j=0}^{S-i}f[j]* f[S-i-j]即先查 $S-i$ 这个权值是否合法，再配硬币配出 $S-i$ 。 那么把这个问题上树呢？ 事实是式子也是一样的，考虑配金币的过程。$f[j]* f[S-i-j]$ 其实就是在尝试“一棵子树权值和为 $j$ ，另一棵子树权值和为 $S-i-j$ ”的造树方法。 那么随手改写成卷积： F=G* F^2+1_（因为$G[0]=0$ ，导致常数项 $(G*F)[0]=1$ 在 $G$ 和 $F$ 的卷积中丢掉了，所以补一个 $1$）_ 在这里有的题解是直接一元二次求根公式的，但您应该注意，$G[0]=0$ ，也就是说 $G$ 是不可求逆的。以下应该才是正确的推倒方式。 先小力配方： G^2F^2-GF+G=0(GF+\\frac{1}{2})^2=\\frac{1}{4}-G再小力分讨： 当 $GF+\\dfrac{1}{2}=\\sqrt{\\dfrac{1}{4}-G}$ GF=\\frac{\\sqrt{1-4G}+1}{2}注意到这个右式的零次项是 $\\dfrac{\\sqrt{1-0}+1}{2}=1$ ，然而 $GF$ 一卷零次项应该是 $0$ ，所以舍正。 当 $GF+\\dfrac{1}{2}=-\\sqrt{\\dfrac{1}{4}-G}$ GF=\\frac{-\\sqrt{1-4G}+1}{2}这个右式的零次项是 $\\dfrac{-\\sqrt{1-0}+1}{2}=0$ ，符合条件，故取负。 最后小力化式子： F=\\frac{-\\sqrt{1-4G}+1}{2G}F=\\frac{2}{1+\\sqrt{1+4G}}只要会零次项为 $1$ 的多项式开方和多项式求逆即可。 先辈在召唤： 当我们有某个权值是否可选的限制时，可以开一个装 $0/1$ ，表示权值 是否可用 的 $G$ 数组去和正经的 $F$ 卷一卷。 一个多项式 $F$ 可以求逆的前提是 $F[0]\\neq0$ ，可以开方的前提是 $F[0]\\geq 0$ （有时 $F[0]=0$ 时不可开方，那是特例）。 注意观察零次项，零次项有时需要在推式子过程中 补全 ，常数项的存在有无有时可以帮助我们 舍掉一些情况 。 [国家集训队]整数的lqp拆分x义x 神仙名著《生成函数再入门》的第三题。 事实上笔者学数数的最初一段时间就是对着x义x神仙的文章摸♂索与练♂习的，这里表示感谢与膜拜。 大E是正整数拆分，拆分出的数装在 $a$ 里，定义一个方案的贡献是 $\\prod fib[a[i]]$ ，求总贡献。 设 $f[i]$ 表示和为 $i$ 的拆分的总贡献，显然我们的答案是 $f[n]$ 。 有一个极其一眼的递推式： f[0]=1f[k]=\\sum_{i=1}^{k}f[k-i] * fib[i]即，假设目前是第一次拆分，枚举这次将被拆分出的数，把 剩余部分 的总贡献乘以 拆分出这个数时 所得的贡献 其实就是把配硬币的新方案贡献换成了 $fib[k-i]$ 。 随手写成卷积，设 $F$ 是 $f$ 的 $\\text{OGF}$ ，$G$ 是 $fib$ 的 $\\text{OGF}$ 。 有： F=F* G+1F=\\dfrac{1}{1-G}（依然需要 $0$ 次项补全） 如果您有初中水平，那么您应该知道 $G(x)=\\dfrac{1}{1-x-x^2}$ ，下面是推倒： \\begin{aligned}G=fib[0]+fib[1]x+&fib[2]x^2+fib[3]x^3\\cdots\\\\xG=\\qquad\\quad\\;\\ fib[0]x+&fib[1]x^2+fib[2]x^3+fib[3]x^4\\cdots\\\\x^2G=\\qquad\\quad\\;\\;\\qquad\\quad\\;\\;&fib[0]x^2+fib[1]x^3+fib[2]x^4+fib[3]x^5\\cdots\\end{aligned}把一个多项式乘 $x$ 相当于是把其系数 向右平移 的过程。 我们发现如果把 同次项对齐，我们惊奇地发现在非零次项上，都有 $G[i]-(xG)[i]-(x^2G)[i]=0$ ；而在零次项上 $G[0]-(xG)[0]-(x^2G)[0]=1$ 。 也就是说 $G-xG-x^2G=1$ ，那么 $G(x)=\\dfrac{1}{1-x-x^2}$ ！ $\\Box$ 回到我们卷出来的式子： F=\\dfrac{1}{1-G}也就有了： F(x)=\\dfrac{1}{1-\\dfrac{1}{1-x-x^2}}一通操作化得： F(x)=1+\\dfrac{x}{-x^2-2x+1}我们说过，生成函数是晾衣架，我们要的是 $x$ 的系数，从这个分式里显然看不出，我们得把它化成 $\\text{OGF}$。 想到 $\\dfrac{1}{1-cx}=\\sum_{i=0}^{\\infty} c^ix^i$ ，我们尝试把右边那个鬼化成 $\\dfrac{x}{(1-ax)(1-bx)}$ 这种形式。 实数域上因式分解分母有，注意到两因式差为 $2\\sqrt{2}$ ，裂项即可： \\begin{aligned}\\dfrac{x}{-x^2-2x+1}&=\\dfrac{x}{[1-(1+\\sqrt{2})x][1-(1-\\sqrt{2})x]}\\\\&=\\dfrac{\\sqrt{2}}{4}(\\dfrac{1}{1-(1+\\sqrt{2})x}-\\dfrac{1}{1-(1-\\sqrt{2})x})\\end{aligned}非常惭愧，只做了一些微小的工作。 这样我们就有 $\\text{OGF}$ 的曙光了。 时刻牢记 $F(x)$ 代表的是关于 $x$ 的多项式，而 $F[x]$ 代表的是多项式第 $x$ 项的系数。 F(x)=1+\\dfrac{\\sqrt{2}}{4}(\\dfrac{1}{1-(1+\\sqrt{2})x}-\\dfrac{1}{1-(1-\\sqrt{2})x})F[k]=1+\\dfrac{\\sqrt{2}}{4}((1+\\sqrt{2})^k-(1-\\sqrt{2})^k)因为常数项 $1$ 是为了使 $f[0]=1$ ，之后就不再管了。 f[k]=\\dfrac{\\sqrt{2}}{4}((1+\\sqrt{2})^k-(1-\\sqrt{2})^k)\\qquad (k>0)枚举可得 $\\sqrt{2}$ 在膜 998 意义下为 $59713600$ ，爆算即可，不需要多项式科技。 先辈在召唤： 斐波那契数列的生成函数是 $\\dfrac{1}{1-x-x^2}$ ，可以采取 平移+对齐同次项观察系数 的方式得出（这种方法可以沿用到其它数列的推导） 时刻分清 晾衣架（生成函数本体）和晾着的衣服（系数） 之间的差异，必要时在草稿上用不同变量名。 面对要用 “大”分式生成函数 想求它的系数时，可以拆成若干个 $\\dfrac{1}{1-cx}$ 相加减，然后改写为 $c^i$ 即得系数的通项公式。 差分与前缀和大E是求一个数列的 $k$ 阶差分或前缀和。 水平不够，没什么时间写了","categories":[],"tags":[{"name":"“知识”决定命运","slug":"“知识”决定命运","permalink":"https://quest233.github.io/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/"}]},{"title":"才高一，就已经获得图灵奖，他是怎么做到的","slug":"才高一，就已经获得图灵奖，他是怎么做到的","date":"2021-04-17T07:01:05.000Z","updated":"2021-04-18T11:44:59.735Z","comments":true,"path":"2021/04/17/才高一，就已经获得图灵奖，他是怎么做到的/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E6%89%8D%E9%AB%98%E4%B8%80%EF%BC%8C%E5%B0%B1%E5%B7%B2%E7%BB%8F%E8%8E%B7%E5%BE%97%E5%9B%BE%E7%81%B5%E5%A5%96%EF%BC%8C%E4%BB%96%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E7%9A%84/","excerpt":"","text":"$s\\color{red}{henmadongdong}$ ，原名 【提升信赖值以查看该内容】，现在就读于HZXJHS。他以发明的“曙光筛”获得了2021年度图灵奖，是老师同学们的骄傲。 曙光筛，是一种高效的数据处理筛法，他以损失 $91\\%$ 的正确性为代价，换取了 $10$ 倍的运行效率，是数据处理领域的重大革新，宣告了第四次工业革命达到高潮。 (摘自 smdd 的实验记录) 著名计算机领域学者 WZL 说：“曙光筛是计算机迈入全新时代的标志，smdd 作为人类文明的缔造者与成就者，应该受到全人类的膜拜。” (摘自 smdd 对 WZL 的回复) 记者来到 smdd 的工作室进行采访时， smdd 正在食用被称作薯片的物质，当记者问到 smdd 为什么会有这么大的成就时，smdd 只是轻描淡写地说： smdd 的挚友匿名11872号提到 smdd ，不由得会心一笑：”smdd 是我们的红太阳，凡是 smdd 说的，我们都矢志不渝地坚持。” 近期，smdd 的新成果“曙光大力筛”正在投入试验，估计不久后，我们又能看见他新的成果。据 smdd 的回应，目前进度喜人： 据悉，美、俄等大国也曾尝试过这一领域进行过钻研，但最后只有 smdd 坚持了下来，并以极快的速度完成了三期实验。 （摘自 smdd 在颁奖典礼上的发言） 与此同时，smdd 同学在军事等领域也颇有建树。","categories":[],"tags":[{"name":"water","slug":"water","permalink":"https://quest233.github.io/tags/water/"}]},{"title":"NOIP 过往真题泛做","slug":"NOIP-过往真题泛做","date":"2021-04-17T06:59:22.000Z","updated":"2021-04-17T08:07:46.706Z","comments":true,"path":"2021/04/17/NOIP-过往真题泛做/","link":"","permalink":"https://quest233.github.io/2021/04/17/NOIP-%E8%BF%87%E5%BE%80%E7%9C%9F%E9%A2%98%E6%B3%9B%E5%81%9A/","excerpt":"","text":"$\\color{orange}{\\texttt{佛脚佛脚佛脚佛脚佛脚佛脚佛脚佛脚佛脚佛脚佛脚佛脚佛脚佛脚。}}$ 因为曾经AFO多年，导致 S组补题计划咕了两年整。 这并不很有趣嘛。 _注：以下只收录难度绿—紫的真题_ _UPD：如你所见，那道黑题它A了。_ 这篇文章主要采用叙述式风格，这会显得极其枯燥，所以看不下去的读者可以看看图找点乐子。 声明：本文中所有引用皆为断章取义，请勿无有端联想！ $2451545 (Julian)$ 前（fixed again） 旅行家的预算 简易的分类讨论 + 困难的贪心。 每次装到能抵达下一个价格更低的地方为止。然后开过去。 如果装满了也到不了，就在自己这里先把油加满，再开到价格相对最低的地方。 实现很烦。 棋盘问题（2） 简易的暴搜 + 改变搜索顺序的 $trick$ 。 搜索很简单，预处理质数表，随缘跑 $dfs$ 。 主要是要求首行首列和最小，可以用 $nxt$ 数组控制“下一个搜的位置”以达到这一效果。 进制位 简单思维 + 高精思想。 一行里有几个两位数就代表这是几。 最后需要逐一验证，这里要手打一个高精一样的玩意实现 $K$ 进制。 $2452276(Julian)$ 前 乘积最大 简单搜索 + 毒瘤高精。 预处理把某一位 $i$ 后 $j$ 位数单独分出来是多少。 以搜到第 $pos$ 位，用掉 $k$ 次分割机会为状态，记忆化暴搜。要写高精。表示： 方格取数 偏板的 $dp$ + 简单的压维优化。 转化为两个人从左上角走向右下角。 设计状态：$dp[i][j][k][l]$ 为第一个人走到 $(i,j)$ ，第二个人走到 $(k,l)$ 的最优解。 转移方程： f[i][j][k][l]=a[i][j]+a[k][l]+ \\max\\begin{cases}f[i-1][j][k-1][l]\\\\f[i-1][j][k][l-1]\\\\f[i][j-1][k-1][l]\\\\f[i][j-1][k][l-1]\\end{cases}因为两人走过的路程必定相等，故可以压掉最后一维。用前三维来算 $l$ 。优化： Car的旅行路线 初级的建图 + 最短路。 城市与城市连边，火车站之间连边，跑最短路即可。 需要写函数求笛卡尔坐标系上点距。 $2453006(Julian)$ 前 矩形覆盖 中等搜索。 以“搜到第 $pos$ 个点，覆盖这些点用了 $sum$ 个矩形”为状态 $dfs$ 。 加最优性剪枝，开结构体装矩形，重载运算符，手打函数以实现加点和判交。 $dfs$ 状态不好想。还是题刷少了。 神经网络 简单图论。 把所有初始状态为 $1$ 的结点入队，跑 $bfs$ 即可。读者： $2453737(Julian)$ 前 过河 中等 $dp$ 。 设计状态：$dp[i]$ 表示到达 $i$ 点最少需要走几步。 状态转移：$dp[i]=\\min\\{dp[i-k]\\}+1\\;(k\\in[L,R])$ 但是需要路径压缩节省空间，若两点之间距离超过 $R*(R+1)$ 则可以压成一个点。 篝火晚会 复杂思维题。 求变动次数，相当于是求不变人数。 不停的转动目标环和当前环，比较匹配个数。 提前处理好 $dis$ ，表示当前环上这个数到目标环上需要转动几次： 虫食算 困难搜索 + 改变搜索顺序的 $trick$ 。 依次搜索每个字母分别代表什么。 写 $judge$ 函数判断当前情况是否合法。 改变搜索顺序从较低位开搜。 $2454467(Julian)$ 前 作业调度方案 简单模拟。 每次找到第一个空位，向后查能不能安排得下这么多。 直到第一个能放下的位置放下即可。证明： 2^k进制数 困难组合数学。 推式子，若 $k|n$ 且每一位都不填 $0$ ，那么就是在 $2^k-1$ 个数中安排合适的顺序填，有 $C^{n/k}_{2^k-1}$ 。 若允许填 $0$ ，与上种情况一加，则枚举哪一位开始填的 $0$ ，有 $\\sum^{n/k}_{i=2}C^{i}_{2^k-1}$ 。 若 $k\\not|n$ ，若首位为 $0$ ，则后面退化成了上面那种情况。 若首位不为 $0$ ，后面全部受前面限制。有 $\\sum^{2^{n\\bmod k}}_{i=1}C^{n/k}_{2^k-i-1}$ 。 所以总式为： C^{\\lfloor\\frac{n}{k}\\rfloor}_{2^k-1}+\\sum^{2^{n\\bmod k}}_{i=1}C^{n/k}_{2^k-i-1}主要式子难推。 $2455198(Julian)$ 前 Hankson 的趣味题 简单数学。 有 $\\gcd(x,a_0)=a_1$ ， $x*b _ 0/\\gcd(x,b_0)=b_1$ 。 故有 $\\gcd(x/a_1,a_0/a_1)=1$ ， $\\gcd(b_1/x,b_1/b_0)=1$ 。 那么枚举 $b_1$ 的约数，测试是否满足如上条件即可。感想： 最优贸易 中等图论 + 简单 $dp$ 。 两次 $dfs$ 处理出 $1$ 号点可达的点和 $N$ 号点可达的点。 对于每一个 $1$ 号点可达的点 $u$ ，枚举每一条出边，倘若某出边抵达的点 $v$ 可达 $N$ 点，则在 $val_v$ 和 $val_u$ 之间连边（邻接表）。 跑 $floyed$ 传闭包。最终找到互相可达的最大差值的 $val$ ，其差值为答案。 靶形数独 简单暴搜 + 改变搜索顺序的 $trick$ 。 开 $hang,lie,gong$ 等数组表示各自范围内填数情况。 将 $0$ 少的行尽量先算以压缩搜索树。 写函数计算价值。回溯并更新。 双栈排序 二分图染色 + 中等贪心。 用栈的性质推知 $i&lt;j&lt;k$ ， $a_k&lt;a_i&lt;a_j$ 的情况是不可能的，故可因此构建出限制条件连边，二分图染色，分出两个栈来。 维护指针“现在该弹哪一个”，并选用贪心策略：尽量先走 $1$ 栈，尽量先 $push$ 。 实现难。 $2455563(Julian)$ 前 乌龟棋 简单 $dp$ 。 开四维数组 $dp[i][j][k][l]$ 表示用了 $i$ 个 $1$ ， $j$ 个 $2$ …… 的最大价值。 从四种情况转移过来即可。 引水入城 简单搜索 + 中等问题转化 。 先搜索出每个蓄水场能灌溉到最底下一行的哪些位置。 可证各个蓄水场能灌溉的位置必连续。 将题目转化为最小线段覆盖问题即可。 问题转化难想。 $2455928(Julian)$ 前 选择客栈 中等数数。 整前缀和，在 $for$ 循环跑客栈的过程中，实时更新某种颜色出现的次数。 每出现一个客栈，倘若它之前有过 $pre$ 个同颜色的，就使答案增加 $pre$。 注意各变量改值的顺序。 聪明的质监员 基础前缀和 + 基础二分。 二分这个 $W$ 。 每次 $judge$ 时做前缀和，暴力计算即可。 水蓝。 观光公交 复杂思维。 预处理每个时间点上车上的人数。可知装一个加速器会让当时在车上的人受益。 每次贪心选受益最大的就是了。选完以后记得重新更新。 正确性可以保证。 $2456294(Julian)$ 前 借教室 简单数据结构。 租用一段时间相当于在这些时间 $-1$ 。 如果某个时间点被减到 $0$ 以下，则说明不可行。 敲一棵线段树即可。复杂度： 开车旅行 复杂 $dp$ + 复杂倍增优化。 先配合 $set$ 预处理出在 $i$ 点上，某人（0/1）开车时会去哪。记作 $nxt[i][0/1]$ 。 设计状态 $arr[0/1][i][j]$ 为某人（0/1）从 $i$ 点出发，开车 $2^j$ 次到达的地方，显然有初始化： arr[0/1][i][0]=nxt[i][0/1]设计状态 $dp[0/1][0/1][i][j]$ 为从 $i$ 点出发，某人（第二维0/1）先开车，总开车 $2^j$ 次的过程中，某人（第一维0/1）行驶的路程，显然有初始化： dp[start][start][i][0]=dis(i,nxt[i][start])dp[start\\oplus 1][start][i][0]=0对于这 $2^k$ 的前半段和后半段是否是同一人开车分类讨论，有： 当 $j=1$ （即前后两段不同人）： arr[start][i][1] = arr[start\\oplus 1][arr[start][i][0]][0];dp[start][0][i][1] = dp[start][0][i][0] + dp[start\\oplus 1][0][arr[start][i][0]][0];dp[start][1][i][1] = dp[start][1][i][0] + dp[start\\oplus 1][1][arr[start][i][0]][0];当 $j!=1$ （前后同人）： arr[start][i][j] = arr[start][arr[start][i][j - 1]][j - 1];dp[start][0][i][j] = dp[start][0][i][j - 1] + dp[start][0][arr[start][i][j - 1]][j - 1];dp[start][1][i][j] = dp[start][1][i][j - 1] + dp[start][1][arr[start][i][j - 1]][j - 1];这样我们就处理出了所有的开车方法，询问时将 $j$ 从大到小枚举，逐个累加即可。 要求对算法灵活运用： 疫情控制 困难图论。 要最小化用时，就得二分这个时间，重在 $judge$ 函数。 先贪心地尽量把军队往根上移，因为根结点不能驻扎军队，所以如果一支军队可以移到根结点以上，则先把它停在根结点的一个儿子上，并且存一些剩余的时间。 我们称这些儿子为已驻军点。 再从根往下跑 $dfs$ ，求出根结点下属的哪棵子树还未被切断，处理这些子树根结点到全树的根结点的距离。 我们称这些根结点为未驻军点。 贪心地让剩余时间少的已驻军点，移向离根结点距离近的未驻军点。 若未驻军点都可被移到，则可行，尝试更小的时间。 实现十分困难。 $2457024(Julian)$ 前 联合权值 简单图论。 两点距离为 $2$ ，说明必然只有一个中间点把他们两个连接。 那么 $O(n)$ 枚举一下这个中间点，取 $\\max$ /求和即可。 飞扬的小鸟 中等 $dp$ + 压维优化。 设置状态 $dp[i][j]$ 表示在二维平面上达到 $(i,j)$ 所需的最小点击次数。 有转移 dp[i][max(M,j+k\\cdot up)]=dp[i-1][j]+k$i$ 只与上一位有关，滚掉即可。 摸索到正解要较长时间。形象化： 寻找道路 中等图论。 建反图跑 $dfs$ ，求出能抵达终点的点有哪些，染色。 建正图，跑只通过已染色点的 $dij$ 即可。 刷大量图论以掌握反图的灵活运用。 指刷题量。 解方程 简单数学。 枚举 $x$ 取值，用秦九韶算法求值判断即可。 $2457389(Julian)$ 前 斗地主 复杂搜索。 先搜顺子，数据不大，暴力枚举可能出现的顺子情况，更改状态往下搜（ $dfs1$ ），搜后复原。 同时在 $dfs1$ 中调用 $dfs2$ ，其作用为搜索最少出牌次数，传4个参数，代表单牌张数，对子张数，三个头张数，炸弹张数即可。 $dfs2$ 中除了正常出牌策略外，还可有拆牌选项，即“不消耗出牌次数，将XXX牌型（如：一对）拆成几个XXX（如：两张单）。” 在 $dfs1$ 过程中更新最小值即可。 应学会把不等价操作转为等价。 指题解。 子串 中等 $dp$ + 滚动数组优化。 设置状态： $dp_{i,j,k,l}$ 表示：“决策到原串的第 $i$ 位，匹配串的第 $j$ 位，已用掉 $k$ 次拆分次数，这个第 $i$ 个数是否（1/0）用来匹配”的方案数。 有 dp_{i,j,k,0}=dp_{i-1,j,k,0}+dp_{i-1,j,k,1}dp_{i,j,k,1}=\\begin{cases}0\\qquad(A[i]\\neq B[j])\\\\dp_{i-1,j,k-1,0}+dp_{i-1,j-1,k,1}+dp_{i-1,j-1,k-1,1}\\qquad (A[i]=B[j])\\end{cases}滚掉第一维。 应掌握在 $dp$ 数组下标中设置 $0/1$ 维度，对之分类讨论。 代码很短。 运输计划 中等图论 + 中等二分。 题目要求使最长航线最短，故二分最长航线的长度。 所有超过这个二分出的长度的航线，说明都需要加速，可以用 $LCA$ 求出某条航线长度。 对每一条超过的航线做树上差分，若某一条边差分出来的值 = 超过航线的数目。说明这条边被所有超过的航线经过，故这是一条可以加速的边。 取所有可以加速的边中的最大值来加速，若使所有航线中最长的一条也低于了我们二分出的值，则这是一种可行的方案，尝试更小的长度。 重在思维和马速，细节不多。 $2457754(Julian)$ 前 换教室 简单图论 + 中等 $dp$ + 中等概率期望。 结点数少，可 $floyed$ 求两点距离。 设置状态 $dp_{i,j,k}$ 表示决策到第 $i$ 节课，已用掉 $j$ 次申请机会，这节课是否（0/1）申请时，走过路程的期望。 另设 C1 指上节课本该在的教室， C2 指这节课本该在的教室， D1 指上节课换去的教室， D2 指这节课换去的教室。 设 $pr[i]$ 为第 $i$ 节课换成功的概率。 显然有： dp_{i,j,0}=\\min\\begin{cases}dp_{i-1,j,0}+dis(C1,C2)\\\\dp_{i-1,j,1}+pr_{i-1}\\cdot dis(D1,C2)+(1-pr_{i-1})\\cdot dis(C1,C2)\\end{cases}dp_{i,j,1}=\\min\\begin{cases}dp_{i-1,j-1,0}+pr_{i}\\cdot dis(C1,D2)+(1-pr_{i})\\cdot dis(C1,C2)\\\\\\\\dp_{i-1, j-1,1}+pr_{i-1}\\cdot pr_{i}\\cdot dis(D1,D2)+pr_{i}\\cdot (1-pr_{i-1})\\cdot dis(C1,D2)\\\\+(1-pr_{i})\\cdot pr_{i-1}\\cdot dis(D1,C2)+ (1-pr_{i-1})\\cdot (1-pr_{i})\\cdot dis(C1,C2)\\end{cases}码量不大。公式别抄错了。 蚯蚓 复杂思维。 手模发现每一次砍的蚯蚓单调递增。 维护三个队列，分别装原蚯蚓，切后较长的蚯蚓，切后较短的蚯蚓 。 每次取三个队列中的队首中最长的一条，取出并根据当前天数修改长度值。切后，将都两段减去一些长度值（表示少成长了这么多天），放入相应队列。如此往复即可。 重在思路的推导，这题看了题解。 愤怒的小鸟 中等搜索 + 中等状压 。 跑 $dfs$ ，参数包括：还剩下多少猪要打，决策到第几头猪，已用了多少抛物线。 对于每一只猪，若它被之前的某条抛物线经过，则跳过，搜索下一只猪。 若没有，尝试它可以和哪一只还未打的猪串起来一起打，向下搜索。 用状压记录每一只猪是否被打掉的状态。 不需要用到 $M$ 。 $2458119(Julian)$ 前 逛公园 中等图论 + 困难 $dp$ 。 建正反两图。在正图上跑 $dij$ ，求出 $1$ 号点到其他点的最短路 $dis$ 。 在反图上跑 $dp$ ，设计状态 $dp[u][k]$ 表示决策到第 $u$ 个点，路径比最短路长 $k$ 的方案。 有： dp[u][k]=\\sum dp[v][k+(dis[u]-dis[v])-w_{u,v}]用记搜实现即可。注意先判环，有 $0$ 环在最短路上则为无限解，可用 $Bellman-Ford$ 解决。 能通过所有 $hack$ 数据。 宝藏 中等随机化。 生成开发顺序排列，以代价作为 $\\text{calc}$ 函数返回值，若更优或一定概率下更劣，则在原序列基础上随机交换两个元素，否则 $\\text{random_shuffle}$ 生成新排列。 出正解率极高。 $2458484(Julian)$ 前 货币系统 简单递推。 设置 $flag$ 数组存三种值： $0$ —— 未能被凑出的面值， $1$ —— 能被凑出的面值 ， $2$ —— 本来就有的面值。 枚举当前所有 $flag$ 非零的面值，筛一下后面的面值（改一些面值对应的 $flag$ 为 $1$ ）。有时可以将一个 $2$ 覆盖成 $1$ ，表示这种初始面值是不需要的。 最后扫一遍 $flag$ 数组，有几个 $2$ 就是需要多少初始面值。 赛道修建 中等图论。 二分最短的赛道长度。以之为标准跑 $dfs$ 获取路径长度。若某条路径长度大于标准，则可行路++，若小于，则丢进 $set$ 等待匹配。 在 $set$ 里用 $\\text{lower_bound}$ 尽可能多地拼路径，若可行路径 &gt; $M$ ，则尝试更大的 $mid$ 。 $set$ 改 $multiset$ 也可。 咕咕咕！","categories":[],"tags":[{"name":"“知识”决定命运","slug":"“知识”决定命运","permalink":"https://quest233.github.io/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/"}]},{"title":"多项式公式查询+板子整理","slug":"多项式公式查询-板子整理","date":"2021-04-17T06:55:24.000Z","updated":"2021-04-22T01:56:01.610Z","comments":true,"path":"2021/04/17/多项式公式查询-板子整理/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%AC%E5%BC%8F%E6%9F%A5%E8%AF%A2-%E6%9D%BF%E5%AD%90%E6%95%B4%E7%90%86/","excerpt":"","text":"RT，为了方便自己全文背诵板子特开此文。 代码有很多很冗余的地方，主要是因为 @Rui_R 神仙是这么说的： $\\mathrm{NTT}$123456789101112131415161718192021222324252627282930313233void NTT(poly &amp;arr, int typ)&#123; for (int i = 0; i &lt; LIM; i++) &#123; if (R[i] &gt; i) &#123; swap(arr[i], arr[R[i]]); &#125; &#125; for (int mid = 1; mid &lt; LIM; mid &lt;&lt;= 1) &#123; int W = quick_pow(typ == 1 ? org : lev, (MOD - 1) / (mid &lt;&lt; 1)); for (int j = 0; j &lt; LIM; j += (mid &lt;&lt; 1)) &#123; int w = 1; for (int i = 0; i &lt; mid; i++) &#123; int x = arr[i + j], y = (arr[i + j + mid] * w) % MOD; arr[i + j] = (x + y) % MOD; arr[i + j + mid] = (x - y + MOD) % MOD; w = w * W % MOD; &#125; &#125; &#125; if (typ == -1) &#123; int inv = quick_pow(LIM, MOD - 2); for (int i = 0; i &lt; LIM; i++) &#123; arr[i] = arr[i] * inv % MOD; &#125; &#125;&#125; $\\mathrm{init}$ （取按位反转）1234567891011121314void init(int len)&#123; L = 0; LIM = 1; while (LIM &lt;= len) &#123; L++; LIM &lt;&lt;= 1LL; &#125; for (int i = 0; i &lt; LIM; i++) &#123; R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)); &#125;&#125; $\\mathrm{mul}$ （卷）1234567891011121314151617181920212223void mul(poly &amp;a, int lena, poly &amp;b, int lenb, poly &amp;kk)&#123; init(lena + lenb); for (int i = lena; i &lt; LIM; i++) &#123; a[i] = 0; &#125; for (int i = lenb; i &lt; LIM; i++) &#123; b[i] = 0; &#125; NTT(a, 1); NTT(b, 1); for (int i = 0; i &lt; LIM; i++) &#123; kk[i] = (a[i] * b[i]) % MOD; &#125; NTT(kk, -1); for (int i = lena + lenb - 1; i &lt; LIM; i++) &#123; kk[i] = 0; &#125;&#125; 以上三个是最基础的，不另加公式。 $\\mathrm{inv}$ （取逆元）设： \\mathrm{G*F\\equiv1\\pmod {x^n}}\\mathrm{G_0*F\\equiv1 \\pmod{x^\\frac{n}{2}}}有： \\mathrm{(G-G_0)\\equiv 0\\pmod{x^\\frac{n}{2}}}\\mathrm{(G-G_0)^2\\equiv 0\\pmod{x^{n}}}\\mathrm{G^2-2GG_0+G_0^2\\equiv0\\pmod {x^n}}\\mathrm{FG^2-2FGG_0+FG_0^2\\equiv0\\pmod {x^n}}\\mathrm{G-2G_0+FG_0^2\\equiv0\\pmod {x^n}}\\mathrm{G\\equiv2G_0-F_0^2G_0\\pmod {x^n}}1234567891011121314151617181920212223242526272829303132333435363738namespace INV&#123; poly G0, F;&#125;void get_inv(poly &amp;a, int len, poly &amp;kk)&#123; if (len == 1) &#123; kk[0] = quick_pow(a[0], MOD - 2); return; &#125; INV::G0.clear(); get_inv(a, (len + 1) &gt;&gt; 1LL, INV::G0); init(len + len); for (int i = 0; i &lt; len; i++) &#123; INV::F[i] = a[i]; &#125; for (int i = len; i &lt; LIM; i++) &#123; INV::F[i] = 0; &#125; NTT(INV::F, 1); NTT(INV::G0, 1); for (int i = 0; i &lt; LIM; i++) &#123; kk[i] = (INV::G0[i] * (2 - (INV::G0[i] * INV::F[i]) % MOD)) % MOD; &#125; NTT(kk, -1); for (int i = len; i &lt; LIM; i++) &#123; kk[i] = 0; &#125;&#125; $\\mathrm{ln}$不会求导，全文背诵。 \\mathrm{G=∫\\dfrac{F'}{F}}1234567891011121314151617181920212223242526272829303132333435namespace LN&#123; poly dev_A, inv_A, B;&#125;void get_dev(poly &amp;a, int len, poly &amp;kk)&#123; for (int i = 1; i &lt; len; i++) &#123; kk[i - 1] = a[i] * i % MOD; &#125; kk[len - 1] = 0;&#125;void get_idev(poly &amp;a, int len, poly &amp;kk)&#123; for (int i = 1; i &lt; len; i++) &#123; kk[i] = a[i - 1] * quick_pow(i, MOD - 2) % MOD; &#125; kk[0] = 0;&#125;void get_ln(poly &amp;a, int len, poly &amp;kk)&#123; kk.clear(); LN::dev_A.clear(); get_dev(a, len, LN::dev_A); LN::inv_A.clear(); get_inv(a, len, LN::inv_A); LN::B.clear(); mul(LN::dev_A, len, LN::inv_A, len, LN::B); get_idev(LN::B, len, kk);&#125; $\\mathrm{exp}$不会求导，全文背诵。 \\mathrm{G\\equiv G_0(1-ln(G_0)+F)\\pmod {x^n}}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace EXP&#123; poly G0, lnG0, F;&#125;void get_exp(poly &amp;a, int len, poly &amp;kk)&#123; if (len == 1) &#123; kk[0] = 1; return; &#125; /*获取G0*/ EXP::G0.clear(); get_exp(a, len + 1 &gt;&gt; 1, EXP::G0); /*获取ln(G0)*/ get_ln(EXP::G0, len, EXP::lnG0); init(len + len); /*获取F*/ EXP::F.clear(); for (int i = 0; i &lt; len; i++) &#123; EXP::F[i] = a[i]; &#125; for (int i = len; i &lt; LIM; i++) &#123; EXP::F[i] = 0; &#125; NTT(EXP::G0, 1); NTT(EXP::lnG0, 1); NTT(EXP::F, 1); for (int i = 0; i &lt; LIM; i++) &#123; kk[i] = EXP::G0[i] * ((1 - EXP::lnG0[i] + EXP::F[i] + MOD) % MOD) % MOD; &#125; NTT(kk, -1); for (int i = len; i &lt; LIM; i++) &#123; kk[i] = 0; &#125; EXP::lnG0.clear();&#125; $\\text{sqrt}$不会任意零次项 $\\text{sqrt}$ ，先整理零次项为 $1$ 的 $\\text{sqrt}$ 。 设： \\mathrm{G^2\\equiv F\\pmod {x^n}}\\mathrm{G_0^2\\equiv F\\pmod{x^{\\frac{n}{2}}}}有： \\mathrm{G_0^2-G^2\\equiv 0\\pmod {x^\\frac{n}{2}}}\\mathrm{G_0^4-2G_0^2G^2+G^4\\equiv 0\\pmod {x^n}}\\mathrm{(G_0^2+G^2)^2\\equiv 4G_0^2G^2\\pmod{x^n}}\\mathrm{G_0^2+G^2\\equiv 2G_0G\\pmod{x^n}}\\mathrm{G_0^2+F\\equiv 2G_0G\\pmod{x^n}}\\mathrm{G\\equiv \\dfrac{G_0^2+F}{2G_0} \\pmod{x^n}}123456789101112131415161718192021222324252627282930313233343536373839404142namespace SQRT&#123; poly G, F, A, invG;&#125;void get_sqrt(poly &amp;a, int len, poly &amp;kk)&#123; if (len == 1) &#123; kk[0] = 1; return; &#125; SQRT::G.clear(); get_sqrt(a, len + 1 &gt;&gt; 1, SQRT::G); SQRT::invG.clear(); get_inv(SQRT::G, len, SQRT::invG); SQRT::A.clear(); init(len + len); for (int i = 0; i &lt; len; i++) &#123; SQRT::A[i] = a[i]; &#125; for (int i = len; i &lt; LIM; i++) &#123; SQRT::A[i] = 0; &#125; NTT(SQRT::G, 1); NTT(SQRT::invG, 1); NTT(SQRT::A, 1); int inv2 = quick_pow(2, MOD - 2); for (int i = 0; i &lt; LIM; i++) &#123; kk[i] = ((SQRT::G[i] + SQRT::A[i] * SQRT::invG[i] % MOD) % MOD * inv2) % MOD; &#125; NTT(kk, -1); for (int i = len; i &lt; LIM; i++) &#123; kk[i] = 0; &#125;&#125;","categories":[],"tags":[{"name":"“知识”决定命运","slug":"“知识”决定命运","permalink":"https://quest233.github.io/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/"}]},{"title":"联赛前夕的小小小小小复习","slug":"联赛前夕的小小小小小复习","date":"2021-04-17T06:47:17.000Z","updated":"2021-04-17T08:13:27.234Z","comments":true,"path":"2021/04/17/联赛前夕的小小小小小复习/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E8%81%94%E8%B5%9B%E5%89%8D%E5%A4%95%E7%9A%84%E5%B0%8F%E5%B0%8F%E5%B0%8F%E5%B0%8F%E5%B0%8F%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"$CSP$ 就要到辣！场外退役选手正准备抱一抱 $\\Large\\color{orange}{\\texttt{佛}}$ 脚。 所谓复习者，实则是康一康以前切（he）过的所有有一定难度的题目 $AwA$。 因为我的做题量属实不行，所以这个坑应该很快会填完！ UPD: $NOIp$ 就要到辣！场外退役选手正准备抱一抱 $\\Large\\color{orange}{\\texttt{佛}}$ 脚。 $2020.07.01-2020.07.20$ CF337D Book of Evil 闲话： 很奇怪，我的第一道紫题比蓝题来的还早。 现在去看才发现这道题真的水，难怪那时候那么逊的笔者也肝出来了。 启发： 对于 数据范围较小 的树形图，干脆就预处理每对点之间的 $dis_{u,v}$ ，便于以后 $dp$ 时转移。 动态查找树上最远/近点对，第一眼应该想到 树形 $dp$ 而非点分树啊啥的。这种题目维护一个最大/小值，维护一个次大/小值，并对其动态更新就是了。 CF489E Hiking 闲话： 那时不懂事，见到个带除号的就说是分数规划，没想到还真给我说对了一回。 还真就是分数规划的板子题啊。 启发： 分数规划 的基本形态： $\\dfrac{\\sum v_i}{\\sum w_i}=\\eta$ 。我们的目的就是让这个 $\\eta$ 尽可能大。 考虑化式子： \\dfrac{\\sum v_i}{\\sum w_i}=\\eta\\sum v_i-\\eta\\cdot\\sum w_i=0二分 $\\eta$ 的答案，一通胡乱代算就行了。 如果发现 $dp$ 方程出现 $\\ if(dp_{i,j}+f_{i}&gt;dp_{j})\\quad balabala;\\;$ 的句子出现，甚至可以跑 最短路 。 CF1251E2 Voting (Hard Version) 闲话： 我明确记得这是我听机房神仙讲vjudge上的题中，少有的能听懂的一道。 启发： 如果一道贪心题，对一个对象什么时候进行操作，结果都一样的时候，那就要么越早越好，要么拖到最后一秒（卡点预警） CF1200E Compress Words 闲话： 听说因为这题写三模哈希的人都被hack了四次，CF特色。 KMP 专场算是我早期打 $vjudge$ 上面的比赛打的比较好的一次了，虽然也冲不进前五。 启发： 需要深刻认识到 KMP 算法中 失配指针 的意义：一个串的前缀和后缀最大匹配长度。 字符串 拼接 不是融合，有时需要用特殊字符（串）分割两个拼接的字符串。 P3452 [POI2007]BIU-Offices 闲话： $\\color{black}{R}\\color{red}{UI_R}$ 神那时候好像还分不清补图和反图，被我大肆嘲笑了一番。 启发： 题目要是说什么“两人之间有XX关系”阿巴阿巴之类的，不是并查集就是两点之间连一条边跑搜索。这题就是一道连边跑 $bfs$ 。 CF706E Working routine 闲话： 讨论区里的两篇翻译质量都好高啊（（（ 可惜只能选取其中一份。 启发： 当我们尝试对数组、矩阵、STL 等大型容器做一些变换时，倘若直接交换、移动元素的工作量会很大，我们可以考虑只变换 具有代表性的一个位置 的指针，以减小工作量。 比如这题就是用一个方块 左上角 的位置对应指针，再对指针进行移动、交换的。 P3620 [APIO/CTSC 2007]数据备份 闲话： 你谷上的有悔贪心习题是真的少，不过是找道板子题都紫题起步。 但是也正因为这道题我才发现，51nod才是真的不行，下载数据都要花钱。 启发： 有悔贪心，一个极为鲜明的特点就在于，不管是什么时候选，选它的代价往往都只是一个 固定的数值 。 而实现的方式也很简单，一种是记录选择了什么元素，一种是留下一个反悔点，让之后还可以有后悔的机会。 CF980E The Number Games 闲话： 题解区的压行大师zhh不压行了，我的青春结束了。 启发： $2^k$ 有个极妙的性质，一个 $2^k$ ，即使所有 $2^i(i&lt;k)$ 加起来也不如它。 所以这道题无脑暴搜，优先取编号 $k$ 大的即可。 P1120 小木棍［数据加强版］ 闲话： 臭名昭著的剪枝题，用上了8种剪枝才过的题。 我就是不行。 启发： 虽说臭名昭著，但有的剪枝还是该学习的。 该退出赶紧退出，既然已知道剩下都是在空跑循环，做额外功，为什么不在能 $return$ 的 最近 的地方赶紧走人呢。 暴搜不等于无脑，有的时候 手推 出的遍历的上下界就特别优秀。 P2261 [CQOI2007]余数求和 闲话： 给指导在台上讲杜教筛，蒟蒻听得一脸懵比。 没办法，只能学前置芝士，结果就滚到了这里。 启发： 数论分块中的整除分块，可以根号解决大部分向下取整的问题。 其实就是这个式子： \\left\\lfloor\\frac{k}{\\left\\lfloor\\dfrac{k}{\\lfloor\\frac{k}{i}\\rfloor}\\right\\rfloor}\\right\\rfloor=\\lfloor\\dfrac{k}{i}\\rfloor（大草，我不会 $\\LaTeX$ 。） 然后将 $i$ 到 $\\left\\lfloor\\dfrac{k}{\\lfloor\\frac{k}{i}\\rfloor}\\right\\rfloor$ 当成一个整体一起算就是了。 P4208 [JSOI2008]最小生成树计数 闲话： 并查集专场人生巅峰，拿了俩一血和一个泉水一血，至今还是那场的 $rank\\ 1$ 。 后来就越来越不行了。 启发： 最小生成树中同一种边权出现的个数是 固定的 ，证明略。感性理解是，如果还有另一种方法来替换其中一条边，他就不能叫 最小 或者不能叫 树 了。 对于边权未知的题，开桶之前还是 离散化 一下最为靠谱，尽管题目好像跟你说了同一种边权不会超过十条。（杰宝一开始兴致勃勃地想用乱搞搞过去，结果打了个指数算法还假掉了）。 $2020.07.21-2020.08.20$ P5027 Barracuda 闲话： 写到这道题的时候才发现以前一直打的 $gauss$ 消元都是假的。 从一个侧面反映了你谷数据水。 启发： 手打 $swap$ 要！传！地！址！洛谷上的模板是什么辣鸡数据。 $double$ 运算小心炸精，遇事不决先 $\\times 1.0$ 。 CF835F Roads in the Kingdom 闲话： 噫，我完全不记得怎么做了，怕不是我又贺题解了。 启发： 要在基环树上断边使原图联通，则必断 环 上的点。 应有化繁为简意识，比如这一题就可以把基环树下挂树内最长路径，存到环上点中作为点权。 P1169 [ZJOI2007]棋盘制作 闲话： 第一眼：$dp$ ！ 第二眼：单调栈 ！ 第三眼：我傻了。 弱的只是我罢。/dk/dk 启发： 悬线法，一种求 最大矩阵 的高妙做法。 大体思路是往 两边扩展 直到无法满足条件。可惜后来这样的题越来越少了，学个思想就行了（吧？） CF786B Legacy 闲话： 我做这题的时候根本没学过“线段树优化建图”嗷，即使是现在也没学会。 但就是 YY 出了正解，小编也很惊讶。 启发： 带线段树的题一定要开好空间！全天下的线段树不全都是 $4$ 倍空间，这题开的就是 $8$ 倍。 CF896C Willem, Chtholly and Seniorious 闲话： 珂朵莉树好写又好吃，为什么不写？（指不恰当地使用 $set$ 导致疯狂 $RE$ ） 可惜这道板子题已经掉紫，成为时代的眼泪了。 启发： 一定要先 $split$ 右区间，否则可能会 $RE$ 有的函数装在 &lt;cmath&gt; 库里，码的时候千万小心冲突。可能在本地不会给你报错。 P2569 [SCOI2010]股票交易 闲话： 这题还是我上去讲的。 听别人说，他们觉得我讲题的套路从来就是：“XXX是板子，我不讲了。XXX只要和XXX一样反着跑就行了。XXX就不用我多说了吧……” 能听懂的才是人上人嗷！ 启发： 如果几方面的决策互不影响，则可以考虑将他们 分开来 分别 $dp$ 。比如这里的买、卖和什么都不做的情况，每天只能做他们其中的一个。 $dp$ 顺序一定要注意，如果是有意让 $i-1$ 不影响 $i$ ，就应该反向扫。 P1896 [SCOI2005]互不侵犯 闲话： 当初 $RUI_R$ 问我这道题的时候其实我是拒绝的，因为它真的很水很板，直到我自己码的时候处处出锅。 我们成家班都在码 启发： 枚举状态要枚举到 $0$ ，因为全空也是一种情况。 状压初始状态设计应设计得当，避免有漏初始化的情况。 P6747 『MdOI R3』Teleport 闲话： 做这题的时候第一次接触了 hack.chat 这个神仙网站，后来就把它当成了以后的加密通讯工具（笑） 启发： 对于两数与/或/异或求 $\\min,\\max$ 的题目，可以开数组，按位考虑取0还是1。 位运算小心爆精，能开 long long 开 long long ，能开 int128 开 int128 ，比如这题就只能开 128 水过。 P3878 [TJOI2010]分金币 闲话： 喔！这题就是我交了122发的那道退火！！！ 启发： int 类型的函数一定要有 返回值 ！ 有时候这里的锅呈现出来的是 TLE ，调起来极其自闭。 $2020.08.21-2020.09.10$ P4269 [USACO18FEB]Snow Boots G 闲话： 明明一道 $set$ 水过的题要做这么麻烦，这一切，值得吗？ 启发： 善于使用“ 改变循环顺序 ”的方法优化/卡常。 比如这里就可以将地砖排序，不联通后马上 $break$ 的方法，以达到每次减小循环长度的作用。 P1052 过河 闲话： hoho！我就是不行，远古联赛第二题都要看题解！ 启发： 对于多个决策点之间的距离过大，有大量转移的结果往往相同的时候，可以考虑 路径压缩 ，类似图论中的缩点。 P3694 邦邦的大合唱站队 闲话： zb的大合唱站队/xyx 启发： 状压dp的状态可以表示的东东不限于该点的存在，还可以表示是否归位、存活可能性之类的。 P1248 加工生产调度 闲话： 一道从初三解决到高一的历史性问题。 甚至横跨了一整个AFO周期都没推出贪心式子。 启发： 两条流水线排工程的题目，基本思路为 johnson 算法：即在 $A$ 流水线上快的按耗时递减排，在 $B$ 流水线上快的按耗时递增排。 P2233 [HNOI2002]公交车路线 闲话： 我就是在写这题的时候被QY叫出去D爆的！ 我倒是记得清楚。 启发： 走来走去求方案数的题大多可以矩乘解决，比如《美食家》。 有一个东西叫什么薛山定理的，大体就是：有规律的转移往往会回到最初状态。 即：$f(n)=f(0)$ P3398 仓鼠找sugar 闲话： 你谷是不是人均人赢啊！ 下辈子当个给说不定树论会好一点。 启发： 证明树上两条路径有交点的方法：$dis(A,B) + dis(C,D) ≥ dis(A,C) + dis(B,D)$ P3205 [HNOI2010]合唱队 闲话: 为什么会有 2000m 高的人，不知道高到哪里去了。 启发： 需要区间dp的题目的两种要素： 如果是最优解类题目，则要求全局答案必须满足 每一个小区间 都为最优答案。 如果是计数类题目，则要求大区间是在 小区间的基础上 建立的。 $2020.09.11-2020.09.30$ P4139 上帝与集合的正确用法 闲话： 我记得我说过联赛前碰数论就吃奥利给来着。 启发： 背熟： a^b≡\\begin{cases}a^{b \\bmod \\varphi(m)}& (\\gcd(a,m)=1)\\\\a^b&(b","categories":[],"tags":[{"name":"“知识”决定命运","slug":"“知识”决定命运","permalink":"https://quest233.github.io/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/"}]},{"title":"XJ2021春游游记","slug":"XJ2021春游游记","date":"2021-04-17T06:25:26.000Z","updated":"2021-04-17T08:08:19.991Z","comments":true,"path":"2021/04/17/XJ2021春游游记/","link":"","permalink":"https://quest233.github.io/2021/04/17/XJ2021%E6%98%A5%E6%B8%B8%E6%B8%B8%E8%AE%B0/","excerpt":"","text":"我们带着激动的心情来到公园，我们就觉得今日的公园和往日的公园大有不同，是因为有了美丽的春姑娘和小朋友们快乐的笑声、美丽的笑脸。 公园中央有一个大湖，湖水很碧绿，湖水中有许多小鱼和小虾。公园的周围有许多花草树木及秋千和许多健身器材。夜晚，龙潭公园有许多劳累了一天的人们在闲谈，还有许多小孩在那里尽情的玩耍。我们先写了一个春游计划，然后租了辆车，便出发了。不一会，就到了公园，只见又清又绿的水里倒映着蓝天，白云……公园的周围树木很多很多，像一个大森林，可惜叶子还没长出来。我们爬到了河堤，俯视公园，公园真像大海呀！一眼望不到头。不知不觉就到中午了，我们一边吃烧烤，一边观赏着公园的风景……吃完午饭后，我们一起来到公园，刚进公园，我们就看见有一群人看耍猴，我们挤了进去，看见那个耍猴人牵着三只猴子，一边说笑话，一边耍猴。我们看的可高兴了！不知不觉以尽黄昏，我们不得不结束今天的旅行。 梦醒了。","categories":[],"tags":[{"name":"water","slug":"water","permalink":"https://quest233.github.io/tags/water/"}]},{"title":"浅谈简单小数学题","slug":"浅谈简单数学","date":"2021-04-17T05:34:21.000Z","updated":"2021-04-19T03:33:13.388Z","comments":true,"path":"2021/04/17/浅谈简单数学/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6/","excerpt":"","text":"~~数论小白，在线挨打~~ 很难想象笔者在 48h 之前对这些艰涩的数论名词还是一无所知。然而在两天的探（zhua）索（ba）之后，我也不禁感叹数论的美（e）妙（xin）。 扩 展 欧 几 里 得($\\mathtt{exgcd}$)诸位读者一定对 $\\gcd$ 毫不陌生，这是一种递归（或者不递归？）求最大公约数的方法，其核心在于 $\\gcd(a,b)=\\gcd(b, a\\bmod b)$ 而 $\\mathtt{exgcd}$ 却与之略有提升，它还是用于求解同余方程 $ax+by=\\gcd(a,b)$ 的一种工具。 实现？ ： 对于我们手上的一个方程，造一个拥有两个参数 $a$ ,$b$ 的函数 $\\mathtt{exgcd}$ 层层调用，老千层饼了，递归时参数的改动与 $\\gcd$ 相似，都是以 $b$ 成为新 $a$ ，以 $a \\bmod b$ 成为新 $b$ 。 在每一层的递归结束后，还不能结束，我们有一对全局变量 $x,y$ ，它们的存在意义是作为这个方程的最终解。将 $x$ 更改成原来的 $y$ ，将 $y$ 更改成 $x- \\left\\lfloor\\dfrac{a}{b}\\right\\rfloor * y $ （附）有关 2 中 $x,y$ 变量变化的原因？ ：不妨设新的 $x$ 为 $ x’$ ，新的 $y$ 为 $ y’$ ； 则有 $ax+by=bx’+(a\\bmod b)y’$ ； 也就是 $ax+by=bx’+(a-b * \\left\\lfloor\\dfrac{a}{b}\\right\\rfloor)y’$ ； 一波运算即得 $ax+by=ay’+b(x’-\\left\\lfloor\\dfrac{a}{b}\\right\\rfloor * y’) $； 所以 $ x’$ 可以转化成 $y$ ， $ y’$ 可转化为 $x-\\left\\lfloor\\dfrac{a}{b}\\right\\rfloor * y$。 $\\Box$ 我们继续。递归是一定要停下来的，因为只要道路不断延伸…………（雾）。我们要为他设定一个终点，当 $b=0$ 的时候，此时如果再做下去，就会出现 $a \\div 0$ 的 RE 情况，观察此时我们手上的方程式 $ax+0 y = \\gcd (a,b)$ ，*一定有一个极小解 $x=1,y=0$ ，走到这一步，我们马上改变 $x,y$ ，然后 return 走人。 这里放上我们 $\\mathtt{exgcd}$ 的函数代码～：1234567891011121314int x, y;void exgcd(int a, int b)&#123; if(b==0) &#123; x = 1; y = 0; return; &#125; exgcd(b, a % b);//递归 int tmp = x; x = y; y = tmp - (a / b) * y;//更改x,y的值&#125; 乘 法 逆 元($\\mathtt{inv}$)：若有 $ ax \\equiv1 \\bmod b$（ $\\equiv $ ，即同余）（要求 $a,b$ 互质) ， 则称 $a$ 关于 1 模 $b$ 的乘法逆元为 $x$ 。也可表示为 $ax≡1 \\pmod b$ 。对于一个数关于 1 模 $b$ 的乘法逆元，我们还有另一个通俗的名字“倒数”。 实现？ :这里给出两种求乘法逆元的方法，分别适用不同的情况： $\\mathtt{exgcd}$法：适用情形：不管模数是不是质数，较适用于对单个数的查询（言外之意使用面更广，但复杂度不够优） 前文提到，$\\mathtt{exgcd}$ 其作用是求解同余方程，它形如 $ax+by=\\gcd(a,b)$ ，可我们怎么把求乘法逆元的式子转化成同余方程的形式呢？我们考虑稍加变换。观察这个式子： ax≡1\\pmod b我们可以将同余化为等号，用我们的转化带余除法的传统艺能： ax=by+1再稍加移项～： ax+(-b)y=1啊这，这不是同余方程？那我们对其求解，其答案中的 $x$ 不就是一个满足这个方程的 $a$ 关于 1 模 $f$ 的乘法逆元嘛？ 芜湖，起飞！上代码：12345678910111213141516171819202122232425void inv(int a, int b)&#123; if (!b) &#123; x = 1; y = 0; return; &#125; exgcd(b, a % b); int tmp = x; x = y; y = tmp - (a / b) * y; return ;&#125;int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n;i++) &#123; x = y = 0; inv(i, k); cout &lt;&lt; (x%k+k)%k &lt;&lt; endl; &#125;&#125; 递推法：适用情形：模数必须是质数，使用于需要求多个数的乘法逆元的情况（换言之就是限制多但是效率快，可以达到线性） 所谓递推，公式求出来，代码就是几行的事，重在公式的推导。来看原式： ax≡1\\pmod b我们设这个 $b=k * i+r$ ，也就是设 $k=\\left\\lfloor\\dfrac{b}{i}\\right\\rfloor$ ， $r=b \\bmod i$ 。 k * i+r≡0 \\pmod b左右同乘 $\\dfrac{1}{i * r}$ 得： \\dfrac{k}{r}+\\dfrac{1}{i}≡0 \\pmod b稍加移项即得： \\dfrac{1}{i}≡b-\\dfrac{k}{r} \\pmod b也就是： i^{-1}≡b-\\left\\lfloor\\dfrac{b}{i}\\right\\rfloor * (b\\bmod i)^{-1}啊这，左边这玩意不就是 $i$ 关于 $1 \\bmod b$ 的逆元嘛？有被爽到。而右边那些玩意完全都是已知的。诸位可能疑问的，估计就是最后那个 $(b\\bmod i)^{-1}$ 为什么已知，然而 $b\\bmod i$ 必然小于 $i$，我们的递推又是从小到大推，所以…… 女少 口阿！上代码：123456789101112signed main()&#123; int n,p; cin &gt;&gt; n &gt;&gt; p; inv[1]=1;//inv即为逆元之意 cout&lt;&lt;1&lt;&lt;endl; for (int i = 2; i &lt;= n;i++) &#123; inv[i] = p - (p / i) * inv[p % i]%p;//递推公式 printf(&quot;%d\\n&quot;, inv[i]); &#125;&#125; 矩 阵 乘 法矩阵？乘法？定义：我们手上有两个矩阵如下: \\begin{pmatrix}a1&a2\\\\a3&a4\\end{pmatrix} * \\begin{pmatrix}b1&b2\\\\b3&b4\\end{pmatrix}我们矩阵乘法的规则是“对位相乘”，积矩阵第 $i$ 行第 $j$ 列的值等于第一个乘数矩阵第 $i$ 行第 $k$ 列与第二个乘数矩阵第 $k$ 行第 $j$ 列的乘积的累加（其中$1\\le k \\le n$） 所以上边的运算结果就是$\\begin{pmatrix}a1 a1+a2 b3&amp;a1 b2+a2 b4\\\\a3 b1+a4 b3&amp;a3 b2+a4 b4\\end{pmatrix}$ ！！ 学这东西有什么用呐？一个非常重要的作用就是优化（加速）递推，一般能将线性的递推优化到 $\\log(n)$级别，极度实用。 要发挥这一作用，我们可以定义一种名为 $matrix$ 的结构体，里边存的是个二维数组 $num$ ，这就是矩阵里的值了。我们可以为矩阵乘法重载运算符（笔者觉得很香），代码如下：12345678910111213141516matrix operator*(matrix x) &#123; matrix c; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; c.num[i][j] = 0; for (int k = 1; k &lt;= n; k++) &#123; c.num[i][j] = (c.num[i][j] + (num[i][k] * x.num[k][j]) % MOD) % MOD; &#125; &#125; &#125; return c; &#125;不妨参照上方定义略加理解，当板子背亦可。 但只有子弹没有枪是不行的，我们需要一个高效的方法帮助递推转移。矩阵优化的基本方略是每次将原来的状态存入矩阵，我们称之为 $ORZ$ ，每次转移时，将 $ORZ$ 乘上一个转移矩阵，我们称之为 $RBQ$ （因为他要被用好多次），使新得的矩阵成为下一个状态，以起到转移状态的目的。如下例是一个快速求斐波那契的矩阵加速： $\\begin{pmatrix}f(n-1)&amp;f(n-2)\\\\0&amp;0\\end{pmatrix}$ 这是 $ORZ$ ，初始矩阵。 $\\begin{pmatrix}1&amp;1\\\\1&amp;0\\end{pmatrix}$ 这是 $RBQ$ ，转移矩阵。 $\\begin{pmatrix}f(n-1)+f(n-2)&amp;f(n-1)\\\\0&amp;0\\end{pmatrix}$ 这是积，也能作为下一个状态。 因为矩阵乘法是满足结合律的，原因我也不懂 （逃 ，所以如果我们要多次乘以这一矩阵，就可以用快速幂优化累乘。矩阵的快速幂如下代码：1234567891011121314matrix quick_pow(matrix b, int k)&#123; if (k == 1) return b; matrix tmp = quick_pow(b, k / 2); //笔者尤其喜欢递归快速幂的写法，毕竟出题人不会恶心到要让人爆栈（？） if (k % 2 == 0) return tmp * tmp; else &#123; return tmp * tmp * b; &#125; //因为我们重载了运算符，所以快速幂变得极为方便&#125;可是，斐波那契毕竟是数论弃子，递推中的弟弟，要是状态一复杂，推导转移方法将会极考验思维。 笔者在此分享自己推导转移矩阵的方法：假设我们已知有一种函数 $A(x)$ ，符合 $A(0) = 1 , A(1) = 1 , A(N) = X A(N - 1) + Y A(N - 2)(N \\ge 2)$ ，又有函数 $S(x)$ ，符合 $S(N) = A(0)^2 +A(1)^2+……+A(n)^2$ ，给定一个数 $n$，要求 $S(n)$ 。 先将递推过程中需要的量写在初始矩阵 $ORZ$ 的第一行（依据个人喜好和方便确定是那些量），如下S(n-1)\\quad A(n-1)^2\\quad A(n-2)^2\\quad A(n-1)A(n-2) 对于每一项，按照递推式决定这一项在转移后需要进行怎样的变换，需要哪些“原材料”（这种变换要求只使用我们写下的那行数里的元素）。我们以第一项 $S(n-1)$ 为例，对于 $S(n-1)$ ，他要成为 $S(n)$ ，变化方法即：S(n-1)+(X * A(N-1)+Y * A(N-2))^2需要1个 $S(n-1)$ ，$X^2$ 个 $A(N-1)^2$ ， $Y^2$ 个 $A(N-2)^2$ ， $2XY$ 个 $A(n-1)A(n-2)$。 后面几项都可如此推出。 将每一项的变换方法得知后，对于第 $i$ 项，将每一个元素在造下个状态时所需的个数从上向下排在转移矩阵 $RBQ$ 的第 $i$ 列。为什么可以对于一个元素，只讨论他自己是怎么转移，而不用考虑其他项呢？原因显然，毕竟第二个乘数 $RBQ$ 的各列之间互不影响，这一引论可以手推/肉眼观察法得出。对于那些矩阵里空着的位置，我们用 0 补全。得出的矩阵就像这样： \\begin{pmatrix}1&0&0&0\\\\X^2&X^2&1&x\\\\Y^2&Y^2&0&0\\\\2XY&2XY&0&Y\\end{pmatrix} 来看我们的 $ORZ$ ，刚才第 1 行我们仅仅只是填上了几个字母，但他里面的初始状态究竟是什么，还得咱自己去初始化（具体是什么值题干会给），比如这一题，他的初始矩阵就是:\\begin{pmatrix}2&1&1&1\\end{pmatrix} 刚才提到的那道递推题的高清无码代码.avi：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define int long longconst int M = 10007;using namespace std;int n = 4;struct matrix&#123; int num[17][17]; matrix operator * (const matrix x) const &#123; matrix c; memset(c.num, 0, sizeof(c.num)); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; for (int k = 1; k &lt;= n; k++) &#123; c.num[i][j] = (c.num[i][j] + (num[i][k] * x.num[k][j]) % M) % M; &#125; &#125; &#125; return c; &#125;//重载运算符*&#125; ORZ, RBQ;matrix quick_pow(matrix x, int p)&#123; if (p == 1) return x; matrix tmp = quick_pow(x, p / 2); if (p % 2 == 0) return tmp * tmp; else return tmp * tmp * x;&#125;//矩阵快速幂signed main()&#123; int N, x, y; while (~scanf(&quot;%lld%lld%lld&quot;, &amp;N, &amp;x, &amp;y)) &#123; memset(RBQ.num, 0, sizeof(RBQ.num)); ORZ.num[1][1] = 2; ORZ.num[1][2] = 1; ORZ.num[1][3] = 1; ORZ.num[1][4] = 1; RBQ.num[1][1] = 1; RBQ.num[2][1] = x * x%M; RBQ.num[3][1] = y * y%M; RBQ.num[4][1] = 2 * x * y%M; RBQ.num[2][2] = x * x%M; RBQ.num[3][2] = y * y%M; RBQ.num[4][2] = 2 * x * y%M; RBQ.num[2][3] = 1; RBQ.num[2][4] = x%M; RBQ.num[4][4] = y%M; //初始化，有被爽到 matrix ans = ORZ * quick_pow(RBQ, N-1); cout &lt;&lt; ans.num[1][1] &lt;&lt; endl; &#125;&#125; 欧 拉 函 数（ $\\varphi$ ）定义：我们定义 $\\varphi(d)$ 代表着 $d$ 以内的与 $d$ 互质的数的个数，例如 $\\varphi(6)=2$ ，因为 6 之内有 1,5 两个数与它互质。特别的，我们有 $\\varphi(1)=1$ 。 这玩意有好多好多奇奇怪怪的性质：性质0：对于 $n$ 的每个因数 $i$ ，所有 $\\varphi(i)$ 之和等于 $n$（证明？观察归纳法（雾）） 性质0.5：欧拉函数是积性函数，即有 $\\varphi(m\\cdot n)=\\varphi(m)\\cdot \\varphi(n)$ 。 性质1：（终于来了个够格的性质）对于一个质数 $x$ ，$\\varphi(x)=x-1$ （毕竟质数以下的所有数都不得不和他互质/kel）。 性质2：对于一个次方数 $p^k$ （指一个质数 $p$ 的 $k$ 次方的结果，我自己编的QWQ） ，因为他充其量质因子只有 $p$ 一个，所以与他不互质的数只有 $\\left\\{p,2p,3p,\\dots,p^{k-1}p\\right\\}$ 这里 $p^{k-1}$ 个 $p$ 的倍数，故有 $\\varphi(p^k)=p^k-p^{k-1}$ ，提一个 $p^k$ 后稍加变形就有了下面的式子： \\varphi(p^k)=p^k\\cdot\\dfrac{p-1}{p}（可稍加理解，也可以当结论记） 性质3：对于任意一个数 $a$ ，都能写作 $a=p_1^{k _ 1}\\cdot p _ 2^{k _ 2} \\cdot p _ 3^{k _ 3} \\cdots $ 的次方数相乘的形式（类比分解质因式的短除法？），也就是 $a= {\\textstyle \\prod_{i=1}^{n}}p _ i^{k _ i}$ ，又因为性质0.5，欧拉函数是积性函数，所以 $\\varphi(a)= {\\textstyle \\prod_{i=1}^{n}} \\varphi(p _ i^{k _ i})$ ，用性质2又可以把 $\\varphi(p _i^{k _ i})$ 变形成 $p_i^{k_i}\\cdot\\dfrac{p_i-1}{p _ i}$ ，那么我们就有： \\varphi(a)=\\prod_{i=1}^{n} p_i^{k_i}\\cdot\\prod_{i=1}^{n}\\dfrac{p_i-1}{p_i}还记得我们之前 $a$ 是怎么表示的嘛？是了， $a= {\\textstyle \\prod_{i=1}^{n}}p_i^{k_i}$ 。发现什么，我们可以把 $a$ 代入我们推出的式子！也就是说！！！ \\varphi(a)=a\\cdot\\prod_{i=1}^{n}\\dfrac{p_i-1}{p_i}怎么求 $\\varphi$ :和 $\\mathtt{exgcd}$ 一样，求 $\\varphi$ 也有两种方法，下面分别给出： 单点求 $\\varphi$:适用情形：所求数较少，对时间要求高（因为这是一个 $O(\\sqrt{n})$ 的做法）。 做法：依据我们已知的性质3可知，一个数 $a$ 不管他是什么，都满足 $\\varphi(a)=a\\cdot\\textstyle\\prod_{i=1}^{n}\\dfrac{p_i-1}{p_i}$ ，其中 $p_i$ 是 $a$ 的质因子。那我们就根据这一性质，初始化一个 $ans=a$ ,像线性筛素数一样从1枚举到 $\\sqrt{a}$ ，找到每一个质因子，累乘上 $\\dfrac{p_i-1}{p_i}$ 。 为了防止这个 $a$ 本身是质数，导致枚举过程中一次也没更新 $ans$ ，结果返回了错误答案 $ans=a$ ，我们运用性质1，将其修改为 $ans * \\dfrac{p_i-1}{p_i}$ ，最后得到 $ans=a-1$ 。 上代码～：123456789101112131415161718int phi(int n)&#123; int ans = n, m = sqrt(n); for (int i = 2; i &lt;= m; i++) &#123; if (n % i == 0) &#123; ans = ans / i * (i - 1); while (n % i == 0) n /= i; //枚举质因子，之后除去该因子，避免这个因子被多次统计 &#125; &#125; if (n &gt;= 2) ans = ans / n * (n - 1); //特殊处理 return ans;&#125; 线性筛 $\\varphi$ ：适用情形：所求数较多，多次 $O(\\sqrt{n})$ 复杂度不如单次 $O(n)$ 时。 做法：从2到 $n$ 跑循环，找到未 $vis$ 的一个数 $i$ ，则他是质数，将其加入质数表 $prime$ ，将 $\\varphi(i)$ 标为 $i-1$ （性质1）。 再枚举倍数 $j$ ，将这个质数 $i$ 的 $j$ 倍标记为合数，也就是把 $vis$ 标记成1，枚举当前质数表内质数，如果手上这个合数不是一个质数的倍数，那这个合数和这个质数就只能互质。 我们干脆多做点事，求一下他们积的 $\\varphi$ 。 已知两个互质数求他们的积的 $\\varphi$ ？？？想到了什么，性质0.5！！！ 记得吗？ $\\varphi(m\\cdot n)=\\varphi(m)\\cdot \\varphi(n)$ ，那么我们就有 $\\varphi(i\\cdot prime_j)=\\varphi(i)\\cdot \\varphi(prime_j)$ ！！！ 那不互质怎么办？我们提到，不互质，就只能是倍数关系。要是倍数关系的话，手上的这个合数根本没有新质因子增添进来。那么我们可以运用性质3，$a\\cdot\\textstyle\\prod_{i=1}^{n}\\dfrac{p_i-1}{p_i}$ 里的 $i$ 取哪些值不会变（因为质因子不变多），只是前面这个 $a$ 乘了 $prime_j$，这个式子在原先 $\\varphi(i)$ 的基础上乘上了 $prime_j$ ，这就产生了新的 $\\varphi(i\\cdot prime_j)=\\varphi(i)\\cdot prime_j$ ！！！ 注意特判 $\\varphi(1)=1$ ！！！！！ 话不多说，上代码～：1234567891011121314151617181920212223int phi()&#123; phi[1] = 1; for (int i = 2; i &lt;= 1000007; i++) &#123; if (!vis[i]) &#123; prime[++cntp] = i; phi[i] = i - 1; &#125; for (int j = 1; prime[j] &amp;&amp; i * prime[j] &lt;= 1000007; j++) &#123; vis[i * prime[j]] = 1; if (!(i % prime[j])) //case 1：倍数关系 &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else //case 2:互质关系 phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125;&#125; 扩 展 欧 拉 定 理在学扩展之前，这里先提一下欧拉定理来引入主题（工具人）。欧拉定理实则无比简洁，内容如下： a^{\\varphi(k)}≡1 \\pmod k（这里要求 $a,k$ 互质，证明极其麻烦，记结论即可） 还有个叫费马小定理的，写的是 $a^{k-1}≡1 \\pmod k $ ，这里要求的 $k$ 是质数。看出点什么了吗，是呐，费马小定理就是欧拉定理的一种特殊情况，在 $k$ 是质数这种情况下， $\\varphi(k)$ 也就成了 $k-1$ 。 然而这并不是今天的重点，我们还是得请出今天的主角——扩展欧拉定理！ 我们先来看看这个定理长什么样~ a^b≡\\begin{cases}a^{b \\bmod \\varphi(m)}& (\\gcd(a,m)=1)\\\\a^b&(b \\begin{vmatrix}1&2&3\\ \\|&11\\\\2&2&1\\ \\|&11\\\\3&4&1\\ \\|&19\\end{vmatrix}其目的是将这个矩阵变换成下面的模样以求解： \\begin{vmatrix}a1&b1&c1\\ \\|&ans1\\\\0&b2&c2\\ \\|&ans2\\\\0&0&c3\\ \\|&ans3\\end{vmatrix}这样我们就可以从矩阵最下面一行逐步推出每一个未知数的解啦！（一行一杀，逐行上推） 我们的思想是先找到哪一行的第 $i$ 个数绝对值最大，将这一行全部换到第 $i$ 行的位置 （这里的 $i$ 从1到 $N$ 枚举），如下图的变换(这里我们找到了第一项系数最大值在第三行我们将第三行换到了第一行的位置），我们称之为操作一。 \\begin{vmatrix}1&2&3\\ \\|&11\\\\2&2&1\\ \\|&11\\\\3&4&1\\ \\|&19\\end{vmatrix}-opt1->\\begin{vmatrix}3&4&1\\ \\|&19\\\\2&2&1\\ \\|&11\\\\1&2&3\\ \\|&11\\end{vmatrix}操作一完成以后，再对于第 $i$ 项进行加减消元，也就是要把他下面的每一行的第 $i$ 项系数全部削成0，称作操作二，如下图： \\begin{vmatrix}3&4&1\\ \\|&19\\\\2&2&1\\ \\|&11\\\\1&2&3\\ \\|&11\\end{vmatrix}-opt2->\\begin{vmatrix}3&4&1\\quad\\|&19\\\\0&1&-\\dfrac{1}{2}\\|&\\dfrac{5}{2}\\\\0&-2&-8\\ \\|&-14\\end{vmatrix}两种操作交替运行，这样最后我们就可以从后往前倒推，求出 $z=1,y=3,x=2$ 辣！ 代码来辣：12345678910111213141516171819202122232425262728293031for (int i = 1; i &lt;= n; i++)&#123; //枚举第i个未知数 int maxx = i; //绝对值最大的项所在行 for (int j = i + 1; j &lt;= n; j++) //从第i行开始往下搜，因为上面的都已经被处理了 &#123; if (fabs(a[j][i]) &gt; fabs(a[maxx][i])) &#123; maxx = j; //打擂台 &#125; &#125; for (int j = 1; j &lt;= n + 1; j++) swap(a[i][j], a[maxx][j]); //全体交换 if (!a[i][i]) //换完以后发现这行要求的未知数前面系数是零 &#123; printf(&quot;No Solution\\n&quot;); //无解，没得搞了 return 0; &#125; for (int j = 1; j &lt;= n; j++)//开消 &#123; if (j == i) continue; //不能拿这一列式子消他自己 double delta = a[j][i] / a[i][i]; //消元时被削那行需要乘/除上的数 for (int k = i; k &lt;= n + 1; k++) a[j][k] -= a[i][k] * delta; //将第i元系数消为0并对应的把系数消掉 &#125;&#125; 这样我们就成功得到了最终我们需要的那个矩阵。在主函数里稍加处理即可。笔者这里采取的是在输出时处理出未知数的值。 1printf(&quot;%.2lf\\n&quot;, num[i][n + 1] / num[i][i]); 高斯消元一种妙用——解异或方程组：先咕咕咕~ 中 国 剩 余 定 理 （$\\mathtt{CRT}$）他解决什么问题：举个例子，有一方程组如右： $\\begin{cases}x≡2\\pmod 3\\\\x≡3\\pmod 5\\\\x≡2\\pmod 7\\end{cases}$ 要求求出最小的 $x$ （这里的模数都应该互质）。对于这种问题，我们写成一个通式如下 $\\begin{cases}x≡a_1\\pmod {m_1}\\\\x≡a_2\\pmod {m_2}\\\\x≡a_3\\pmod {m_3}\\end{cases}$ 解决的步骤： 计算出一个 $M=m_1\\cdot m_2\\cdots m_n$ 。 开一个 $RBQ$ 数组（老数组名了），对于每个 $RBQ_i$ ，有 $RBQ_i=\\dfrac{M}{m_i}$ （即除了 $m_i$ 以外的所有 $m$ 的积），再求出每一个 $RBQ$ 的在 $\\bmod m_i$ 意义下的逆元 $RBQ_i^{-1}$ （有时并不用开数组， $RBQ$ 也可即造即用(雾））。 那么我们所求的 $x$ 就有（不用害怕原数乘逆元等于一，因为一个是在实数域上，一个是在模 $m_i$ 意义下）： x=a_1\\cdot RBQ_1 \\cdot RBQ_1^{-1}+a_2\\cdot RBQ_2 \\cdot RBQ_2^{-1}+\\cdots 为什么这么做是对的：对于每一行式子的一个 $m_i$ ，我们有两种情况： $Case 1(j\\neq i)$ a_j\\cdot RBQ_j \\cdot RBQ_j^{-1}≡0\\pmod {m_i}因为 $RBQ_j$ 一定是 $m_i$ 的倍数，它本来就是包括 $m_i$ 在内的几个 $m$ 乘起来的结果。 $Case 2(j= i)$ a_j\\cdot RBQ_j \\cdot RBQ_j^{-1}=a_i\\cdot RBQ_i \\cdot RBQ_i^{-1}这不必说。 a_i\\cdot RBQ_i \\cdot RBQ_i^{-1}≡a_i\\pmod {m_i}我们都知道的 $RBQ_i \\cdot RBQ_i^{-1}\\pmod {m_i}$ 他就是1，那这个式子自然成立。 了解了上面两种情况，那么证明就极其简单了： \\sum\\limits_{k=1}^n a_k\\cdot RBQ_k \\cdot RBQ_k^{-1}≡a_i \\pmod {m_i}也就是说让 $x=\\sum\\limits_{k=1}^n a_k\\cdot RBQ_k \\cdot RBQ_k^{-1}$ 总能完美契合方程组里每一个同余式，对于里面的每一个同余式都能得到相应的余数。 $\\Box$ 代码整点康康:123456789101112131415161718192021222324252627282930void exgcd(int a, int b)&#123; if(b==0) &#123; x = 1; y = 0; return; &#125; exgcd(b, a % b); int tmp = x; x = y; y = tmp - (a / b) * y;&#125;//扩欧求乘法逆元，无需多言 signed main()&#123; int N; cin &gt;&gt; N; for (int i = 1; i &lt;= N;i++) &#123; cin &gt;&gt; m[i] &gt;&gt; a[i]; M *= m[i];//累乘模数 &#125; for (int i = 1;i&lt;=N;i++) &#123; RBQ= M / m[i]; exgcd(RBQ,m[i]);//即造即用RBQ sum_a = (sum_a+a[i] * RBQ * x)%M;//累加a[i]*RBQ*RBQ的逆元 &#125; cout &lt;&lt; sum_a % M &lt;&lt; endl;//具体输出可按题意修改&#125; 扩 展 中 国 剩 余 定 理 ($\\mathtt{EXCRT}$)我们之前提到 $\\mathtt{CRT}$ 解决的问题中方程组的各个模数必须是互质的，可有的问题给出的方程组不一定是互质的，难道这种题就不可做了吗？不慌，我们还有 $\\mathtt{CRT}$ 的进阶与扩展， $\\mathtt{EXCRT}$ ！ 他如何运作：我们举个例子，有一方程组如下： \\begin{cases}x≡a_1\\pmod {m_1}\\\\x≡a_2\\pmod {m_2}\\\\x≡a_3\\pmod {m_3}\\end{cases}我们不妨考虑每次合并第一个方程和第二个方程，而不改变新的方程组求出的解的正确性，最后直至消到只剩一个方程，就可以轻松出结果。那么怎么合并呢，我们挑出两方程来看： \\begin{cases}x≡a_1\\pmod {m_1}\\\\x≡a_2\\pmod {m_2}\\end{cases}把同余式化成等式的做法我们已经轻车熟路了，我们就有了： x=m_1\\cdot k_1+a_1 =m_2\\cdot k_2+a_2来看右边，我们稍微来一点移项： m_1\\cdot k_1+(-m_2)\\cdot k_2=a_2-a_1我们会觉得这挺像一个同余方程的，想想办法解一下他，要让他可解我们必须让右边变成 $\\gcd (m_1,m_2)$ ，没什么可以阻止我们在等号左右同乘上 $\\dfrac {\\gcd (m_1,m_2)}{a_2-a_1}$ ，由此一来，我们有： m_1\\cdot \\dfrac {\\gcd (m_1,m_2)}{a_2-a_1}k_1+m_2\\cdot \\dfrac {\\gcd (m_1,m_2)}{a_2-a_1}k_2=\\gcd (m_1,m_2)那个大分数也太 $ex$ 了，我们不得不把他换元，分别换成 $K_1,K_2$ 如何： m_1\\cdot K_1+m_2\\cdot K_2=\\gcd (m_1,m_2)漂亮的同余方程， $\\mathtt{exgcd}$ 一波，推出符合的一组 $K_1,K_2$ ，但这不是我们需要的小 $k$ ，不妨一波返场，对大 $K$ 再乘回 $\\dfrac {a_2-a_1}{\\gcd (m_1,m_2)}$ ，那没事了，我们这就知道了 $k_1$ 的一个可以的值，把他代回到 $x=m_1\\cdot k_1+a_1$ ，我们就暂时知道了一个 $x$ 。 别急，我们还没有做完，这个 $x$ 只能算是局部解，我们应该记得我们此行的目的是把前面两个方程合并到一个方程，怎么搞，我们需要知道新 $a_1$ 和新 $m_1$ ，新 $m_1$ 怎么想都应该知道该是旧 $m_1$ 和旧 $m_2$ 的 $\\operatorname{lcm}$，我们用 $\\dfrac {m_1\\cdot m_2}{\\gcd(m_1,m_2)}$ 可以算出最小公倍数（我想这个应该都知道的），那么对于新 $a_1$ ，求之前我们需要知道一个有趣的定理： x_{common}=x_{special}+ i\\cdot \\dfrac {m_2}{\\gcd(m_1,m_2)}（这其实不能叫定理了，笔者对其根据本题情况稍加修改， $x_{common}$ 指的是 $x$ 的通解，我们之前用的是 $K$ ， $x_{special}$ 指的是 $x$ 的特解， $i$ 是随意的一个正整数， $m_1,m_2$ 正如先前所设） 应该会有人还记得，我们要求的 $K$ 的解，也就是这里的 $x$ ，他本该是个什么，是了， $\\dfrac {\\gcd (m_1,m_2)}{a_2-a_1}k_1$ （是我们嫌他太 $ex$ 才把他换元的） ，那么是时候把他换回来， $x_{special}$ 肯定是不能动了，毕竟我们好不容易才把他求出来，那么 $x_{common}$ 呢，我们尝试变形: k_1=(x_{special}+ i\\cdot \\dfrac {m_2}{\\gcd(m_1,m_2)})\\cdot \\dfrac {a_2-a_1}{\\gcd (m_1,m_2)}这就是 $k_1$ 的通解了，那么再带回 $x=m_1\\cdot k_1+a_1$ ？那么我们又有了: x=m1\\cdot (x_{special}+ i\\cdot \\dfrac {m_2}{\\gcd(m_1,m_2)})\\cdot \\dfrac {a_2-a_1}{\\gcd (m_1,m_2)}+a_1把 $m_1$ 乘进括号里（分配律），再一波变形如下： x=m_1\\cdot x_{special}\\cdot \\dfrac {a_2-a_1}{\\gcd (m_1,m_2)}+ i\\cdot \\dfrac {m_1\\cdot m_2}{\\gcd(m_1,m_2)}\\cdot \\dfrac {a_2-a_1}{\\gcd (m_1,m_2)}+a_1x=m_1\\cdot x_{special}\\cdot \\dfrac {a_2-a_1}{\\gcd (m_1,m_2)}+ i\\cdot \\operatorname{lcm}(m_1,m_2)\\cdot \\dfrac {a_2-a_1}{\\gcd (m_1,m_2)}+a_1别的显然都不能动了，我们手上的棋子只有 $i$ 这一颗 ，只能说 $x$ 的大小取决于 $\\operatorname{lcm}(m_1,m_2)$ 前面的系数，等等，$\\operatorname{lcm}(m_1,m_2)$ 是什么，这不是我们定下来的新 $m_1$ 嘛。看来我们已经离胜利只差一步了。什么时候让 $x$ 有最小解，简单， $i=0$ ，那我们就有： x=m_1\\cdot x_{special}\\cdot \\dfrac {a_2-a_1}{\\gcd (m_1,m_2)}+a_1噫，好了，这个形式怎么看怎么爽，是呢，我们之前不管不顾地让 $i=0$，可 $i$ 的值是不定的，他的背后就是那个模数 $\\operatorname{lcm}(m_1,m_2)$ ，那么最终的式子已经呼之欲出了！ x≡m_1\\cdot x_{special}\\cdot \\dfrac {a_2-a_1}{\\gcd (m_1,m_2)}+a_1 (\\bmod\\operatorname{lcm}(m_1,m_2))这，就是合并了第一第二式的最终式子（呼～）。 不妨对着代码格物致知？：1234567891011121314151617181920212223int EXCRT()&#123; __int128 A1,A2,MOD1,MOD2; //用int128是因为被毒瘤数据爆了long long，千万小心 A1=A[1],MOD1=MOD[1]; //a1,m1整来 for(int i=2;i&lt;=N;i++) A2=A[i],MOD2=MOD[i]; //a2,m2整来 __int128 C=A2-A1,GCD=__gcd(MOD1,MOD2); //换个a2-a1,gcd免得式子太ex exgcd(MOD1,MOD2); //解同余方程 x=((x*C/GCD)%(MOD2/GCD)+(MOD2/GCD))%(MOD2/GCD); //处理一下x，帮助a1出新值 A1=x*MOD1+A1; MOD1=MOD1*MOD2/GCD; //a1,m1各更新 &#125; return A1;&#125; 我NOIp之前再碰数论我就吃奥利给！完结撒花～","categories":[],"tags":[{"name":"“知识”决定命运","slug":"“知识”决定命运","permalink":"https://quest233.github.io/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/"}]},{"title":"浅谈简单数据结构","slug":"浅谈简单数据结构","date":"2021-04-17T05:33:28.000Z","updated":"2021-04-17T08:14:33.403Z","comments":true,"path":"2021/04/17/浅谈简单数据结构/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"是鬼畜数据结构专题～ 我是不会告诉你我打前两次NOIP/CSP的时候对这些东西都一无所知的（雾）。 这些有（du）趣（liu）的数据结构题往往伴随着各种鬼畜操作，各种诡异询问。毕竟裸的板子题越来越少了（哭），还是应该灵活运用。 分 块蛮好打的数据结构，算是里面比较不毒瘤一点的了，理解也不难，下面稍微讲解一下他的思想。 基本思想？有一区间长为 $n$ ，我们把他分成 $\\sqrt{n}$ 个块，那由此一来每个块里就有 $n\\div \\sqrt{n}=\\sqrt{n}$ 个数（倘若不能整分，就在末尾保留一个元素个数不满 $\\sqrt{n}$ 的零头块），在处理过程中我们遵循“多块拆分处理，整块直接处理，零块暴力处理”的策略，以区间修改为例，我们先来体味一下这句话的意思。 我们把整条序列比作一个国家，分出的几个块比作城市，进行的修改比作 $\\color{red}\\colorbox{white}{政策}$ （zzmg警告）。 给出政策实行的范围在 $l,r$ 之间，要在这个范围里实施“羟基计划”（草）。我们想采用分块，怎么做？ 下面三层情况： $Case 1:$不多不少的一块，即这个政策正好坐落在一个城市上（惨 城市 惨），对于城市里的每个学生，我们不用一个一个告知“羟基计划”实行了。我们只要在政府网上发个公告，也就是在块上打个 $tag$ ，修改整块的有关信息（比如 $sum$ ），表示这个块里的元素被修改了，这样我们就不用把这一政策下放到个人，有效地减小了复杂度。 $Case 2:$国家打算对一个城市的部分人实施这一政策（\\jk），那我们发公告的法子就行不通了（有误伤可能）。怎么搞，暴力即可，封顶 $\\sqrt{n}$ 的工作量我们还承受不了嘛？直接告诉个人，你被选入了“羟基计划”（\\kel）。我们甚至还可以再贪一把，如果政策在这个城市的受众面实在太广（指修改的元素多于 $\\dfrac{\\sqrt{n}}{2}$ ），也可以用发公告公布政策的施行方法，再悄悄告诉那些实则不参加计划的学生，他们是破格生（\\fad）。比如先在块的总和上加上（参与羟基计划的人数* 1）， $tag+1$ ，再对那些其实不用加的元素暴力 $-1$ 。 $Case 3:$国家打算大面积施行“羟基计划”（危）。范围包含许多连续的”试点城市“和许多不在“试点城市”的“试点人”（自己编的）。怎么搞？我们已经知道了对单城市和城市内个人的操作套路，那我们把这个长区间拆分成一些整块和一些零块，对于这些东西分别按 $Case 1,2$ 的套路处理即可。 实现？好写即正义！一些细节需要稍加注意： 可以预处理一下每一个程序位于哪一块内，以及每个块的左右界。我们以一道单点修改、区间查询最大值的题为例，实现如下（这里的处理方法还是挺值得玩味的，可以用特殊值帮助记忆？）：12345678910111213141516171819202122void pre()&#123; sqr=sqrt(n); m=n/sqr; for(int i=1;i&lt;=n;i++) &#123; block[i]=(i-1)/sqr+1;//预处理所在块 if(num[maxx[block[i]]]&lt;num[i]) maxx[block[i]]=i;//预处理MAX &#125; for(int i=1;i&lt;=m;i++) &#123; L[i]=(i-1)*sqr+1; R[i]=i*sqr;//预处理左右界 &#125; if(n%sqr) &#123; L[m+1]=R[m]+1; R[m+1]=n;//预处理最后的零头块上下界 &#125;&#125; 珂以定义两种 $\\operatorname{check}$ 函数，(1)对应块内个体处理（$Case 2$），(2)对应全部处理（$Case 3$），(2)在运行中会调用(1)来处理他分出的散块情况。 $\\operatorname{check}$ 也是如此。这里放一份区间加的部分代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344void update_2(int l,int r,int v)//Case 2&#123; if((r-l+1)&gt;(R[block[l]]-L[block[l]]+1)&gt;&gt;1) &#123;//超过一半就处理另外一半，贪一把 for (int i = L[block[l]]; i &lt; l;i++) &#123; num[i] -= v; &#125; for (int i = R[block[r]]; i &gt; r;i--) &#123; num[i] -= v; &#125;//告知另外一半破格生 &#125; else &#123; for (int i = l; i &lt;= r;i++) &#123; num[i] += v;//告知计划内的人 &#125; &#125; sum[block[l]] += v * (r - l + 1); //发公告&#125;void update_1(int l,int r,int v)&#123; if(block[l]==block[r]) &#123; update_2(l, r, v); &#125;/检测到Case 2，块内处理 else//Case 3 &#123; update_2(l, R[block[l]], v); update_2(L[block[r]], r, v); //边角部分采用Case 2策略 for (int i = block[l] + 1; i &lt; block[r];i++) &#123; tag[i] += v; sum[i] += v * (R[i] - L[i] + 1); //发公告 &#125; //整块部分采用Case 1策略 &#125;&#125; 数据结构的题目还是尽量多写函数，否则会 很 难 调！！！（血的教训） 。 这里放一份分块经典代码，主函数部分还是诸位视题目而写～123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1e6 + 7;const int MAXN = 1e3 + 7;#define int long longint L[MAXN], R[MAXN], sum[MAXN], tag[MAXN];int block[MAX], num[MAX];int n, m, M, sqr;int mode;void pre()&#123; sqr = sqrt(n); m = n / sqr; for (int i = 1; i &lt;= n; i++) &#123; block[i] = (i - 1) / sqr + 1; sum[block[i]] += num[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; L[i] = (i - 1) * sqr + 1; R[i] = i * sqr; &#125; if (n % sqr) &#123; L[m + 1] = R[m] + 1; R[m + 1] = n; &#125;&#125;int check_2(int l, int r)&#123; int res = 0; if ((r - l + 1) &gt; ((R[block[l]] - L[block[l]] + 1) &gt;&gt; 1)) &#123; res = sum[block[l]]; for (int i = L[block[l]]; i &lt; l; i++) res -= num[i] + tag[block[i]]; for (int i = r + 1; i &lt;= R[block[l]]; i++) res -= num[i] + tag[block[i]]; &#125; else &#123; for (int i = l; i &lt;= r; i++) &#123; res += num[i] + tag[block[i]]; &#125; &#125; return res;&#125;int check(int l, int r)&#123; int res = 0; if (block[l] == block[r]) &#123; res = check_2(l, r); &#125; else &#123; res += check_2(l, R[block[l]]); res += check_2(L[block[r]], r); for (int i = block[l] + 1; i &lt; block[r]; i++) &#123; res += sum[i]; &#125; &#125; return res;&#125;void update_2(int l, int r, int v)&#123; if ((r - l + 1) &gt; (R[block[l]] - L[block[l]] + 1) &gt;&gt; 1) &#123; for (int i = L[block[l]]; i &lt; l; i++) &#123; num[i] -= v; &#125; for (int i = R[block[l]]; i &gt; r; i--) &#123; num[i] -= v; &#125; tag[block[l]] += v; &#125; else &#123; for (int i = l; i &lt;= r; i++) &#123; num[i] += v; &#125; &#125; sum[block[l]] += v * (r - l + 1);&#125;void update_1(int l, int r, int v)&#123; if (block[l] == block[r]) &#123; update_2(l, r, v); &#125; else &#123; update_2(l, R[block[l]], v); update_2(L[block[r]], r, v); for (int i = block[l] + 1; i &lt; block[r]; i++) &#123; tag[i] += v; sum[i] += v * (R[i] - L[i] + 1); &#125; &#125;&#125;signed main()&#123; return 0;&#125; 树 状 数 组极其好打又极其难懂的数据结构，能解决绝大部分的单点修改、区间查询的题目，但是在笔者理解不能的年代，这东西是真的噩梦。所以笔者这里尽量描述得易于理解～（说句闲话：据不可靠消息，在某次浴谷网校的课上，当一位学生提问树状数组的原理是，LXL当场谔谔） 令人谔谔的思想我们树状数组运用的思想主要是前缀和的思想，数组如其名，其结构层次就像一棵树，节点保存的都是一个区间的前缀和。就像下面这样： 这是一个树状数组保存值的方式，发现了吗， $A$ 数组里保存的值往往都是一个部分的值，这也就是他能做到高效区间求和（往往是 $\\log{N}$ 级别）的奥秘。看上去就像一场不太公平的比赛？（雾） 我们干脆拿这种有保送资格的 公 平 竞 争 来举例子。 诡异的存储方式必然带来了诡异的操作方法，如何得知一个选手晋级后要参加的下场比赛成了处理的一大问题，我们来康康图上。 以 $1$ 为例，他从 $1$ 出发，下一场比赛在 $2$ 号位置，两个位置相差 $1$ 。再从 $2$ 出发，下一场比赛在 $4$ ，两个位置相差 $2$ 。再到 $8$ ，走 $4$ 步。$1$ 走一步， $2$ 走两步，$4$ 走四步？很难找出规律。 考虑从构建树状数组的方法入手吧， $1$ 所表示的区间位于赛程树的第一层， $3$ 表示的区间也在第一层，还有 $5$ 和 $7$ ，他们的下一场比赛都是在下一个位置。他们有什么共同特点，没错，都是奇数。奇数在二进制下表现的通性是什么？没错，表示 $2^0$ 的那一位上都是 $1$ 。 或许我们已经看出一点端倪了，同样的， $2$ 和 $6$ 位于赛程树的第二层，他们的下一场比赛在 $2$ 步之后， $2$ 和 $6$ 的二进制有什么特性?没错，表示 $2^0$ 的一位上是 $0$ ，但表示 $2^1$ 的一位上是 $1$ 。 我知道了（，但你出言不逊是）！下一场比赛与当前的距离，就是当前位置编号在二进制下，最靠后的不是 $0$ 的位置所表示 $2$ 的次幂值！那我们就有了这样的图： （字有点小？） 怎么快速得到这个距离？有一个奇技淫巧或许是一种方法。 $\\operatorname {lowbit}(a)=a\\And-a$ 。这样可以取到 $a$ 最靠后的非 $0$ 位（为什么？好像有用到计算机补码的知识，笔者初赛从来都是挨打，我不会）。 知道了每名选手要打什么比赛，我们现在要对选手实力进行调整了，调整了一个选手的实力，必然会对他之后要打的比赛的格局产生影响（也就是改变了其它包含他的区间的值），所以我们要进行 $\\log{N}$ 的单点修改（别觉得亏，为了区间查询的效率，这里的复杂度还是值得牺牲的），也就是修改所有他要打的比赛。具体做法就是从修改点 $pos$ 往上跳 $\\operatorname{lowbit}$ ，直到 $pos \\geq N$ 。 12345678void update(int x, int k)&#123; while (x &lt;= N) &#123; tree[x] += k;//修改比赛格局 x += lowbit(x);//跳lowbit &#125;&#125; 接下来才是树状数组的绝妙之处—— $\\log{N}$ 区间查询，其实理解了前缀和的思想就很容易了，无非是 $r$ 的前缀和减上 $l-1$ 的前缀和。单点前缀和在树状数组上怎么求？其实是单点修改的反向，从 $pos$ 往下跳 $\\operatorname{lowbit}$ ，直到 $pos \\leq 0$ 。 12345678910111213141516171819int query(int x)&#123; int res = 0; while (x &gt; 0) &#123; res += tree[x];//总和加上这个位置表达的前缀和 x -= lowbit(x);//跳lowbit &#125; return res;&#125;/*然后主函数里调用时是这样的*/if (s == &quot;Query&quot;)&#123; int fr = read(); int to = read(); cout &lt;&lt; query(to) - query(fr - 1) &lt;&lt; endl; //前缀和传统艺能&#125; 希望加深记忆的读者也可以在树状数组上跑一跑，模拟一下，康康是不是这么回事。 有一说一，这代码真的好打下面是一道单点修改，区间求和的板子题代码～ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 200007;int N, M, tree[MAX];int lowbit(int x)&#123; return x &amp; (-x);&#125;void update(int x, int k)&#123; while (x &lt;= N) &#123; tree[x] += k; x += lowbit(x); &#125;&#125;int query(int x)&#123; int res = 0; while (x &gt; 0) &#123; res += tree[x]; x -= lowbit(x); &#125; return res;&#125;int read()&#123; int bj = 0, num = 0; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == &#x27;-&#x27;) &#123; bj = 1; &#125; ch = getchar(); &#125; while (isdigit(ch)) &#123; num = num * 10 + ch - &#x27;0&#x27;; ch = getchar(); &#125; return bj ? -num : num;&#125;int main()&#123; int T = read(); for (int j = 1; j &lt;= T; j++) &#123; memset(tree, 0, sizeof(tree)); N = read(); for (int i = 1; i &lt;= N; i++) &#123; int num = read(); update(i, num); &#125; string s; cout &lt;&lt; &quot;Case &quot; &lt;&lt; j &lt;&lt; &quot;:&quot; &lt;&lt; endl; while (cin &gt;&gt; s &amp;&amp; s != &quot;End&quot;) &#123; if (s == &quot;Add&quot;) &#123; int p = read(); int num = read(); update(p, num); &#125; if (s == &quot;Sub&quot;) &#123; int p = read(); int num = read(); update(p, -num); &#125; if (s == &quot;Query&quot;) &#123; int fr = read(); int to = read(); cout &lt;&lt; query(to) - query(fr - 1) &lt;&lt; endl; &#125; &#125; &#125;&#125; 三 $\\operatorname{while}$ 怒切绿/蓝/紫题。 线 段 树极其难打且难调的数据结构，但是可以处理的操作和询问却极其广泛（毕竟能力越大，责任越大）。思想是不难的，起码比树状数组简单（确信）。 就这思想还是那样，我们依旧拿“羟基计划”来说事。（zzmg警告） 线段树，结构如其名，像树一样。对于他内部的存储方式，向来百家争鸣。我们可以理解为构建各级机构的过程。笔者在这里推出一种最为风靡且作者本人认为最优的的建树方式： 建树方法：结构体指针配合位运算装B法：先把图上了！ 这里的 $\\mathtt{number}$ 数组是我们要存的值们，也就是对各人的“羟基计划”的各种方案。 $\\mathtt{tree}$ 是我们最终建好的庞大的官僚体系 （八月肃反名单警告）。这里很容易看出，线段树是一个以空间换时间的典型数据结构。 体系上，每一个叶子节点都是针对于一个人的方案，每一个非叶子节点都是一个官员，负责一个区间。我们规定一个官员结点 $x$ 管辖的两个儿子（儿子可能是个人，也可能是另一个官员），他们所在的地址分别位于 $\\mathtt{tree}$ 数组的 $2x$ 与 $2x+1$ ，用位运算装波小b，就是 $x&lt;&lt;1$ 和 $x&lt;&lt;1|1$ 。（据说是会快的） 我们这样来表示一些变量，一个结点有关的值有：$ls$：左儿子的编号， $rs$：右儿子的编号， $val$ ：值（“羟基计划”的方案）。 在实现上，我们采用递归二分的思想，往函数里传一个左边界 $l$ ，一个右边界 $r$ 。每次，我们把这个边界圈出的范围分成两半，对分出的两部分，分别进行递归，继续收缩范围。 还是那句话，递归的终点一定得要设置。如果左右边界合一，很明显，我们把范围收紧到了一格的位置，也就是收缩到了叶子节点上，他属于个人，直接赋值，直接向他告知“羟基计划”，然后 $return$ 走人。 这一部分实现如下： 1234567891011121314151617181920212223242526inline int ls(int x)&#123; return x&lt;&lt;1; &#125;inline int rs(int x)&#123; return x&lt;&lt;1|1;&#125;//左右儿子inline void build(ll now,ll l,ll r)//建树//参数分别为根，左边界，右边界&#123; /*这里可以放一些tag的初始化，现在用不上*/ if(l==r) &#123;//叶子节点，赋值走人 val[now]=num[l]; return; &#125; int mdl=(l+r)&gt;&gt;1;//二分 build(ls(now),l,mdl); build(rs(now),mdl+1,r); //分别处理左右两半部分 /*这里可以放一些整合子节点信息的操作*/ /*我们叫他push_up*/&#125; $\\operatorname{push}$_$\\operatorname{up}$ 是我们整合一个结点俩儿子的信息的操作，也就是官员下访群众收集信息的操作。比如我们要求区间和，我们的 $\\operatorname{push}$ _ $\\operatorname{up}$ 就是使目前的 $now$ 结点的 $val$ 值等于两个子节点的 $val$ 之和。如下： 1234567void update(int pos) &#123; val[pos] = (val[ls(pos)] + val[rs(pos)]); //整合信息 return;&#125; 我们为什么要专门把他放在一个函数里？因为我们之后的操作里还要用到（伏笔～）。 这样建树的优势：建树较有序，使其常数更小（或许？），子结点位置不固定，方便一些操作。 区间修改：一劳永逸懒标记下传法：先谈思想，举个例子，我们要让 1～4 之间的所有人参加“羟基计划”。 我们从根结点（中央JY部） 开始更新，往下走。 树上，JY部有两个子机构，XX省JY厅(1)分管 $1$~$4$，XX省JY厅(2)分管 $5$~$6$ ，我们要修改的区间是 $1$~$4$ ，只只位于 XX省JY厅(1)的管辖范围（即发布“羟基计划”只是厅(1)的任务），所以我们往 XX省JY厅(1)的方向往下走。 XX省JY厅(1)有两个下属， XX市JY局(1)分管 $1$~$2$ ， XX市JY局(2)分管$3$~$4$ 。“羟基计划”与省里每个人都有关系，还记得我们分块的时候对于这种情况是如何操作的嘛？是了，发公告。如果一个部门的管辖区间被我们要修改的目标区间完全包含，我们直接在表示这个管辖区间的非叶子节点（也就是官员结点）上打 $tag$ ，如果还有什么这个管辖区间有关的值，比如 $sum$ 、$max$ ，也一并修改。我们这里就在XX省JY厅(1)上打上标记 那这样被修改的官员结点下属里别的官员呢，比如这里的 XX市JY局(1)和XX市JY局(2) ，我们要进行标记下传的操作了。通俗点说，就是让下面的局(1)局(2) 也得到这个公告。 我们标记下传的这个操作在里面叫做 $\\operatorname{push}$_$\\operatorname{down}$ ，实现是这样的： （提醒：以下的 $sum$ 就是我们之前看到的那个 $val$ ，后面的代码同） 12345678910111213141516inline void work(int x,int lft,int rgt,int tg)&#123; tag[x]+=tg; //tag的传递这样实现 sum[x]+=tg*(rgt-lft+1); //这里以sum为例，是“这个管辖区间有关的值的修改”的一个例证&#125;inline void push_down(int x,int lft,int rgt)&#123; int mdl=(lft+rgt)&gt;&gt;1;//二分 work(ls(x),lft,mdl,tag[x]); work(rs(x),mdl+1,rgt,tag[x]); //对两部分进行tag的传递工作 tag[x]=0; //清空这里的标记，毕竟已经传达给下属了，这里的公告可以销毁了&#125; 修改的全过程只有下传是不够的，我们修改了 $1$~$4$ ，那 $1$~$6$ 这个结点怎么办，很显然，我们需要让 $1$~$6$ 这个结点再次整合他下属的信息，整合信息的做法我记得我们之前提到过，就是所谓的 $\\operatorname{push}$_$\\operatorname{up}$ （伏笔消除！）。所以，一个区间修改就是下面这样： 123456789101112131415161718192021inline void change(int needl,int needr,int lft,int rgt,int x,int tg)//参数特别说明：needl是我们要修改的区间，是不会变的。//lft是我们递归到的左边界，会变。（r同理）&#123; if(needl&lt;=lft&amp;&amp;needr&gt;=rgt) &#123; //完全包含时的有关处理 tag[x]+=tg; sum[x]+=tg*(rgt-lft+1); return; &#125; push_down(x,lft,rgt); //标记下传 int mdl=(lft+rgt)&gt;&gt;1; if(needl&lt;=mdl) change(needl,needr,lft,mdl,ls(x),tg); if(needr&gt;mdl) change(needl,needr,mdl+1,rgt,rs(x),tg); //二分递归，这里要判断这个羟基计划和这个下属到底有没有关系 //就和一开始我们不走XX省JY厅(2)是一个道理 push_up(x); //整合信息&#125; （说句闲话：线段树是有一个公告向下属传达的过程的，而分块直接就是发公告，让下面人自己去看，可见线段树国的官员比分块国负责任） 区间查询：层层递归包括即返回法：笔者个人觉得线段树的区间查询和区间修改还是蛮像的，大体说一下流程： 上级要检查 $4$~$5$ 的“羟基计划”实行情况。 假设我们之前已经在代表 $1$~$4$ 的官员结点上打了一个 $+1\\ tag$ 。 老规矩，如果当前官员结点的管辖区间被完全包含，直接返回，比如我们要求一段区间的 $sum$ ，我们这个时候就应该返回被包含的管辖区间的总 $sum$ 。 我们之前有过很多区间修改的操作，往下走的路其实百废待兴，留了一些 $tag$ 。所以，还是要标记下传，为领导的检查开辟好道路（雾）。 二分我们的目标区间，递归这一操作，每次更新答案，比如我们要求一段区间的 $max$ ，这个时候 $ans$ 就可以等于 max (ans,check(needl,needr,lft,mdl,ls(x)\\ )\\ )应该很好理解的叭（心虚）…… 上个代码品品（区间求和）： 123456789101112131415inline int check(int needl,int needr,int lft,int rgt,int x)&#123; int answer=0;//答案 if(needl&lt;=lft&amp;&amp;needr&gt;=rgt) &#123; return sum[x];//被包含，返回对应区间的sum &#125; push_down(x,lft,rgt); //标记下传 int mdl=(lft+rgt)&gt;&gt;1; if(needl&lt;=mdl) answer+=check(needl,needr,lft,mdl,ls(x)); if(needr&gt;mdl) answer+=check(needl,needr,mdl+1,rgt,rs(x)); //二分递归 return answer;&#125; 就这实现：放一下板子题（线段树1） ，要求区间修改，区间求和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int a[500005], sum[500001], tag[500001];int ls(int x)&#123; return x &lt;&lt; 1;&#125;int rs(int x)&#123; return x &lt;&lt; 1 | 1;&#125;void push_up(int x)&#123; sum[x] = sum[ls(x)] + sum[rs(x)];&#125;void build(int x, int lft, int rgt)&#123; tag[x] = 0; if (lft == rgt) &#123; sum[x] = a[lft]; return; &#125; int mdl = (lft + rgt) &gt;&gt; 1; build(ls(x), lft, mdl); build(rs(x), mdl + 1, rgt); push_up(x);&#125;void work(int x, int lft, int rgt, int tg)&#123; tag[x] += tg; sum[x] += tg * (rgt - lft + 1);&#125;void push_down(int x, int lft, int rgt)&#123; int mdl = (lft + rgt) &gt;&gt; 1; work(ls(x), lft, mdl, tag[x]); work(rs(x), mdl + 1, rgt, tag[x]); tag[x] = 0;&#125;void change(int needl, int needr, int lft, int rgt, int x, int tg)&#123; if (needl &lt;= lft &amp;&amp; needr &gt;= rgt) &#123; tag[x] += tg; sum[x] += tg * (rgt - lft + 1); return; &#125; push_down(x, lft, rgt); int mdl = (lft + rgt) &gt;&gt; 1; if (needl &lt;= mdl) change(needl, needr, lft, mdl, ls(x), tg); if (needr &gt; mdl) change(needl, needr, mdl + 1, rgt, rs(x), tg); push_up(x);&#125;int check(int needl, int needr, int lft, int rgt, int x)&#123; int answer = 0; if (needl &lt;= lft &amp;&amp; needr &gt;= rgt) &#123; return sum[x]; &#125; int mdl = (lft + rgt) &gt;&gt; 1; push_down(x, lft, rgt); if (needl &lt;= mdl) answer += check(needl, needr, lft, mdl, ls(x)); if (needr &gt; mdl) answer += check(needl, needr, mdl + 1, rgt, rs(x)); return answer;&#125;signed main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; &#125; build(1, 1, n); for (int i = 0; i &lt; m; i++) &#123; int opt; cin &gt;&gt; opt; if (opt == 1) &#123; int a, b, k; cin &gt;&gt; a &gt;&gt; b &gt;&gt; k; change(a, b, 1, n, 1, k); &#125; if (opt == 2) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; check(a, b, 1, n, 1) &lt;&lt; endl; &#125; &#125; return 0;&#125; 看过上面思路部分的大体就能懂了（吧？） 珂 朵 莉 树 ($\\mathtt{O\\ D\\ T}$)FBI WARNING:下方可能出现大量暴力片段，无关人员请迅速撤离这里的一部分来自笔者之前的题解吖！ 珂朵莉树是一种比线段树更好打，比树状数组更易理解，比分块更暴力的和树一点关系没有的数据结构，作为一个名字里带树的数据结构，他是用 $set$ 维护的（笑）。 珂朵莉树支持的操作其实不少：区间修改、查找 $k$ 大值、区间赋值、区间询问$\\dots\\dots$其复杂度趋向 $m\\log{n}$ 。为什么？我们随后会讲。我们现在只需要知道，珂朵莉树可以切许许多多标程是线段树的题目，并且时不时爆踩标程（雾）。 先来讲解珂朵莉树的有关思想：珂朵莉树的一个重要思想就是找集合里需要修改的部分推平（暴力的气息），再添加这个被推平区间的新点进入集合。（即把用不着的清除，留下一个新的代表）。而从整个集合里找到需要修改的部分，并对其单独修改，靠的是分裂 $\\operatorname{split}$ ： （注：这个集合里的元素都代表一个区间，用结构体实现） 非常玄学的算法，我们画个图尝试理解流程。 以下 $\\mathtt{poster}$ 是我的结构体名，主要是因为我最初接触 ODT 的时候写的是一道和海报有关的题…… 一、从整个区间里分裂出要修改区间 首先我们需要找到目标位置所在 $\\mathtt{poster}$ 这里我们二分找到下一个 $\\mathtt{poster}$ 的起点。那么下一个 $\\mathtt{poster}$ 对应的迭代器减去 1 ，就是 $pos$ 所在的这个 $\\mathtt{poster}$ 的位置。 将 $pos$ 在的这个 $\\mathtt{poster}$ 分割成 $l$~$pos-1$ 和 $pos$~$r$ 两个 $\\mathtt{poster}$ 。这样我们就可以单独处理一部分的区间了。具体操作就是直接删掉这整个大块区间，然后再插入两个小块的区间（暴力气息逐渐浓厚）。实现如下～ 123456789101112131415161718192021222324252627282930313233343536373839#define IT set&lt;node&gt;::iterator//纯粹懒得打struct node&#123; int l, r; mutable int val;//我们知道set里的普通元素是不能修改的，这里的mutable可以解决这一问题。 node(int a=0,int b=0,int c=0) &#123; l = a; r = b; val = c; &#125; bool operator &lt;(const node a)const &#123; return l &lt; a.l; &#125;//重载运算符&lt;，便于处理区间时从左到右处理&#125;;set&lt;node&gt; s;IT split(int pos)//将“pos所在 poster ”分裂成“以pos为界线”的两个小 poster&#123; IT it= s.lower_bound(node(pos, 0, 0)); //取下一个 poster 头的位置，也就是“这次要分裂的poster”的右限 if(it!=s.end()&amp;&amp;it-&gt;l==pos) &#123; //他不是最后一段poster（指位置最后），且他自己就是下一个poster的开头 return it;//pos已经在我们“要更改的poster ，即*it”里了//到时候处理“*it自己所在的poster” &#125; it--;//应处理上一个poster，这才是“pos所在的poster” int L = it-&gt;l, R = it-&gt;r, VAL = it-&gt;val; s.erase(it);//这里到下个poster之前的这些位置就先删了 s.insert(node(L, pos-1, VAL)); //将我们删除的这个区间的前半部分（l~pos-1)加入集合 return s.insert(node(pos, R, VAL)).first; //将我们删除的这个区间的后半部分(pos~r)加入集合 //不会有人不知道insert是有pair返回值的，而且返回值的first是插入的位置的吧！(yygq)&#125; 二、暴力给一个区间赋上新值 这才是整个赋值实现里最精彩的部分，不如看一下图。 我们要把 $x-&gt;y$ 赋值成 $val$ ，倘若我们已经把“ $x$ 到他的区间末尾”，“ $y$ 到他的区间头”这两段区间单独分离出来了，他们加在一起就是我们要赋值的区间。 对于这两小块，我们暴力推平他们，暴力插入一个新区间，暴力赋值为 $val$ （毁灭即重建） 这一思想体现在代码里就像下面这样: 12345678910void assign(int l,int r,int val)&#123; IT it2 = split(r + 1), it1 = split(l); //因为我们处理时是默认是左闭右开的区间，所以要找到r+1 //先找r+1防的是分离l的时候不小心把r+1所在区间删了 s.erase(it1, it2); //这段都扬喽 s.insert(node(l, r, val)); //插回一个新代表，代表的val是我们要赋的新值&#125; 三、暴力修改我们的区间 这里的大体思想极其简单：把要修改的部分里的最左边，从他原来所属的 $\\mathtt{poster}$ 分离出来。最右边也从他原来所属的区间分离出来。再把最左边到最右边中间的每一个 $\\mathtt{poster}$ 暴力修改。 （暴力气息扑面而来） 如图： 我们把左边分离出来，右边分离出来，中间的每一段，我们直接修改他的 $val$ 。代码如下： 123456789void update(int l, int r, int k)&#123; IT it2 = split(r + 1), it1 = split(l); //把左右界确定好，以相同的原因先it2再it1 for (IT i = it1; i != it2; i++) &#123; i-&gt;val += k;//暴力修改 &#125;&#125; 就短$\\dots\\dots$ 四、暴力查找区间第k大 这里我们的做法是： $\\operatorname{sort}$ 。 没错，真就 $\\operatorname{sort}$ 。不过既然到了珂朵莉树这里，又要进行一些本地化处理。 我们大体流程是这样的： 取出这段区间里所有 $\\mathtt{poster}$ ，将其化为 &lt;权值，拥有该权值的区间长度&gt; 的 pair ，并存进一个 vector ，也就是对于一个 $\\mathtt{poster}$ 化成一个 make_pair(val,r-l+1) 的元素。 对这个区间暴力 $\\operatorname{sort}$ 。 从 $begin$ 往 $end$ 开搜，每次我们跑过一个元素，就把 $k$ （区间第k大的那个k）减去这个元素的 $second$ ，相当于我们跑过了这些元素，消耗里这么多排名。跑过一个以后，我们看看 $k$ 是不是变得小于 0 。小于0则说明我们跑过头了，那我们刚刚跑过的那个元素，不就是我们要找的嘛， $return$ 了。 实现不难了吧： 12345678910111213141516171819202122int rankk(int l, int r, int k)&#123; vector&lt;pair&lt;int, int&gt;&gt; v;//开vector! IT it2 = split(r + 1), it1 = split(l);//分出左右界 v.clear(); for (IT i = it1; i != it2; i++) &#123; int l = i-&gt;l, r = i-&gt;r, val = i-&gt;val; v.push_back(make_pair(val, r - l + 1)); //权值val，以及“以val为权值的区间”里的单点个数 &#125; sort(v.begin(), v.end()); //violence!!! for (VIT i = v.begin(); i != v.end(); i++) &#123; k -= i-&gt;second; //跑过一个元素 if (k &lt;= 0)//跑过头，也就是找到了 return i-&gt;first; &#125; return -1;&#125; 妙过头了。 我们再来考虑之前的复杂度问题，为什么珂朵莉树可以逼近甚至超越线段树？其实很好解释，我们的 $set$ 里的元素可不是始终有 $N$ 个，我们经过 $\\operatorname{assign}$ 的清除元素留代表的工作，已经在不断地消减我们的工作量，最终这里的工作量是趋于 $\\log{n}$ 的（玄学）。 这里放一下ODT板子题也是其发源地 CF896C （这道题以前是个黑，刚刚变成紫了，呜呜呜～）的完整代码叭。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;using namespace std;#define IT set&lt;node&gt;::iterator#define VIT vector&lt;pair&lt;int, int&gt;&gt;::iterator#define int long longstruct node&#123; int l, r; mutable int val; node(int a, int b, int c) &#123; l = a, r = b, val = c; &#125; bool operator&lt;(const node a) const &#123; return l &lt; a.l; &#125;&#125;;set&lt;node&gt; s;int MOD;int n, m, seed, vmax;IT split(int pos)&#123; IT it = s.lower_bound(node(pos, 0, 0)); if (it != s.end() &amp;&amp; it-&gt;l == pos) &#123; return it; &#125; it--; int l = it-&gt;l, r = it-&gt;r, val = it-&gt;val; s.erase(it); s.insert(node(l, pos - 1, val)); return s.insert(node(pos, r, val)).first;&#125;void assign(int l, int r, int val)&#123; IT it2 = split(r + 1), it1 = split(l); s.erase(it1, it2); s.insert(node(l, r, val));&#125;void update(int l, int r, int k)&#123; IT it2 = split(r + 1), it1 = split(l); for (IT i = it1; i != it2; i++) &#123; i-&gt;val += k; &#125;&#125;int rankk(int l, int r, int k)&#123; vector&lt;pair&lt;int, int&gt;&gt; v; IT it2 = split(r + 1), it1 = split(l); v.clear(); for (IT i = it1; i != it2; i++) &#123; int l = i-&gt;l, r = i-&gt;r, val = i-&gt;val; v.push_back(make_pair(val, r - l + 1)); &#125; sort(v.begin(), v.end()); for (VIT i = v.begin(); i != v.end(); i++) &#123; k -= i-&gt;second; if (k &lt;= 0) return i-&gt;first; &#125; return -1;&#125;int quick_pow(int a, int exp)&#123; if (exp == 1) &#123; return a % MOD; &#125; int tmp = quick_pow(a, exp / 2); if (exp % 2 == 0) &#123; return (tmp * tmp) % MOD; &#125; else &#123; return ((tmp * tmp) % MOD * a) % MOD; &#125;&#125;int powsum(int l, int r, int exp)&#123; IT it2 = split(r + 1), it1 = split(l); int res = 0; for (IT i = it1; i != it2; i++) &#123; int l = i-&gt;l, r = i-&gt;r, val = i-&gt;val; res = (res + (r - l + 1) * quick_pow(val % MOD, exp) % MOD) % MOD; &#125; return res;&#125;inline int rnd()&#123; int ret = seed; seed = (seed * 7 + 13) % 1000000007; return ret;&#125;signed main()&#123; scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;seed, &amp;vmax); for (int i = 1; i &lt;= n; i++) &#123; int num = rnd() % vmax + 1; s.insert(node(i, i, num)); &#125; for (int i = 1; i &lt;= m; i++) &#123; int op = (rnd() % 4) + 1; int l = (rnd() % n) + 1; int r = (rnd() % n) + 1; if (l &gt; r) swap(l, r); int x; if (op == 3) &#123; x = (rnd() % (r - l + 1)) + 1; &#125; else x = (rnd() % vmax) + 1; if (op == 4) &#123; MOD = (rnd() % vmax) + 1; &#125; if (op == 1) &#123; update(l, r, x); &#125; if (op == 2) &#123; assign(l, r, x); &#125; if (op == 3) &#123; cout &lt;&lt; rankk(l, r, x) &lt;&lt; endl; &#125; if (op == 4) &#123; cout &lt;&lt; powsum(l, r, x) &lt;&lt; endl; &#125; &#125; return 0;&#125; 比平衡树好打多了～ 这里友情提醒：珂朵莉树基本上永远不是我们做一道题目的唯一解或者首选项，因为他的复杂度 是 假 的。有可能会被卡（不过出题人如果不刻意卡他应该还好），所以ODT一般是我们的第二屏障，要是正解真的写不出来，还是可以期待暴力碾标算的奇迹的。（逃 终于写完辣！这里列举的只是一些较为基础的数据结构，普及选手顺手拿个1=应该是游刃有余，提高的话，想要往上走走还是要往深里学（或许 第1008行题解撒花～～～","categories":[],"tags":[{"name":"“知识”决定命运","slug":"“知识”决定命运","permalink":"https://quest233.github.io/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/"}]},{"title":"初赛模拟挨打纪实","slug":"初赛模拟挨打纪实","date":"2021-04-17T05:29:00.000Z","updated":"2021-04-17T08:11:04.648Z","comments":true,"path":"2021/04/17/初赛模拟挨打纪实/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E5%88%9D%E8%B5%9B%E6%A8%A1%E6%8B%9F%E6%8C%A8%E6%89%93%E7%BA%AA%E5%AE%9E/","excerpt":"","text":"$\\color{salmon}{\\texttt {放小球：}}$$n$ 球， $m$ 盒 小球是否不同 盒子是否不同 是否允许空盒 相应做法 $\\surd$ $\\surd$ $\\surd$ $m^n$ $\\surd$ $\\surd$ $\\times$ $m!\\cdot {\\small\\texttt{斯二林}}(n,m)$ $\\surd$ $\\times$ $\\surd$ $\\sum_{i=1}^{m} {\\small\\texttt{斯二林}}(n,i)$ $\\surd$ $\\times$ $\\times$ $\\small\\texttt{斯二林}(n,m)$ $\\times$ $\\surd$ $\\surd$ $C_{m+n-1}^{n}$ $\\times$|$\\surd$|$\\times$| $C_{n-1}^{m-1} $ 有关斯二林：$S(N,M)=M\\cdot S(N-1,M)+S(N-1,M-1)$ 对于该式理解：有如今已有 $N$ 个球，放置在 $M$ 个盒中。我们是通过放置第 $N$ 球来达成的这一状态。 能转移到这里的有两种情况。 其一：放这个球是在已经放有球的盒子里，这样的话，盒子数没变过，有 $M$ 个。也就是由 $S(N-1,M)$ 转移来，又考虑到第 $N$ 球有 $M$ 个盒子可以放，故需乘上 $M$ 。 其二：放这个球的时候是新开了一个盒子，这样新盒子数是加 $1$ 得来。也就是由 $S(N-1,M-1)$ 得来。 二者结合即有上式。 对第五行的理解：设第 $i$ 个盒子内球数为 $a_i(a_i\\geq 0)$ 可看作是求 $a_1+a_2+\\cdots +a_m=n$ 的非负整数解的组数。 求这样的方程的非负整数解的组数的算式为： $num=C^{n}_{m+n+1}$ ，故可将该方法迁移到此处。 对第六行的理解：插板法天下第一！ 看作是 $n$ 个球，现要插板将其分成 $m$ 块即可。 那就有 $n-1$ 个间隙，需插 $m-1$ 块板。 $n-1$ 选 $m-1$ ，有 $C^{m-1}_{n-1}$ 种方法。 $\\color{salmon}{\\texttt {期望次数：}}$格式：对XXX（哈希表/有序数组/链表）进行XXX（二分查找/线性探测），等概率情况下，（成功/失败）的（平均查找长度/平均比较次数）为___。 这是什么 要求什么 怎么做 哈希表 线性探测的平均探测次数 $1+\\dfrac{\\small\\texttt{出现冲突的次数之和}}{\\small\\texttt{元素个数}}$ 哈希表 查找成功的平均次数 同上 哈希表 查找失败的平均次数 （下方特讲） 有序数组 二分查找的平均次数 分数形式：分子的递推式为 $D_i=D_{i-1}+\\lfloor\\log_{2} i\\rfloor+1$ ，其中 $D_1$ 为 $1$ 。分母为元素个数。 哈希表查找失败的平均次数：这里有一种非常易于实现的方法，先把线性探测完了以后的哈希表写下来如这样。 0 1 2 3 4 5 6 7 14 空 8 空 11 30 我们要查一个元素，会先看看它本该对应的位置是否有它。 倘若没有，我们会怀疑它是不是因为冲突而顺延了，于是到下一个位置找它。 一直找到一个空位置，我们就可以宣告查找失败了。 可见，查找失败的平均次数和我们 怀疑顺延 的次数有关。 于是，我们可以把一个位置 直到下一个空位的距离 先直接一眼看出，写在数组下方。 0 1 2 3 4 5 6 7 14 空 8 空 11 30 2 1 0 1 0 2 1 但是这只是我们怀疑的次数，我们一开始查它 本该对应的位置 的时候其实也应该算一次查找。所以每一位加一： 0 1 2 3 4 5 6 7 14 空 8 空 11 30 3 2 1 2 1 3 2 再把下面这些加起来，除上元素个数即可。 为什么查找成功的次数和平均探测次数是一样的：其实两者中我们的动作可以看作是一样的，都是先查本位，往下找直到一个可以还没有被占用的位置。 有关二分查找的次数：这个递推式是刚刚花 $5min$ 推出来的，不好证明。 直接定址法是完美哈希 $\\color{salmon}{\\texttt {进制相关：}}$X进制转十进制——加权法：114514_{(6)}----1\\times 6^5+1\\times 6^4+4\\times 6^3+5\\times 6^2+1\\times 6^1+4\\times 6^0 十进制转X进制——短除法： 除以 $base$ 取模，倒序拼接成一个数。 X进制小数转十进制：0.114514_{(6)}--1\\times 6^{-1}+1\\times 6^{-2}+4\\times 6^{-3}+5\\times 6^{-4}+1\\times 6^{-5}+4\\times 6^{-6} 十进制小数转X进制：短乘法，乘 $base$ 取整数部分，正序拼接成一个数。 任意的十进制有限小数，未必也是八进制有限小数。 $\\color{salmon}{\\texttt{ccf}}\\color{salmon}{\\texttt{赞歌：}}$ NOI全称：全国青少年信息学奥林匹克竞赛。 今年是第 32 届IOI，中国队获得了 4 金。 1984年，邓小平 指出：“计算机的普及要从娃娃做起。” CCF 于 1984 年创办全国青少年计算机程序设计竞赛（简称：NOI）。故今年是第 37 届，在 长沙 举行。 NOIP的创办时间：1995 年，故今年是第 26 届。 2020年 开始， 除NOIP以外 的NOI系列其他赛事（包括冬令营、CTSC、APIO、NOI）将不再支持 Pascal语言和C语言； 从 2022年 开始，NOIP竞赛也将不再支持 Pascal语言 。即以后只有 C++ 一个了。 竞赛费：0元 。但本着 谁受益谁承担成本 原则，参加竞赛所需的餐饮、住宿、交通、保险等费用由参加者自行承担。 2011年 起，复赛提高组由 一试改为两试 ，分由两天进行。每天竞赛试题由原来的 4题改为3题 。 第一届 APIO 于 2007 年在 澳大利亚 举办。中国第一次承办是在 2010 年。 第一届 NOI 网络同步赛于 1999 年举办。 $\\color{salmon}{\\texttt{图论相关：}}$ 概念 定义 判定 欧拉通路 过图中所有边 恰好一次 且 行遍所有顶点 的通路 1.连通 2.恰有 0个或2个 奇度顶点 欧拉回路（欧拉闭迹） 过图中所有边 恰好一次 且 行遍所有顶点 的回路 1.连通 2. 无 奇度顶点 哈密顿通路 过图中所有顶点 恰好一次 的通路 对于每对不相邻点，$d(u)+d(v)\\geq N-1$ （$N$ 为顶点数， $d$ 为度数） 哈密顿回路 过图中所有顶点 恰好一次 的回路 所有顶点的度数大于等于 $\\frac{N}{2}$ （$N$ 为顶点数） 二分图|能把顶点分成两个集合，且两个集合 内部没有边 的图|没有 奇环的图 有关欧拉回路和欧拉通路：实则可理解为是 从任意一点都能一笔画全图 还是 得从某个特定的起点开始才能一笔画全图 。 有关欧拉回路和哈密顿回路：欧拉回路：需一笔经过全边。 哈密顿回路：只需一笔能串起所有节点即可。 $\\color{salmon}{\\texttt{存图方式：}}$$N$ 点， $M$ 边， $d$ 为一点出度。 存图方式 遍历一点出边 遍历全图 查询单边 跑拓扑/ $dfs$ 效率 邻接矩阵 $O(N)$ $O(N^2)$ $O(1)$ $O(N^2)$ 邻接表 $O(d(N))$ $O(M)$ $O(d(N))$ $O(N+M)$ 链式前向星 同上 同上 同上 同上 为什么邻接表和前向星一样：因为前向星就是一种邻接表。 邻接矩阵中的无效元素个数：有向： $N^2-M\\;$ 无向：$N^2-2M$ $\\color{salmon}{\\texttt{树相关：}}$题型一： 在一棵树中，度为 $1$ 的结点数有 $a_1$ 个，度为 $2$ 的结点数有 $a_2$ 个， $\\dots\\dots$ ，度为 $n$ 的结点数有 $a_n$ 个，则度为 $0$ 的结点数为（）个。 树上的度数指的是其出度。可理解为度为 $K$ 的结点会贡献出 $K$ 个出度。而除根结点外，每个结点都会消耗掉一个出度。要求最后出度消到 $0$ 。则有： $a_0\\cdot 0+a_1\\cdot 1+\\cdots +a_n\\cdot n-(a_0+a_1+\\cdots+a_n-1)=0$ 被减数即贡献出的出度之和，减数即消耗掉的出度之和（这里减 $1$ 是因为根结点不消耗出度）。 题型二： 一棵 $K$ 叉树的结点数为 $N$ ，则它的最小高度为（）。（设根结点深度为 $1$) $K$ 叉树，则第 $x$ 层最多有 $K^{x-1}$ 个结点。 前 $x$ 层就最多有 $\\lfloor\\dfrac{K^x}{K-1}\\rfloor$ 个结点。 则在最后一个结点之前高度就有 $\\lfloor\\log_{K}N(K-1)\\rfloor$ 层。 那他这一层就是第 $\\lfloor\\log_{K}N(K-1)\\rfloor+1$ 层。 _其他的题型都还简单(bushi)_ 先序序列和中序序列相同的二叉树的特征为：空树 或者 任一结点均无左孩子的非空二叉树中序序列和后序序列相同的二叉树的特征为：空树 或者 任一结点均无右孩子的非空二叉树先序序列和后序序列相同的二叉树的特征为：空树 或 仅有一个结点的二叉树 $\\color{salmon}{\\texttt{刚学的几个式子（还不会证）：}}$$\\sum_{i=1}^{n} i^3=\\dfrac{n^2(n+1)^2}{4}$ $\\sum_{i=1}^{n} i^4=\\dfrac{n(n+1)(2n+1)(3n^2+3n-1)}{30}$ 错排：$D(n) = n! [(-1)^2/2! + … + (-1)^{n-1}/(n-1)! + (-1)^n/n!]$ $\\color{salmon}{\\texttt{计算机知识：}}$ 冯诺伊曼的计算机结构的核心思想： 单处理机结构，机器以运算器为中心； 采用程序存储思想； 指令和数据一样可以参与运算； 数据以二进制表示； 将软件和硬件完全分离； 在微机系统中，最基本的输入输出模块BIOS存放在 ROM 里。 想不到吧，RAM 和 外存 也是 输出 设备！ 显存断电后是 不会 保存的。 存储程序工作原理的特点是： 事先编制程序 和 从存储器中依次取出程序自动执行 Fortran 是历史上的 第一种 高级语言，它面向 科学计算 Simula 67 是历史上的第一个支持 面向对象 的语言 Smalltalk 是历史上的第一个 完善的 支持 面向对象 的语言 根据汉字国际GB2312-80的规定，一个汉字的内码码长为 16 bit 汉字区位码 $+2020(H)$ 得国标码，国标码 $+8080(H)$ 得机内码。 一级汉字以 拼音 排序，二级汉字以 偏旁部首 排序 图像分辨率指图像中存储的 信息量 显示分辨率是显示器在 显示图像 时的分辨率 调色板中的颜色数依 颜色深度 而定 $\\color{salmon}{\\texttt{排序相关：}}$时间复杂度分类： $\\qquad n^2\\qquad $ $\\qquad n\\log n\\qquad $ $\\qquad n\\qquad $ $\\qquad$ 奇怪的复杂度$\\;$ 冒、插、选 归（严格）、堆（严格）、快（最优 $O(n)$ ，最劣 $O(n^2)$ ） 桶 计 （ $O(n+w)$ ，$w$ 为值域），希尔（最优 $O(n)$ ，最劣 $O(n\\log^2 n)$，基 _注：也有称希尔平均为 $O(n^{1.5}$)的说法_ 稳定性分类： $\\qquad$稳定$\\qquad$ $\\qquad$不稳定$\\qquad$ 插、冒、计、归、基、桶 选、堆、快、希 即： $n^2$ 除选择都为稳定。 $n\\log n$ 除归并都为不稳定。 $n$ 都为稳定。 就地性分类： $\\qquad$就地$\\qquad$ $\\qquad$不就地$\\qquad$ 插、选、冒、希、快、堆 归、计、基、桶 _注：有的写法的归并是就地的_ 即： $n^2$ 都为就地。 $n\\log n$ 除归并都为就地 $n$ 都为不就地。 其他知识： C++ 的 $\\operatorname{sort}$ 在数据较小的时候能自动转换为 堆排 希尔排序的最后一趟是 插入排序 ，因为希尔本质上就是插入排序的优化算法。 数据几乎有序时：插入、希尔、归并、冒泡 快于 快排 平均 比较次数最少 的是快排。 求第 $k$ 大最低的算法时间复杂度为 $O(n)$ ，由 快排 思想实现。 堆排天下第一！（bushi 优先级：$(\\; ) &gt; \\lnot &gt; \\bigwedge &gt; \\bigvee$","categories":[],"tags":[{"name":"“知识”决定命运","slug":"“知识”决定命运","permalink":"https://quest233.github.io/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/"}]},{"title":"浅谈一类简单置换问题——SP1843 题解","slug":"浅谈一类简单置换问题——SP1843-题解","date":"2021-04-17T04:18:47.000Z","updated":"2021-04-17T08:20:14.115Z","comments":true,"path":"2021/04/17/浅谈一类简单置换问题——SP1843-题解/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E4%B8%80%E7%B1%BB%E7%AE%80%E5%8D%95%E7%BD%AE%E6%8D%A2%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94SP1843-%E9%A2%98%E8%A7%A3/","excerpt":"","text":"推一下蒟蒻 $\\color{salmon}{blog}$ 233~ 这是一道小思维题，有趣还是挺有趣的。 题意见此 ，这里不赘述。 我们都知道，一个置换可以拆成许多个不相交的循环的并，比如 $(^{1\\ 2\\ 3\\ 4} _ {4\\ 2\\ 1\\ 3})$ 就可以拆成 $(^{1\\ 3\\ 4} _ {4\\ 1\\ 3})$ 和 $(^{2} _ {2})$ 。 也就是说，因为每个循环是不相交的，所以我们只要确认 每个循环 是否都能作为一个合法的 两次置换后的情形 。 怎么确保呢，这里有一个小力分讨。 若循环节长度为奇数： 如果这是两次置换后的情形，是一个循环， $i$ 指向 $i+1\\pmod n$ 。 那么我们如何构造出这种置换呢。 认真思尻我们可以构造出这样的氡氡： 我们使 $i$ 指向 $i+\\dfrac{n+1}{2}\\pmod n$ ，由此一来，两次置换后，$i$ 就指向了 $i+n+1\\pmod{n}$ ，也就是 $i+1\\pmod n$ ，那么就是一个循环的形状了～ 换一种解释，我们其实是要构造一种循环移位，使得两次循环移位的总距离 $\\equiv 1\\pmod n$ 这个构造策略可以推广到所有 奇数循环 上，即： 『构造置换为（ $i$ 指向 $i+\\dfrac{n+1}{2}\\pmod n$ ） ，两次置换后可得到该循环。』 那么我们可以说，所有奇数循环都是 合法 的两次置换后的情形了。 若循环节长度为偶数： 我们把一个偶数循环整出来看一看： 我们发现，任何循环移位都不能使两次移位总距离 $\\equiv 1\\pmod n$ ，因为 $kn+1$ 是一个奇数而总距离一定为偶。 那么奇数时的构造策略在这里就不适用了，我们想想别的方法。 如果原来是这样一张图： 移位两次后就变成了这样： 我们发现，如果一个偶数环一开始是 （ $i$ 指向 $i+1$ ）的话，移位两次后原图就会裂开成两个大小为 $\\dfrac{n}{2}$ 的环。 而我们要造偶数环，也只有这一种方法了。 那么我们就可以稍作整理了： 首先，找出最终形态里的所有环。 其次，其中奇数环我们全都可以就地构造，偶数环我们只能通过 大环分裂 得来。那么也就是说，我们所有的偶数环都得是 成对 出现的。 这个很好办，只要为环的大小开个桶，最后查桶内个数 是奇是偶 即可~~~ 这里是瑇码qwq（写的很丑，但是至少能看？）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#define endl &#x27;\\n&#x27;const int MAX = 1e2 + 7;const int MOD = 1e9 + 7;void print(bool a)&#123; cout &lt;&lt; (a ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; endl;&#125;int N;int tong[MAX];int vis[MAX];char S[MAX], T[MAX];char AKIOI[37] = &quot; ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;vector&lt;int&gt; v;signed main()&#123; int t; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; S + 1; v.clear(); memset(vis, 0, sizeof(vis)); memset(tong, 0, sizeof(tong)); memcpy(T, AKIOI, sizeof(AKIOI)); for (int i = 1; i &lt;= 26; i++) &#123; if (vis[i]) &#123; continue; &#125; char tmp = S[i], pos = i; int flag = 0; int cnt = 0; while (S[pos] != tmp || flag == 0) &#123; cnt++; flag = 1; for (int j = 1; j &lt;= 26; j++) &#123; if (S[j] == T[pos]) &#123; pos = j; break; &#125; &#125; vis[pos] = 1; &#125; if (cnt % 2 == 0) &#123; tong[cnt]++; if (tong[cnt] == 1) &#123; v.push_back(cnt); &#125; &#125; &#125; int M = v.size(); int fl = 1; for (int i = 0; i &lt; M; i++) &#123; if (tong[v[i]] % 2 != 0) &#123; print(0); fl = 0; break; &#125; &#125; if (fl) &#123; print(1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://quest233.github.io/tags/solutions/"}]},{"title":"浅谈一类叉点——A Bit Similar 题解","slug":"浅谈一类叉点——A-Bit-Similar-题解","date":"2021-04-17T02:25:40.000Z","updated":"2021-04-18T12:29:01.259Z","comments":true,"path":"2021/04/17/浅谈一类叉点——A-Bit-Similar-题解/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E4%B8%80%E7%B1%BB%E5%8F%89%E7%82%B9%E2%80%94%E2%80%94A-Bit-Similar-%E9%A2%98%E8%A7%A3/","excerpt":"","text":"原题链接qaq 倒垃圾（bushi）： 阴间题，赛时PP了以为稳极，谁知道第二天一早醒来就收到了被叉的噩耗/fn 会被叉的思路： 我一看，$n$ 不超 $1e6$ ，那么我们大可直接枚举子串（ $1e6$ 级别），从而刷出一些“危险”的串，即与某个长度为 $k$ 的子串 没有任何一位相同 的串。 因为这是一个可爱的01串，所以直接取反串即可（这个反串说的是每位 取反 后的串）。 把这些危险串存起来，显然这些串一共也不超过 $1e6$ 个。也就是说，必然存在一个 $20$ 位的 $01$ 串，和这些危险串互异。（ $2^{20}&gt;1e6$ ） 很舒适，那么直接枚举这个 $01$ 串即可。确保了最后 $20$ 位的 “A bit similar” 之后，其它的位上我们就可以 自由发挥 了。 它让我们取最小字典序，那么我们只需在其他位上都填 $0$ 即可。 这太简单了叭，我也能有一天 $1h$ 不到切E题，蛤蛤蛤蛤蛤…… 真的如此吗？ 我为什么又又又又被叉了： 考虑我们“自由发挥”的时候，我们把一些位置填上了 $0$ 。 但是当我们把这些位置填上 $0$ 的时候，是否想过，如果在这里填 $0$ 就可以 防出去一些危险串 的话，那这些被防出去的串是不是就 不危险 了？ 如果这样一个被防出去的串的字典序更小，是不是就可以替换答案了？ 得在原来的瑇码上缝缝补补以应对这种情况。 以下是代码，实现方法在注释里： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 4e6 + 7;int N, M;string s;int dan[MAX];int ok[MAX];void solve(int T)&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; s; int st = max(0, M - 20); //有多长的长度可以自由发挥 string ans = &quot;&quot;; for (int i = 0; i &lt; st; i++) //先全0 &#123; ans += &quot;0&quot;; &#125; if (st &gt; 0) //如果可以自由发挥 &#123; int j = 0; for (int i = 0; i &lt; N; i++) &#123; if (s[i] == &#x27;0&#x27;) &#123; j = max(i - st + 1, j); while (j &lt;= i) //这说明从j到i这块地儿可以直接防出去 &#123; ok[j] = T; //用询问编号作为 ok 的标记是为了珍爱生命远离memset j++; &#125; &#125; &#125; &#125; for (int i = 0; i + M &lt;= N; i++) &#123; if (ok[i] == T) //防出去那就不管了 continue; int cur = 0; for (int j = st; j &lt; M; j++) //否则这个串就是危险子串 &#123; cur = cur * 2 + s[i + j] - &#x27;0&#x27;; //取出这个串 &#125; dan[cur] = T; &#125; for (int mask = 0; mask &lt; (1 &lt;&lt; (M - st)); mask++) //枚举到2^&#123;M-st&#125; &#123; if (dan[mask ^ ((1 &lt;&lt; (M - st)) - 1)] == T) //这是危险的，不能用 //异或上 ((1 &lt;&lt; (M - st)) - 1) 即取出 (M - st) 位以下的部分 continue; cout &lt;&lt; &quot;YES\\n&quot;; cout &lt;&lt; ans; //一些0 for (int i = M - 1; i &gt;= st; i--) //输出和危险串都互异的那个01串 &#123; if (mask &amp; (1 &lt;&lt; (i - st))) &#123; cout &lt;&lt; 1; &#125; else &#123; cout &lt;&lt; 0; &#125; &#125; cout &lt;&lt; &quot;\\n&quot;; return; &#125; cout &lt;&lt; &quot;NO\\n&quot;;&#125;int main()&#123; int T = 1; cin &gt;&gt; T; for (int i = 1; i &lt;= T; i++) &#123; solve(i); &#125; return 0;&#125; 这样你就通过了这道题～ 花絮：","categories":[],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://quest233.github.io/tags/solutions/"}]},{"title":"我走在没有你的夜里冷～冰～冰～","slug":"我走在没有你的夜里冷～冰～冰～","date":"2021-04-17T02:22:31.000Z","updated":"2021-04-18T12:30:55.804Z","comments":true,"path":"2021/04/17/我走在没有你的夜里冷～冰～冰～/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E6%88%91%E8%B5%B0%E5%9C%A8%E6%B2%A1%E6%9C%89%E4%BD%A0%E7%9A%84%E5%A4%9C%E9%87%8C%E5%86%B7%EF%BD%9E%E5%86%B0%EF%BD%9E%E5%86%B0%EF%BD%9E/","excerpt":"","text":"推一下蒟蒻 $\\color{salmon}{blog}$ 。 原题链接qaq _写在最前：本文的代码和官方题解没什么区别，只是加一点个人的解释，权且做一个注脚_ 为数不多的炉石背景题。 难不见得难，就是装腔作势，借以吓人罢了。 广义上看，从题面、赛时过题人数、代码谢特的程度来说，这确实是一道大模拟。 而精确地讲，这是一道伪装成大模拟的大暴搜，思想可能和【NOIP2015 斗地主】类似。 即：『用搜索来决策当前这一步应该干什么，会带来什么后果。』 定义一个 $dfs$ 函数，返回型 $double$ ，表示在 这个局面下操作者的胜率 。 显然这个可以 记忆化 。 先列好我们能在一局中干什么。 用随从攻击 开技能（嘬一口） 打牌（开biubiubiu） 结束回合。 这些操作有优先级的限制吗？ 显然是没有的，我们可以在任何时候嘬一口，也可以在任何时候结束回合。 先看随从攻击这一环节。 一个随从存在两个攻击状态，可以攻击（能动）和不可攻击（不能动）。 同时，他还有两种血量的状态（如果他没有GG的话），一血和两血。 这使我们想到，要保存当前一个玩家的随从场面，需要开四个参数，将血量状态（1/2）和攻击状态（1/0）一一配对，参数的值表示 处于该状态的随从个数 ，定为 $x_{11},x_{10},x_{21},x_{20}$ 。 对于当时对面的场面，我们不关心他们是否能动，就开 $y_1,y_2$ 分别代表 某血量对应的个数 即可。 因为 看了题解 要尽量减小 $dfs$ 函数的谢特程度，我们在 函数传参 时，把一血怪的两种参数压进一个两位数里，十位上是 能动 的一血怪数，个位上是 不能动 的一血怪数，等到函数内部要用值的时候再用 $\\%10$ 或 $\\div10$ 取出来。二血怪同理。（这里笔者换结构体写了一下，发现怎么调也调不出，最后还是向压缩屈服了） 传参： 12345double dfs(int HPx, int HPy, int MINx1, int MINx2, int MINy, int cnt, int cardx, int cardy, int biu) //HPx 我方血量，HPy敌方血量 //MINx1压缩后的我方一血怪情况，MINx2二血，MINy对方情况（十位二血怪数，个位一血怪数） //cnt我方剩余嘬+biubiubiu次数，cardx我方牌数，cardy对方牌数 //这个 biu 比较特殊，他指的是当前是biubiubiu的第几发之后，一会再讲 处理参数： 1234/*MINx1,MINx2,MINy 都是从函数传进来经过压缩的参数*/int x11 = MINx1 / 10, x10 = MINx1 % 10, x21 = MINx2 / 10, x20 = MINx2 % 10;int y1 = MINy % 10, y2 = MINy / 10;int tot = x11 + x10 + x21 + x20 + y1 + y2 + 2;//biubiubiu的总目标数，现在还没用 一个 $k$ 点血且能动的怪要么去交换场面，与对面的随从同归于尽，即 $x_{k1}—,y_?—$；要么直接打脸，攻击对方减 $3$ 点血，即 $x_{k1}—,x_{k0}++,HP_y-=3$ 。 随从攻击： 1234567891011121314151617181920212223242526double prob;//该场面我方胜率......if (x11)&#123; if (y2) &#123; prob = max(prob, dfs(HPx, HPy, MINx1 - 10, MINx2, MINy - 10, cnt, cardx, cardy, 0));//我方失去一个能动一血怪，对方失去一个二血怪 &#125; if (y1) &#123; prob = max(prob, dfs(HPx, HPy, MINx1 - 10, MINx2, MINy - 1, cnt, cardx, cardy, 0));//我方失去一个能动一血怪，对方失去一个一血怪 &#125; prob = max(prob, dfs(HPx, HPy - 3, MINx1 - 9, MINx2, MINy, cnt, cardx, cardy, 0));//打脸，我方一个能动一血怪变成了不能动一血怪，对方HP-3&#125;if (x21)//大致同上&#123; if (y2) &#123; prob = max(prob, dfs(HPx, HPy, MINx1, MINx2 - 10, MINy - 10, cnt, cardx, cardy, 0)); &#125; if (y1) &#123; prob = max(prob, dfs(HPx, HPy, MINx1, MINx2 - 10, MINy - 1, cnt, cardx, cardy, 0)); &#125; prob = max(prob, dfs(HPx, HPy - 3, MINx1, MINx2 - 9, MINy, cnt, cardx, cardy, 0));&#125; 其次是开技能。 嘬一口需要满足三个条件：有技能次数，自己血量高于两血，手牌小于 $3$ 张（一血不慌，二血健康，三血抽口也不伤）。 我们开个 $if$ 判一下就是了。 嘬一口： 123456/*上接随从攻击*/......if (cnt &amp;&amp; HPx &gt; 2 &amp;&amp; cardx != 3)//有技能次数，自己血量高于两血，手牌小于 3 张&#123; prob = max(prob, dfs(HPx - 2, HPy, MINx1, MINx2, MINy, cnt - 1, cardx + 1, cardy, 0));&#125; 终于来到了本题最复杂最宏伟的结构——biubiubiu 了。 一个 biubiubiu 分为三次伤害，两次伤害之间 有结算 。换句话说，不会有伤害落在死人身上。 这启示我们把一个 biubiubiu 拆成三个连续的 单点伤害 来看，只不过在三个伤害之间 玩家不能操作 罢了。 我们令参数 $biu$ 代表当前场面是在第几次 biubiubiu 之后的场面，若为 $1/2$ ，则说明这是一个在 biubiubiu 期间的局面，既然在 biubiubiu 期间，那我们唯一能做的就是枚举下一发落到哪，对所有情况取个平均数以体现伪随机即可。 枚举 biubiubiu： 123456789101112131415161718192021222324252627282930313233343536373839double dv = 1.0 / tot;//求平均数用的分母，tot是总目标数，赋值在“参数处理”部分if (biu &amp;&amp; biu &lt; 3)//若在 biubiubiu 期间 //这个判断在随从攻击和开技能之前&#123; if (biu == 2)//如果这是最后一发 &#123; cardx--; MINx2++;//则放置一个二血随从，手牌-1 &#125; biu = (biu + 1) % 3;//多一发，如果当前是2，会变成0 /*开始枚举伤害位置*/ prob += dv * dfs(HPx - 1, HPy, MINx1, MINx2, MINy, cnt, cardx, cardy, biu); prob += dv * dfs(HPx, HPy - 1, MINx1, MINx2, MINy, cnt, cardx, cardy, biu);//打到人身上 if (x11) &#123; prob += x11 * dv * dfs(HPx, HPy, MINx1 - 10, MINx2, MINy, cnt, cardx, cardy, biu);//打到己方能动一血怪身上，己方少一个能动一血怪 &#125; if (x10) &#123; prob += x10 * dv * dfs(HPx, HPy, MINx1 - 1, MINx2, MINy, cnt, cardx, cardy, biu);//以下同上，读者自行理解 &#125; if (x21) &#123; prob += x21 * dv * dfs(HPx, HPy, MINx1 + 10, MINx2 - 10, MINy, cnt, cardx, cardy, biu); &#125; if (x20) &#123; prob += x20 * dv * dfs(HPx, HPy, MINx1 + 1, MINx2 - 1, MINy, cnt, cardx, cardy, biu); &#125; if (y1) &#123; prob += y1 * dv * dfs(HPx, HPy, MINx1, MINx2, MINy - 1, cnt, cardx, cardy, biu); &#125; if (y2) &#123; prob += y2 * dv * dfs(HPx, HPy, MINx1, MINx2, MINy - 9, cnt, cardx, cardy, biu); &#125; return store_in = prob;//&amp;store_in 是我们存储记忆化结果的位置，您也可以用其它的方式进行记忆化&#125; 而在非 biubiubiu 期间，我们要开一次 biubiubiu 的条件又是什么呢？手上有牌，剩余出牌次数&gt;0，我方场上随从&lt;=3 。 开一次 biubiubiu ： 123456789101112131415161718192021222324252627282930313233343536/*上接使用技能*/......if (cardx &amp;&amp; cnt &amp;&amp; x11 + x10 + x21 + x20 &lt;= 3)//手上有牌，剩余出牌次数&gt;0，我方场上随从数&lt;=3 &#123; cnt--;//少一次次数 double tmp = 0.0;//临时储存开 biubiubiu 带来的胜率，因为如果胜率不好我们可以干脆不开 /*枚举第一发伤害位置，各语句意义与上一个代码块相同，在此不表*/ tmp += dv * dfs(HPx - 1, HPy, MINx1, MINx2, MINy, cnt, cardx, cardy, 1); tmp += dv * dfs(HPx, HPy - 1, MINx1, MINx2, MINy, cnt, cardx, cardy, 1); if (x11) &#123; tmp += x11 * dv * dfs(HPx, HPy, MINx1 - 10, MINx2, MINy, cnt, cardx, cardy, 1); &#125; if (x10) &#123; tmp += x10 * dv * dfs(HPx, HPy, MINx1 - 1, MINx2, MINy, cnt, cardx, cardy, 1); &#125; if (x21) &#123; tmp += x21 * dv * dfs(HPx, HPy, MINx1 + 10, MINx2 - 10, MINy, cnt, cardx, cardy, 1); &#125; if (x20) &#123; tmp += x20 * dv * dfs(HPx, HPy, MINx1 + 1, MINx2 - 1, MINy, cnt, cardx, cardy, 1); &#125; if (y1) &#123; tmp += y1 * dv * dfs(HPx, HPy, MINx1, MINx2, MINy - 1, cnt, cardx, cardy, 1); &#125; if (y2) &#123; tmp += y2 * dv * dfs(HPx, HPy, MINx1, MINx2, MINy - 9, cnt, cardx, cardy, 1); &#125; prob = max(prob, tmp);//取max cnt++;//恢复次数&#125; 最后就是我们的结束回合操作了。 结束这个回合，我们会得到【1.0-对手下回合胜率】的胜率。 我们如何表示下一个回合中对手的胜率？是不是 以对手为主视角 ，做一次 $dfs$ ，参数如下： 12dfs(HPy, HPx, y1 * 10, y2 * 10, (x21 + x20) * 10 + (x11 + x10), O, min(cardy + 1, 3), cardx, 3) //y1*10，即所有一血怪都被重置为能动状态，y2同理 我们发现这里的 $biu$ 参数居然是 $3$ ，这又代表什么。 其实是高明的THU爷把 $biu$ 同时还当作了一个标记，因为题目里说一个回合不能啥事不干地 空过 ，所以当 $biu=3$ 其实是 还没有执行过操作 的情况。 所以在 $biu=3$ 时，我们将 $prob$ 初始化为 0 ，否则则至少有 【1.0-对手下回合胜率】作为保底。 初始化 prob ： 123456789101112/*上接“是否在biubiubiu期间”的判断*/......if (biu != 3)&#123; prob = 1.0 - dfs(HPy, HPx, y1 * 10, y2 * 10, (x21 + x20) * 10 + (x11 + x10), O, min(cardy + 1, 3), cardx, 3);&#125;else&#123; prob = 0.0;&#125;....../*下接随从攻击*/ 这样我们就有了获取某场面胜率的基本方式，现在我们可以整合起来看看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138double dfs(int HPx, int HPy, int MINx1, int MINx2, int MINy, int cnt, int cardx, int cardy, int biu)&#123; if (HPy &lt;= 0)//若死了人则直接返回 &#123; return 1.0; &#125; if (HPx &lt;= 0) &#123; return 0.0; &#125; double &amp;store_in = dp[HPx - 1][HPy - 1][id_x[MINx2 * 100 + MINx1]][id_y[MINy]][cnt][cardx][cardy][biu];//id_x和id_y都表示：某一种随从场面对应的编号，这个编号当然是自己定的，主要是为了防炸空间 if (store_in == store_in)//现学的高明记忆化 &#123; return store_in; &#125; double prob = 0.0; /*参数处理*/ int x11 = MINx1 / 10, x10 = MINx1 % 10, x21 = MINx2 / 10, x20 = MINx2 % 10, y1 = MINy % 10, y2 = MINy / 10; int tot = x11 + x10 + x21 + x20 + y1 + y2 + 2; double dv = 1.0 / tot; /*biubiubiu期间的判断*/ if (biu &amp;&amp; biu != 3) &#123; if (biu == 2) &#123; cardx--; MINx2++; &#125; biu = (biu + 1) % 3; prob += dv * dfs(HPx - 1, HPy, MINx1, MINx2, MINy, cnt, cardx, cardy, biu); prob += dv * dfs(HPx, HPy - 1, MINx1, MINx2, MINy, cnt, cardx, cardy, biu); if (x11) &#123; prob += x11 * dv * dfs(HPx, HPy, MINx1 - 10, MINx2, MINy, cnt, cardx, cardy, biu); &#125; if (x10) &#123; prob += x10 * dv * dfs(HPx, HPy, MINx1 - 1, MINx2, MINy, cnt, cardx, cardy, biu); &#125; if (x21) &#123; prob += x21 * dv * dfs(HPx, HPy, MINx1 + 10, MINx2 - 10, MINy, cnt, cardx, cardy, biu); &#125; if (x20) &#123; prob += x20 * dv * dfs(HPx, HPy, MINx1 + 1, MINx2 - 1, MINy, cnt, cardx, cardy, biu); &#125; if (y1) &#123; prob += y1 * dv * dfs(HPx, HPy, MINx1, MINx2, MINy - 1, cnt, cardx, cardy, biu); &#125; if (y2) &#123; prob += y2 * dv * dfs(HPx, HPy, MINx1, MINx2, MINy - 9, cnt, cardx, cardy, biu); &#125; return store_in = prob; &#125; /*初始化prob*/ if (biu != 3) &#123; prob = 1.0 - dfs(HPy, HPx, y1 * 10, y2 * 10, (x21 + x20) * 10 + (x11 + x10), O, min(cardy + 1, 3), cardx, 3); &#125; else &#123; prob = 0.0; &#125; /*随从攻击*/ if (x11) &#123; if (y2) &#123; prob = max(prob, dfs(HPx, HPy, MINx1 - 10, MINx2, MINy - 10, cnt, cardx, cardy, 0)); &#125; if (y1) &#123; prob = max(prob, dfs(HPx, HPy, MINx1 - 10, MINx2, MINy - 1, cnt, cardx, cardy, 0)); &#125; prob = max(prob, dfs(HPx, HPy - 3, MINx1 - 9, MINx2, MINy, cnt, cardx, cardy, 0)); &#125; if (x21) &#123; if (y2) &#123; prob = max(prob, dfs(HPx, HPy, MINx1, MINx2 - 10, MINy - 10, cnt, cardx, cardy, 0)); &#125; if (y1) &#123; prob = max(prob, dfs(HPx, HPy, MINx1, MINx2 - 10, MINy - 1, cnt, cardx, cardy, 0)); &#125; prob = max(prob, dfs(HPx, HPy - 3, MINx1, MINx2 - 9, MINy, cnt, cardx, cardy, 0)); &#125; /*嘬一口*/ if (cnt &amp;&amp; HPx &gt; 2 &amp;&amp; cardx != 3) &#123; prob = max(prob, dfs(HPx - 2, HPy, MINx1, MINx2, MINy, cnt - 1, cardx + 1, cardy, 0)); &#125; /*开biubiubiu*/ if (cardx &amp;&amp; cnt &amp;&amp; x11 + x10 + x21 + x20 &lt;= 3) &#123; cnt--; double tmp = 0.0; tmp += dv * dfs(HPx - 1, HPy, MINx1, MINx2, MINy, cnt, cardx, cardy, 1); tmp += dv * dfs(HPx, HPy - 1, MINx1, MINx2, MINy, cnt, cardx, cardy, 1); if (x11) &#123; tmp += x11 * dv * dfs(HPx, HPy, MINx1 - 10, MINx2, MINy, cnt, cardx, cardy, 1); &#125; if (x10) &#123; tmp += x10 * dv * dfs(HPx, HPy, MINx1 - 1, MINx2, MINy, cnt, cardx, cardy, 1); &#125; if (x21) &#123; tmp += x21 * dv * dfs(HPx, HPy, MINx1 + 10, MINx2 - 10, MINy, cnt, cardx, cardy, 1); &#125; if (x20) &#123; tmp += x20 * dv * dfs(HPx, HPy, MINx1 + 1, MINx2 - 1, MINy, cnt, cardx, cardy, 1); &#125; if (y1) &#123; tmp += y1 * dv * dfs(HPx, HPy, MINx1, MINx2, MINy - 1, cnt, cardx, cardy, 1); &#125; if (y2) &#123; tmp += y2 * dv * dfs(HPx, HPy, MINx1, MINx2, MINy - 9, cnt, cardx, cardy, 1); &#125; prob = max(prob, tmp); cnt++; &#125; return store_in = prob;&#125; 然后主函数有手就行（（（ 这里再点两个细节： 有一个有效而可行的剪枝是，在不是 biubiubiu 期间，且当前手上随从 全部打脸 就能赢的时候，直接返回 1.0 。（亲测每个点可以平均-3s） 1234if (HPy &lt;= (x11 + x21) * 3)&#123; return store_in = 1.0;&#125; 记得把 y1 define 掉。/kk 想来想去还是放送一下主函数比较好： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;#define y1 MKANJD#define y0 MAIJBXJdouble dp[20][20][70][15][6][4][4][4];int id_x[4007], id_y[4007];int situa[47] = &#123;0, 1, 2, 3, 4, 10, 11, 12, 13, 20, 21, 22, 30, 31, 40&#125;;//所有可能的随从场面int O;double dfs(int HPx, int HPy, int MINx1, int MINx2, int MINy, int cnt, int cardx, int cardy, int biu)&#123; ......&#125;int read()&#123; int num = 0, bj = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == &#x27;-&#x27;) &#123; bj = -1; &#125; ch = getchar(); &#125; while (isdigit(ch)) &#123; num = num * 10 + ch - &#x27;0&#x27;; ch = getchar(); &#125; return bj * num;&#125;signed main()&#123; /*预处理id_y*/ for (int i = 1; i &lt; 15; ++i) &#123; id_y[situa[i]] = i; &#125; memset(dp, -1, sizeof(dp)); /*预处理id_x*/ int tot = 0; for (int i = 0; i &lt; 15; i++) &#123; for (int j = 0; j &lt; 15; j++) &#123; if (situa[i] / 10 + situa[i] % 10 + situa[j] / 10 + situa[j] % 10 &lt;= 4 &amp;&amp; id_x[situa[i] * 100 + situa[j]] == 0)//场上随从数不到4个的都叫合法 &#123; id_x[situa[i] * 100 + situa[j]] = tot++; &#125; &#125; &#125; int T; T = read(); O = read(); while (T--) &#123; int HPx = read(); int HPy = read(); int minx1 = 0, minx2 = 0, miny = 0;//我方一血怪、二血怪，对方随从 int M; M = read(); for (int i = 1; i &lt;= M; i++) &#123; int K; K = read(); if (K == 1) &#123; miny++; &#125; if (K == 2) &#123; miny += 10; &#125; &#125; M = read(); for (int i = 1; i &lt;= M; i++) &#123; int K; K = read(); if (K == 1) &#123; minx1 += 10; &#125; if (K == 2) &#123; minx2 += 10; &#125; &#125; int card_y = read(); int card_x = read(); printf(&quot;%.9lf\\n&quot;, dfs(HPx, HPy, minx1, minx2, miny, O, min(3, card_x + 1), card_y, 3)); &#125; //老师彩笔！&#125;","categories":[],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://quest233.github.io/tags/solutions/"}]},{"title":"About","slug":"About","date":"2021-04-17T01:42:23.000Z","updated":"2021-04-22T10:24:07.067Z","comments":true,"path":"2021/04/17/About/","link":"","permalink":"https://quest233.github.io/2021/04/17/About/","excerpt":"","text":"强省强校竞赛班垫底选手，来自 HZXJHS，是一个连联赛一等都没有的铁废物。 擅长拉板子，抄题解，贺代码，法斯特，在机房颓文化课，在翻车位开车。 写了一点学习笔记，但是因为太鸽子被长期爆D；写了一些题解，但是因为写一篇需要巨大多时间导致社区贡献几乎为零。 线上人设是啥都不会，胆小怕事的一般路过蒟蒻（线下可能也是）。 最近在颓钢四和多娜多娜 ，头像是明日方舟的蓝毒小姐姐（虽然已退坑多年）。","categories":[],"tags":[{"name":"water","slug":"water","permalink":"https://quest233.github.io/tags/water/"}]},{"title":"浅谈一类简单期望DP—— CF768D Jon and Orbs题解","slug":"浅谈一类简单期望DP——-CF768D-Jon-and-Orbs题解","date":"2021-04-16T21:42:42.000Z","updated":"2021-04-19T03:44:57.407Z","comments":true,"path":"2021/04/17/浅谈一类简单期望DP——-CF768D-Jon-and-Orbs题解/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E4%B8%80%E7%B1%BB%E7%AE%80%E5%8D%95%E6%9C%9F%E6%9C%9BDP%E2%80%94%E2%80%94-CF768D-Jon-and-Orbs%E9%A2%98%E8%A7%A3/","excerpt":"","text":"推一下蒟蒻 $\\color{limegreen}{\\texttt {博客}}$ ～ 原题链接~ 看到楼上下的大佬都开的是二维数组，实则不需，蒟蒻在这里给出一种反复利用一个一维数组的解法 $QwQ$ 。 $\\color{salmon}{\\texttt {先设置状态～}}$ 按着期望 $DP$ 的套路走，设置 $dp_{\\ i}$ 表示：取到 $i$ 件不同的物品，所期望取的天数。 这一设置状态的思路甚至可以延用到 [SHOI2002]百事世界杯之旅 和 收集邮票 两道蓝题里。（说实话，我觉得这道黄题比那两道蓝题不知道高到哪里去了。） $\\color{violet}{\\texttt {再考虑转移～}}$ 我们提到：$dp_{\\ i}$ 代表的状态是 取到了 $i$ 件不同的物品 。 考虑什么情况下会造就这种状态。无非两种： 原来有 $i-1$ 个物品，一发出货，从 $dp_{\\ i-1}$ 转移过来，这样的概率是 $\\dfrac{K-(i-1)}{K}=\\dfrac{K-i+1}{K}$ _注：即卡池（误）里有 $K$ 个物品，自己已经有了 $i-1$ 个，那还有 $K-i+1$ 个是自己没有的，抽这些即能使自己多获得一种物品_ 早就有 $i$ 个物品了，抽一发沉了 （是我没错了） ，从 $dp[i]$ 转移过来，这样的概率是 $\\dfrac{i}{K}$ _注：含义同上_ 那么我们就可以列出一个方程辣： dp[i]=dp[i-1] * \\dfrac{K-i+1}{K}+dp[i] * \\dfrac{i}{K}为了防止爆精写成这样更为稳妥： dp[i]=\\dfrac{dp[i-1] * (K-i+1)+dp[i] * i}{K}随着时间的推移， 每一天 都会面临一次这样的转移，因为每一天的抽卡都存在有出货与不出货的概率。（赌狗一无所有） $\\color{blueviolet}{\\texttt {最后计划转移方式～}}$ 这个式子对于每一天的状态 独立成立 ，说人话就是： 当天 的 $dp_{i-1}$ 不能影响 当天 $dp_i$ 的转移，用来转移 $dp_i$ 的 $dp_{i-1}$ 是 上一天 的 $dp_{i-1}$ 。 存在一种感性理解就是：我今天抽卡的卡池，实则用的是我 昨天 抽完以后的卡池。 那么，为了防止 $dp_{i-1}$ 的更新影响 $dp_{i}$ 的更新，我们选择 倒序跑 $for$ 。 记录第 $d$ 天抽满 $K$ 个物品的概率，即当时的 $dp_{\\ K}$ 。存这个值于 $ans_{\\ d}$ 最后对于每一个询问，扫一遍 $ans$ ，找到最小的 $d$ 满足条件，输出即可。 $\\color{royalblue}{\\texttt {代码如下：}}$ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const long double EPS = 1e-8;const int MAX = 1e3 + 7;long double dp[MAX];long double ans[MAX &lt;&lt; 3];//楼上大佬已经证过，最大的期望天数跑不出 1000*ln(1000) //这里用*8 代替 *ln(1000)int main()&#123; int K, M; cin &gt;&gt; K &gt;&gt; M; dp[0] = 1.0; for (int i = 1; i &lt;= 8000; i++) &#123; for (int j = K; j &gt; 0; j--)//倒序扫 &#123; dp[j] = (dp[j - 1] * (K - j + 1) + dp[j] * j) / (K * 1.0); //转移 &#125; ans[i] = dp[K];//记录 dp[k] dp[0] = 0; &#125; while (M--) &#123; int p; cin &gt;&gt; p; for (int i = 1; i &lt;= 8000; i++) &#123; if (ans[i] * 2000 &gt;= p - EPS)//防炸精写法 &#123; cout &lt;&lt; i &lt;&lt; &quot;\\n&quot;; break; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://quest233.github.io/tags/solutions/"}]},{"title":"浅谈钬钊钶镭后缀和——「MCOI-02」Convex Hull 凸包 题解","slug":"浅谈钬钊钶镭后缀和——「MCOI-02」Convex-Hull-凸包-题解","date":"2021-04-16T21:39:03.000Z","updated":"2021-04-21T14:09:20.200Z","comments":true,"path":"2021/04/17/浅谈钬钊钶镭后缀和——「MCOI-02」Convex-Hull-凸包-题解/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E9%92%AC%E9%92%8A%E9%92%B6%E9%95%AD%E5%90%8E%E7%BC%80%E5%92%8C%E2%80%94%E2%80%94%E3%80%8CMCOI-02%E3%80%8DConvex-Hull-%E5%87%B8%E5%8C%85-%E9%A2%98%E8%A7%A3/","excerpt":"","text":"推一下蒟蒻 $\\color{green}{\\texttt{博客}}$ ～ 原题链接~ 粗略捞了一眼题解区，觉得有些比较重要的细节不是很懂，自己瞎撞撞终于搞明白乐。/kk 所以本篇文章用于解释一些思维上的细节。 一、$\\tau*\\mu=1 $ ?我们了解到 $\\sum_{d|n} \\mu(d)\\cdot 1=[n=1]$ ，表达成卷积形式有： 1*\\mu=\\epsilon而当我们展开 $\\tau$ 可得： \\tau(n)=\\sum_{d|n} 1\\cdot 1 \\tau=1*1等式两边同卷 $\\mu$ ： \\tau*\\mu=1*1*\\mu用 $\\epsilon$ 换 $1*\\mu$ ： \\tau*\\mu=1*\\epsilon因为 $1*\\epsilon=1$ ，所以我们就证得了： \\tau*\\mu=1二、大众推柿子思路_默认 $n&lt;m$_ \\sum^{n}_{i}\\sum^{m}_{j}\\tau(i)\\tau(j)\\tau(\\gcd(i,j)) =\\sum_{d}^{n}\\tau(d)\\sum^{n}_{i}\\sum^{m}_{j}\\tau(i)\\tau(j)[\\gcd(i,j)=d]\\quad\\texttt{随手枚举gcd} =\\sum_{d}^{n}\\tau(d)\\sum^{\\lfloor\\frac{n}{\\color{red}d}\\rfloor}_{i}\\sum^{\\lfloor\\frac{m}{\\color{red}d}\\rfloor}_{j}\\tau(i{\\color{red}d} )\\tau(j{\\color{red}d})[\\gcd(i,j)={\\color{red}1}]\\quad\\texttt{随手除d} =\\sum_{d}^{n}\\tau(d)\\sum^{\\lfloor\\frac{n}{\\color{red}d}\\rfloor}_{i}\\sum^{\\lfloor\\frac{m}{\\color{red}d}\\rfloor}_{j}\\tau(i{\\color{red}d})\\tau(j{\\color{red}d}){\\color{green}\\sum_{k|\\gcd(i,j)}\\mu(k)}\\quad\\texttt{随手套} \\mu \\texttt{性质} =\\sum_{d}^{n}\\tau(d){\\color{green}{\\sum_{k}^{n}\\mu(k)}}\\sum^{\\lfloor\\frac{n}{\\color{red}d\\color{blue}k}\\rfloor}_{i}\\sum^{\\lfloor\\frac{m}{\\color{red}d\\color{blue}k}\\rfloor}_{j}\\tau(i{\\color{red}d}{\\color{blue}k})\\tau(j{\\color{red}d}{\\color{blue}k})\\quad\\texttt{随手将}\\mu\\texttt{提前，拉出k} ={\\color{purple}\\sum _ {\\color{purple}T}^{n}}\\boxed{\\sum_{d|{\\color{purple}T}}\\tau(d)\\mu(\\frac{\\color{purple}T}{d})}\\sum^{\\lfloor\\frac{n}{\\color{purple}T}\\rfloor}_{i}\\tau(i{\\color{purple}T})\\sum^{\\lfloor\\frac{m}{\\color{purple}T}\\rfloor}_{j}\\tau(j{\\color{purple}T})\\quad\\texttt{随手用T代dk，枚举T} ={\\color{purple}\\sum_{\\color{purple}T}^{n}}\\sum^{\\lfloor\\frac{n}{\\color{purple}T}\\rfloor}_{i}\\tau(i{\\color{purple}T})\\sum^{\\lfloor\\frac{m}{\\color{purple}T}\\rfloor}_{j}\\tau(j{\\color{purple}T})\\quad\\texttt{随手套用}\\tau*\\mu=1 ={\\color{purple}\\sum_{\\color{purple}T}^{n}}{\\color{orange}\\sum_{T|i}^{n}\\tau(i)}{\\color{orange}\\sum_{T|j}^{m}\\tau(j)}\\quad\\texttt{随手换个写法}这样我们就有了一个看上去最终能用的式子。 此时复杂度不严格地说应该是一只 $\\log$ ，众所不知，他跑不过去。如果你很松那另当别论。 我们着手狄利克雷后缀和优化后两个 $\\sum$ 。 三、狄利克雷后缀和？对于形如 ： \\sum_{T|i}f(i)的式子，我们可以用狄利克雷后缀和优化到 $\\mathcal{O}(n\\log\\log m)$ 具体实现如下： 12345678/*len——质数表长度；v[]——质数表；A[]——后缀和函数*/for (int i = 0; i &lt; len; i++)&#123; for (int j = N / v[i]; j; j--)//可以理解成考虑每个质因数对后缀和的影响 &#123; A[j] = (A[j] + A[j * v[i]]) % MOD; &#125;&#125; 我们可以用这个来优化后两个 $\\sum$ 。 最后获得了约为 $\\mathcal{O}(n\\log\\log m)$ 的优秀复杂度。 码字不易，笔者叹气。","categories":[],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://quest233.github.io/tags/solutions/"}]},{"title":"浅谈一类暴力过题——[BalticOI 2012 Day1] 括号 题解","slug":"浅谈一类暴力过题——-BalticOI-2012-Day1-括号-题解","date":"2021-04-16T21:24:07.000Z","updated":"2021-04-19T03:27:44.562Z","comments":true,"path":"2021/04/17/浅谈一类暴力过题——-BalticOI-2012-Day1-括号-题解/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E4%B8%80%E7%B1%BB%E6%9A%B4%E5%8A%9B%E8%BF%87%E9%A2%98%E2%80%94%E2%80%94-BalticOI-2012-Day1-%E6%8B%AC%E5%8F%B7-%E9%A2%98%E8%A7%A3/","excerpt":"","text":"写在最前：推一下蒟蒻 $\\color{limegreen}{blog}$ 原题链接~ 首先，膜拜搬题人 $\\color{black}\\texttt{s}\\color{red}\\texttt{henmadongdong}$ ，他是我们的红太阳！ 其次，强烈谴责出题人自己卡常的恶劣行径。 本文阐（fan）述（yi）官方 std 做法，你会发现它的复杂度是假的，具体一会再说。 题意不用表述了，很清楚。 以下论述中，我们把不合法括号串归为一类，即 左括号数目多于右括号 的括号串。 （若在某一时刻，右括号多于左括号，那么之后无论怎么加括号，这整个串都 救不回来 了，没有统计意义） 接下来，我们需要证明一个氡西： 『所有 夹杂着方括号（至少有一对）的合法括号串与 纯圆括号 的合法括号串一一对应』 尝试胡乱证明： 对于一个 夹杂着方括号 的合法括号串 $s$ ，我们将里面所有左方括号换成左圆括号，所有右方括号换成右圆括号，最终的结果一定是一个 纯圆括号 的合法括号串。我们设这个新串为 $t$ 。目前只是单向的对应，我们需要建立 双向 。 \\texttt{s:(()\\red{[]})}\\Rightarrow\\texttt{t:(()\\red{()})} 对于这个 纯圆括号 的合法括号串 $t$ 。 我们将 $s$ 里，所有匹配上的 圆括号 ，在 $t$ 中相应位置标记出来。 \\begin{matrix}\\texttt{s:\\blue{(()}[]\\blue{)}}\\\\\\texttt{t:\\blue{(()}()\\blue{)}}\\end{matrix} 在 $t$ 的其它部分中，所有左圆括号换成左方括号，所有右圆括号换成右方括号。最终我们又得到了一个 夹杂着方括号 的合法括号串，显然这个新串就是 $s$ 。 \\texttt{t:(()\\red{()})}\\Rightarrow\\texttt{s:(()\\red{[]})}$Q.E.D.$ （这个证明看上去稀奇古怪的） 题目要求我们求 夹杂着方括号 的合法括号串，我们欣欣然把它转化成了 纯圆括号 的合法括号串计数。 之后就是普及- $dp$ 了，根据括号串dp的基本套路（基本法），我们设 $dp _ {i,j}$ 表示：决策到第 $i$ 个位置，当前左括号比右括号 多 $j$ 个的 括号串数目 。（为什么只考虑 $j$ 为正数在文章开头有说） 那么我们就有简单转移柿子（设给定串为 $s$ ）： \\begin{cases}dp _ {i,j}=dp _ {i-1,j+1}\\qquad(s[i]=')')\\\\dp _ {i,j}=dp _ {i-1,j+1}+dp _ {i-1,j-1}\\qquad(s[i]='(')\\end{cases}结合状态定义很好理解（或许？）。 初始化是 $dp _ {0,0}=0$ （显然） 。 但是我们意识到这样空间开不下，所以可以 滚一滚 。 这样我们就获得了 $\\mathcal{O}(n^2)$ 时间复杂度的优秀做法。按理说应该是过不了题的，而要优化起码得从 状态定义 上开刀。 写到这里我横竖想不到更好方法，在极度愤怒的情况下去看了官方题解，结果： The correct solution is still O(N^2), but we should speed it up by some constant factor. 你在教我做事？ 于是打了个 $n$ 方，果然过了，需要手动卡常，不需要吸氧。 代码： 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 3e5 + 7;const int MOD = 1e9 + 9;#define lst (i + 1) &amp; 1//用以滚动数组int dp[2][MAX], N, p;int main()&#123; ios::sync _ with _ stdio(0); cin &gt;&gt; N; dp[0][0] = 1; for (register int i = 1; i &lt;= N; i++) &#123; char c; cin &gt;&gt; c; int M = min(i, N - i); //上界，对答案有贡献的 j 需要小于 N-i ，而考虑合理性，j 还需要小于 i for (register int j = 0; j &lt;= M; j++) &#123; //转移 if (!j || c == &#x27;)&#x27;) &#123; dp[i &amp; 1][j] = dp[lst][j + 1]; &#125; else &#123; dp[i &amp; 1][j] = (dp[lst][j + 1] + dp[lst][j - 1]) % MOD; &#125; &#125; &#125; cout &lt;&lt; dp[N &amp; 1][0] &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","categories":[],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://quest233.github.io/tags/solutions/"}]},{"title":"浅谈一类简单普通莫队—— CF617E XOR and Favorite Number 题解","slug":"浅谈一类简单普通莫队——-CF617E-XOR-and-Favorite-Number-题解","date":"2021-04-16T20:48:07.000Z","updated":"2021-04-19T03:48:30.839Z","comments":true,"path":"2021/04/17/浅谈一类简单普通莫队——-CF617E-XOR-and-Favorite-Number-题解/","link":"","permalink":"https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E4%B8%80%E7%B1%BB%E7%AE%80%E5%8D%95%E6%99%AE%E9%80%9A%E8%8E%AB%E9%98%9F%E2%80%94%E2%80%94-CF617E-XOR-and-Favorite-Number-%E9%A2%98%E8%A7%A3/","excerpt":"","text":"推一手蒟蒻 $\\color{limegreen}{\\texttt {博客}}$ ～ 抓住CF爆炸的间隙乘机AC的水题。（滑稽 做这道题只需要知道两个点： 异或前缀性 和 普通莫队算法 。 不妨分开讲。 $\\large\\color{salmon}{\\texttt {异或前缀性：}}$ 前缀和可以 $O(1)$ 求解区间和。 前缀积可以 $O(1)$ 求解区间积。 那前缀异或能否 $O(1)$ 求解区间异或呢？ 答案是可以的。 $\\color{violet}{\\texttt {尝试证明：}}$ 我们设 $num$ 为一段序列， $xornum_{\\small\\ l,r}$ 表示这段序列里第 $l$ 到第 $r$ 个元素异或的结果。 手模可知，异或操作满足 结合律 。 a\\;\\oplus\\; b\\;\\oplus\\; c=a\\;\\oplus\\; (b\\;\\oplus\\; c)把 $xornum_{\\small\\ 1,l}$ 看成 $a$ ， $xornum_{\\small\\ l,r}$ 看成 $b$ 和 $c$ 异或的结果，那我们也就有了： xornum_{\\small\\ 1,r}=xornum_{\\small\\ 1,l}\\;\\oplus\\; xornum_{\\small\\ l,r}我们又知道异或有以下两个性质： a\\;\\oplus\\;0=aa\\;\\oplus\\;a=0那么我们可以经历一番移位得出： xornum_{\\small\\ l,r}\\;\\oplus\\; xornum_{\\small\\ 1,l}=xornum_{\\small\\ 1,r}佐佑同时异或上一个 $xornum_{\\small\\ 1,l}$ ，再套用一个结合律得： xornum_{\\small\\ l,r}\\;\\oplus\\;(xornum_{\\small\\ 1,l}\\;\\oplus\\;xornum_{\\small\\ 1,l})=xornum_{\\small\\ 1,r}\\;\\oplus\\;xornum_{\\small\\ 1,l}用上面两个性质一通转换： xornum_{\\small\\ l,r}\\;\\oplus\\;0=xornum_{\\small\\ 1,r}\\;\\oplus\\;xornum_{\\small\\ 1,l}xornum_{\\small\\ l,r}=xornum_{\\small\\ 1,r}\\;\\oplus\\;xornum_{\\small\\ 1,l}这样，我们就可以 预处理 异或前缀，来 $O(1)$ 求出区间异或的结果～ $\\large\\color{salmon}{\\texttt {普通莫队算法：}}$ 定一道莫队题需要看三眼。 第一眼，奇怪的区间查询。 第二眼，可以离线。 第三眼，$N\\sqrt{N}$ 能过。 完全符合条件，那就先把莫队的板子敲好。 （这里默认读者一定是会打莫队的QwQ。） 思维难度在 $ins/add$ 和 $del$ 两个函数上。（即 区间扩张/收缩 时的 添/删元素 ） $\\color{violet}{\\texttt {如何定制这两个函数？}}$ 这里要查的是异或值 $=k$ 的元素对数。 两个数 $a,b$ 做异或，知道其中的一个数 $a$ ，知道异或的结果 $c$ ，则运算的另一个数也是 确定的 ，即 $a\\oplus b=c\\Leftrightarrow b=a\\oplus c$ 。（这也可以用于理解异或的前缀性） 我们增添一个元素 $p$ 进入区间时，它带有一个异或前缀 $xornum_{\\small\\ 1,p}$ ，查一下区间里 和 $xornum_{\\small\\ 1,p}$ 异或结果 为 $k$ 的异或前缀的出现次数。 也就是说，我们需要开一个 $cnt$ 数组，维护每个 异或前缀值 当前出现的次数。 参考之前得到的式子，可以推出和 $xornum_{\\small\\ 1,p}$ 异或得 $k$ 的数，即为 $xornum_{\\small\\ 1,p}\\oplus k$ 。 那么添加一个元素 $p$ 时就应在答案上加上 $cnt[xornum_{\\small\\ 1,p}\\oplus k]$ 。 同理，删除一个元素 $p$ 就应减去 $cnt[xornum_{\\small\\ 1,p}\\oplus k]$ 。 $\\color{violet}{\\texttt {为什么能保证不重不漏？}}$ 因为 $a\\oplus b$ 等于 $b\\oplus a$ ，可以保证区间中任取两个数，他们之间只计算了一次。 $\\color{salmon}{\\texttt {实现注意：}}$ $cnt$ 数组的大小应为 异或前缀的值域 大小，而非序列中元素个数，这里应为 $2\\times 10^6$ 。 正如我们做闭区间和时的 $sum[r]-sum[l-1]$ 一样，这里的闭区间异或也应为 $xornum[r]\\oplus xornum[l-1]$ ，一种省力的方法是在输入的时候就把 所有的 $l$ 都减去 $1$ 。 $\\color{salmon}{\\texttt {Code:}}$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1e6 + 7;#define int long longint cnt[MAX &lt;&lt; 1], num[MAX]; //注意cnt应开2e6int block[MAX];int N, M, K;int sum;struct query&#123; int L, R; int id;&#125; q[MAX];bool cmp(query a, query b)&#123; if (block[a.L] != block[b.L]) &#123; return a.L &lt; b.L; &#125; return (block[a.L] &amp; 1 ? a.R &lt; b.R : a.R &gt; b.R);&#125;int xornum[MAX &lt;&lt; 1], ans[MAX &lt;&lt; 1];void ins(int p)&#123; sum += cnt[xornum[p] ^ K]; //查对应的异或值 cnt[xornum[p]]++; ///更新出现次数&#125;void del(int p) //同上&#123; cnt[xornum[p]]--; sum -= cnt[xornum[p] ^ K];&#125;signed main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; int lenb = sqrt(N); for (int i = 1; i &lt;= N; i++) &#123; cin &gt;&gt; num[i]; block[i] = (i - 1) / lenb + 1; xornum[i] = xornum[i - 1] ^ num[i]; //预处理异或前缀 &#125; for (int i = 1; i &lt;= M; i++) &#123; cin &gt;&gt; q[i].L &gt;&gt; q[i].R; q[i].L--; //像做前缀和一样-1 q[i].id = i; &#125; sort(q + 1, q + 1 + M, cmp); int L = 1, R = 0; for (int i = 1; i &lt;= M; i++) //普通莫队 &#123; while (q[i].L &lt; L) &#123; L--; ins(L); &#125; while (q[i].R &gt; R) &#123; R++; ins(R); &#125; while (q[i].L &gt; L) &#123; del(L); L++; &#125; while (q[i].R &lt; R) &#123; del(R); R--; &#125; ans[q[i].id] = sum; &#125; for (int i = 1; i &lt;= M; i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; endl; &#125;&#125;","categories":[],"tags":[{"name":"solutions","slug":"solutions","permalink":"https://quest233.github.io/tags/solutions/"}]},{"title":"","slug":"hello-world","date":"2021-04-16T13:34:44.880Z","updated":"2021-04-17T06:58:57.242Z","comments":true,"path":"2021/04/16/hello-world/","link":"","permalink":"https://quest233.github.io/2021/04/16/hello-world/","excerpt":"","text":"这是 quest_2 手搭的博客，花了他一个上午的时间，貌似很菜，尤其是这个段落概览很逊。 凑合看罢。","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"water","slug":"water","permalink":"https://quest233.github.io/tags/water/"},{"name":"solutions","slug":"solutions","permalink":"https://quest233.github.io/tags/solutions/"},{"name":"“知识”决定命运","slug":"“知识”决定命运","permalink":"https://quest233.github.io/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/"}]}