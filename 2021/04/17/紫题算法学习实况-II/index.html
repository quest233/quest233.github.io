<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="referrer" content="no-referrer" />
  
  <title>紫题算法学习实况 II | quest233的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="quest_2" />
  
  <meta name="description" content="原来那个文章里面全都是瑇码和公式，充斥了4700多行，卡到已经几乎无法编辑了，所以新开一个文章。 如果笔者有什么写得乱七八糟或者听天书的地方，可以直接评论区开D，笔者即刻更改，以免贻害后人。 2021-01-09：愉悦滚去whk，本文应该长期不更了（咕）2021-01-17：爬回机房重新阅读了一下本文，修了大量语文锅 SAM_写在最前：网上最主流的讲解方式无非是 endpos - 构建方法 - 应">
<meta property="og:type" content="article">
<meta property="og:title" content="紫题算法学习实况 II">
<meta property="og:url" content="https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5-II/index.html">
<meta property="og:site_name" content="quest233的博客">
<meta property="og:description" content="原来那个文章里面全都是瑇码和公式，充斥了4700多行，卡到已经几乎无法编辑了，所以新开一个文章。 如果笔者有什么写得乱七八糟或者听天书的地方，可以直接评论区开D，笔者即刻更改，以免贻害后人。 2021-01-09：愉悦滚去whk，本文应该长期不更了（咕）2021-01-17：爬回机房重新阅读了一下本文，修了大量语文锅 SAM_写在最前：网上最主流的讲解方式无非是 endpos - 构建方法 - 应">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/n6rsxx5f.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/xutakwos.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/xutakwos.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/xutakwos.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/9knd6i8p.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/xutakwos.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/9n78yqow.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/xsrbbrcp.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/j5wjw48n.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/pw6x521x.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/paxjq6ke.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/grrkm8jn.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/yql5a08z.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/1gwhgvak.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/7wgd42cy.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/z926nywz.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/7wgd42cy.png">
<meta property="article:published_time" content="2021-04-17T07:16:56.000Z">
<meta property="article:modified_time" content="2021-04-18T08:33:51.604Z">
<meta property="article:author" content="quest_2">
<meta property="article:tag" content="“知识”决定命运">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.luogu.com.cn/upload/image_hosting/n6rsxx5f.png">
  
  
    <link rel="icon" href="images/62224.png">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">quest_2&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/2021/04/17/About/#more">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/150879.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        quest_2&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        “知识”决定命运
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-紫题算法学习实况-II" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      紫题算法学习实况 II
    </h1>
    <div class="post-title-bar">
      <ul>
          
        <li>
          <i class="fa fa-calendar"></i>  2021-04-17
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <p>原来那个<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/quest233/zi-ti-suan-fa-xue-xi-shi-kuang">文章</a>里面全都是瑇码和公式，充斥了4700多行，卡到已经几乎无法编辑了，所以新开一个文章。</p>
<p>如果笔者有什么写得乱七八糟或者听天书的地方，可以直接评论区开D，笔者即刻更改，以免贻害后人。</p>
<h6 id="2021-01-09：愉悦滚去whk，本文应该长期不更了（咕）"><a href="#2021-01-09：愉悦滚去whk，本文应该长期不更了（咕）" class="headerlink" title="2021-01-09：愉悦滚去whk，本文应该长期不更了（咕）"></a>2021-01-09：愉悦滚去whk，本文应该长期不更了（咕）</h6><h6 id="2021-01-17：爬回机房重新阅读了一下本文，修了大量语文锅"><a href="#2021-01-17：爬回机房重新阅读了一下本文，修了大量语文锅" class="headerlink" title="2021-01-17：爬回机房重新阅读了一下本文，修了大量语文锅"></a>2021-01-17：爬回机房重新阅读了一下本文，修了大量语文锅</h6><hr>
<h3 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h3><p>_写在最前：网上最主流的讲解方式无非是 endpos - 构建方法 - 应用，这里也不另辟蹊径，但是会扔掉一些晦涩难懂的证明，争取用阳间一点的语言说罢_</p>
<p><del>“将所有是旧串后缀且在其后面加c形成的新字符串不是旧串子串的字符串往新串的最长后缀所属节点连一条边。”</del></p>
<p>如果要求您在一张图上表示一个字符串的所有子串，那么您可能会建一棵 $\texttt{Trie}$ 。</p>
<p>如图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/n6rsxx5f.png" alt=""></p>
<p>很有精神的一个 $\texttt{Trie}$ ，从根结点往下，走到任意一个点的 <strong>路径</strong> 都是原串的一个子串。</p>
<p>但是缺点貌似也很明显，他太占空间了，这框出的这两部分是一模一样的。这是坏的。</p>
<p>我们意识到需要有一种好的存图规则，来尽可能优化我们的空间。</p>
<p>于是乎， <strong>先 辈</strong> 们想到了一种氡氡—— $endpos$ 。</p>
<h4 id="endpos-？"><a href="#endpos-？" class="headerlink" title="$endpos$ ？"></a>$endpos$ ？</h4><p>假设我有一个字符串 $\mathtt{shenmadongdong}$ 。（这个字符串一听就很巨）</p>
<p>我们截取出一个子串 $\mathtt{dong}$ ，若以一个字串的 <strong>最后一位</strong> 来表示位置的话，它出现在 $\{10,14\}$ 两处。</p>
<p>我们就将 $\{10,14\}$ 这样的 <strong>位置集合</strong> 称做 $\mathtt{dong}$ 这个子串的 $endpos$ 。</p>
<p>未来或现在的 IOIAKer 您一定看出来了，这个 $endpos$ 有些十分美妙的性质，这里分别阐述：</p>
<p>_<strong>以下钦定</strong> $len_a\leq len_b$_</p>
<hr>
<h5 id="性质〇：对于一个子串的后缀们，越长的后缀所拥有-endpos-集合越小，反之则反之。"><a href="#性质〇：对于一个子串的后缀们，越长的后缀所拥有-endpos-集合越小，反之则反之。" class="headerlink" title="性质〇：对于一个子串的后缀们，越长的后缀所拥有 $endpos$ 集合越小，反之则反之。"></a>性质〇：对于一个子串的后缀们，越长的后缀所拥有 $endpos$ 集合越小，反之则反之。</h5><p>算不上性质的性质/jy</p>
<p>这不是显然的事情嘛？越长的后缀它出现的次数肯定越少哇。</p>
<p>$\Box$ </p>
<hr>
<h5 id="性质一：如果两个子串的-endpos-有相同的元素，则一个中的子串必然为另一个的后缀"><a href="#性质一：如果两个子串的-endpos-有相同的元素，则一个中的子串必然为另一个的后缀" class="headerlink" title="性质一：如果两个子串的 $endpos$ 有相同的元素，则一个中的子串必然为另一个的后缀"></a>性质一：如果两个子串的 $endpos$ 有相同的元素，则一个中的子串必然为另一个的后缀</h5><p>我们说过，一个子串的出现位置，由他的 <strong>最后一位</strong> 表示。</p>
<p><strong>胡乱猜结论</strong>：只有最后 $len_a$ 位一样的两个串，才会共享一样的 $endpos$ 。</p>
<p><strong>尝试证明</strong>：要是在 $len_a$ 位内出现了不同的某一字符，那么他们的最后一位必然 <strong>落不到同一个位置</strong> ，那么他们的 $endpos$ 内的元素必然不同。</p>
<p>$\Box$ （好感性啊 AwA ）。</p>
<hr>
<h5 id="性质二：两个子串-a-b-，要么其中一个的-endpos-包含另一个的，要么两者的-endpos-没有交集。"><a href="#性质二：两个子串-a-b-，要么其中一个的-endpos-包含另一个的，要么两者的-endpos-没有交集。" class="headerlink" title="性质二：两个子串 $a,b$ ，要么其中一个的 $endpos$ 包含另一个的，要么两者的 $endpos$ 没有交集。"></a>性质二：两个子串 $a,b$ ，要么其中一个的 $endpos$ 包含另一个的，要么两者的 $endpos$ 没有交集。</h5><p>如果 $a$ 是 $b$ 的后缀，那么 $b$ 出现的地方 $a$ 必然也出现了，那么 $endpos(b)\subseteq endpos(a)$ 是显然的。</p>
<p>如果不是，那么根据性质一，二者不会有交集。</p>
<p>$\Box$ （这个就非常有理有据）<del>（确信）</del> 。</p>
<hr>
<h5 id="性质三：如果把所有-endpos-集合完全相同的子串归在一个等价类里，那么每个-endpos-的等价类里的子串长度连续。"><a href="#性质三：如果把所有-endpos-集合完全相同的子串归在一个等价类里，那么每个-endpos-的等价类里的子串长度连续。" class="headerlink" title="性质三：如果把所有 $endpos$ 集合完全相同的子串归在一个等价类里，那么每个 $endpos$ 的等价类里的子串长度连续。"></a>性质三：如果把所有 $endpos$ 集合完全相同的子串归在一个等价类里，那么每个 $endpos$ 的等价类里的子串长度连续。</h5><p>这个性质十分好用。这证明起来也是很 $naive$ 的。</p>
<p>如果存在 $a,b$ 归在同一个等价类里，且 $len_a+1&lt;len_b$ （也就是中间出现了断层）。</p>
<p>根据性质一， $a$ 必为 $b$ 的 <strong>后缀</strong> 。</p>
<p>根据性质〇，更短的后缀都和 $b$ 出现的位置 <strong>完 全 一 致</strong> 了，那更长的后缀怎么说也更应该一样了 QwQ。</p>
<p>但既然如此，比 $a$ 再长一位的后缀凭什么不能和 $a,b$ 在同一个等价类里？这不公平。</p>
<p>$\Box$ （鬼扯证明）。</p>
<hr>
<h5 id="插播：-parent-tree-？"><a href="#插播：-parent-tree-？" class="headerlink" title="插播：$parent\ tree$ ？"></a>插播：$parent\ tree$ ？</h5><p>虽然性质还有很多，但是这时的确就应该开始讲 $parent\ tree$ 了，这的确符合认识算法的客观规律。</p>
<p>我们看 $\mathtt{shenmadongdong}$ 中的 $\mathtt{n}$ ，它的 $endpos$ 为 $\{4,9,13\}$ 。</p>
<p>如果我们要往它前面加一个字符，我们有 $\mathtt{en}$ 和 $\mathtt{on}$ 两种加法，他们的 $endpos$ 分别为 $\{4\}$ 和 $\{9,13\}$。</p>
<p>你灵光一现，意识到在一个字符串 <strong>前面</strong> 加一个字符，很可能就会把原来这个字符串的 $endpos$ <strong>分割成若干份</strong> 。</p>
<p>我们接着在 $\mathtt{on}$ 上加字符，此时只有一种加法 $\mathtt{don}$ ，$endpos$ 依然是 $\{9,13\}$ 。</p>
<p>你完善了你的猜想，所谓的 “分割成若干份” 也可以指的是 <strong>一份</strong> 。当加字符后和原来还是在 <strong>同一个等价类</strong> 里的话，就会出现这种情况。</p>
<p>我们接着在 $\mathtt{don}$ 上加字符，此时又有两种加法 $\mathtt{adon}$ 和 $\mathtt{gdon}$ ，分别有 $endpos$ 为 $\{9\}$ 和 $\{13\}$ 。</p>
<p>这更加证实了你的猜想，即：</p>
<p>『一个字符串 <strong>前面</strong> 加一个字符，将会把原来这个字符串的 $endpos$ <strong>分割成若干（可能为一）份</strong> 』</p>
<p><del>多么伟大不朽的成就。</del></p>
<p>我们称这是『神马氡氡第一定律』 。</p>
<p>根据性质二，非后缀关系的两个子串 $endpos$ 无交集，所以以 <strong>等价类作为结点</strong> ，这些分割关系构成了一些 <strong>树形结构</strong>，即一棵森林。</p>
<p>森林算不上 $\mathbf{tree}$ ，我们需要一个超级根来聚合一棵树，不难想到，<strong>空串所在的等价类</strong> 正符合当超级根的要求 。因为他无处不在，所以他的 $endpos$ 是 $\{1,2,3,4,5,6,7,8,9,10,11,12,13,14\}$ ，相当于全集。</p>
<p>下属其它的 $endpos$ 集合，都是这个集合的子集。</p>
<p>那么我们这就构建出了一棵 $parent\ tree$ ，对于 $\mathtt{shenmadongdong}$ 这个<del>仙气溢出的</del>字符串，我们能构建这样一棵 $parent\ tree$ ：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xutakwos.png" alt=""></p>
<p>这里引入一个概念：我们称某个等价类中的 <strong>最长子串</strong> 指的是： （$endpos$ 符合某个等价类） 的所有子串中，长度最长的那个子串。</p>
<p><strong>最短子串</strong> 的定义同理。</p>
<p>这里用 $\color{purple}{\texttt{给}}$ 指导最爱的颜色标出了“每个结点对应的等价类的 <strong>最长子串</strong> ”。</p>
<p>结点中的数字表示的是 $endpos$ 集合。</p>
<hr>
<h5 id="性质四：如果两个等价类-A-B-，在-parent-tree-上-B-是-A-的父亲-，那么-B-的最长子串的长度-1，一定等于-A-的最短子串的长度。"><a href="#性质四：如果两个等价类-A-B-，在-parent-tree-上-B-是-A-的父亲-，那么-B-的最长子串的长度-1，一定等于-A-的最短子串的长度。" class="headerlink" title="性质四：如果两个等价类 $A,B$ ，在 $parent\ tree$ 上 $B$ 是 $A$ 的父亲 ，那么 $B$ 的最长子串的长度+1，一定等于 $A$ 的最短子串的长度。"></a>性质四：如果两个等价类 $A,B$ ，在 $parent\ tree$ 上 $B$ 是 $A$ 的父亲 ，那么 $B$ 的最长子串的长度+1，一定等于 $A$ 的最短子串的长度。</h5><p>奇怪的性质增加了.jpg</p>
<p>我们再次 YY 一下 $parent\ tree$ 的构造规则：</p>
<p>在一个等价类中的某个子串前再 <strong>添加一个字符</strong> 。</p>
<p>不难发现，若选择的这个子串是这个等价类中的 <strong>最长子串</strong> ，形成的字符串就必然归于其 <strong>儿子</strong> 的等价类。否则就仍在这个等价类中。</p>
<p>如果选择的是最长子串，那这个新形成的字符串肯定这个 <strong>儿子等价类</strong> 中 <strong>最短</strong> 的一个。</p>
<p>$\Box$</p>
<hr>
<p>算法可行性不证了，版（zuo）面（zhe）有（tai）限（cai）。</p>
<hr>
<p>看到这里，您必然会想：“我是来看 SAM 的，这个吊人却给我讲些什么 $parent\ tree$ 之类的东西搞啥呢。”</p>
<p>我们将要构建的SAM，就和 $parent\ tree$ 有一样的 <strong>结点</strong> 定义。</p>
<p>事实上，SAM 的前置知识还是很重要的，了解了这些性质就有效地避免了全文背诵的惨案。</p>
<p>字符串数据结构的全文背诵是最不彳亍的，因为出出来的那些题大多需要 <strong>魔改</strong> 数据结构的机体，光是全文背诵就很痛苦了。</p>
<hr>
<h4 id="构建一台后缀自动姬"><a href="#构建一台后缀自动姬" class="headerlink" title="构建一台后缀自动姬"></a>构建一台后缀自动姬</h4><hr>
<h5 id="Step-0-：有关变量"><a href="#Step-0-：有关变量" class="headerlink" title="$Step\ 0$：有关变量"></a>$Step\ 0$：有关变量</h5><p>首先我们需要整出一套自动姬所需的数组啊啥的。</p>
<p>东汉末名将赵子龙就曾说过：“能进能退 <del>（能伸能缩）</del>，乃真正法器。”</p>
<p>我们需要让我们的字符串能向前扩展，也能向后扩展，以表达所有的子串。</p>
<hr>
<p>我们已经有了在子串 <strong>前面</strong> 加字符的方法，即 $parent\ tree$ 的构造规则。</p>
<p>再放送 $parent\ tree$ ：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xutakwos.png" alt=""></p>
<p>我们用存 $fa$ 的方式维护这棵 $parent\ tree$ ，$fa[u]$ 里存的是它在 $parent\ tree$ 里面的 <strong>直接父亲</strong> 。</p>
<p>用 $endpos$ 等价类的知识解释，就是 $u$ 等价类的 <strong>最长子串</strong> ，它最长的那个 （<strong>不同等价类</strong> 的后缀）所在的等价类。比如上图中的 $\mathtt{shenmadon}$ 所在等价类的 $fa$ ，就是 $\mathtt{don}$ 所在等价类。</p>
<hr>
<p>上面是在前面加字符的方法，那么在其后面加字符的方法呢？</p>
<p>我们用 $ch[u][c]$ 来表示：在$u$ 结点 <strong>对应的等价类</strong> 的 <strong>最长子串后面</strong> 加上一个字符 $c$ ，<strong>形成的新字符串所属的等价类</strong> 对应的结点 。（参考 $\mathtt{Trie}$ 上的连边）</p>
<p>你搁着读绕口令呢？/fn</p>
<p>你可能需要多读几遍格物致知，更口区的还没来呢。</p>
<p>_/ *这里讲的不好被小猫 @Schwarzkopf_Henkal D了，所以加一个例子 * /_</p>
<p><strong>举个栗子</strong>，假设我们的 $\mathtt{shenmadon}$ 属于的等价类在 $u$ 结点，我们在后面加上 $\mathtt{g}$ 变成 $\mathtt{shenmadong}$ ， $\mathtt{shenmadong}$ 归在等价类 $v$ ，那么我们有 $ch[u][‘g’-‘a’]=v$</p>
<p>其实和 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4070">这道题</a> 表达的意思差不多。</p>
<p>$ch$ 数组和 $parent\ tree$ 没有什么直接关系，它不过是自动姬体内的一些连边。或者说我们要维护两个数据结构，一个是 $fa$ 维护的 $parent\ tree$ ，一个是 $ch$ 维护的SAM姬体。</p>
<p>我们现在有了能伸能缩的方法，接下来就可以开始建造后缀自动姬辣！</p>
<hr>
<p>_以下不再区分结点和结点所对应的等价类，这两个是同一个氡西_</p>
<h5 id="Step-1-：构建前的准备工作"><a href="#Step-1-：构建前的准备工作" class="headerlink" title="$Step\ 1$：构建前的准备工作"></a>$Step\ 1$：构建前的准备工作</h5><p>我们需要明晰构建自动姬的方法为 <strong>增量法</strong> 。</p>
<p>简单点说就是自动姬每次吞进 <strong>一个字符</strong> ，应对这个字符改变内部结构，再吞进下一个字符，以此往复。</p>
<p>每次吞字符的行为之间需要传递一些信息，除了以上提到的 $fa$ 和 $ch$ 照例保留外，还需要传递一个 $lst$ 变量，表示上一次 <strong>添加字符后的串</strong> $s$ 所属的等价类。</p>
<p>显然，上一次加完字符后的串 $s$ ，一定是 $lst$ 这个等价类的 <strong>最长子串</strong>，这不难理解，毕竟 $s$ 甚至是目前所有子串中最长的一个，自然在它的类里也当人上人。</p>
<p>我们在最长子串 $s$ 后加上了一个字符 $c$ 形成了一个新串，根据性质四，我们知道这个新串将会归到一个 <strong>新的等价类</strong> 里。</p>
<p>所以我们开一个新点 $np$ ，表示 $s+c$ 所属的新等价类对应的结点。</p>
<p>如果我们称 $len(u)$ 为 $u$ 这个等价类 <strong>最长子串的长度</strong> 。暂时地，我们应使 $len(np)=len(p)+1$ ，因为 $np$ 目前的最长子串是由 $p$ 的最长子串加上 <strong>一个</strong> 字符 $c$ 变成的。</p>
<p><strong>举个例子</strong>，我们当前构建到了 $\mathtt{shenmad}$ ，它在 $endpos$ 集合 $\{7\}$ 里当人上人。</p>
<p>我们在它后面加一个字符 $\mathtt{o}$ ，显然，新串 $\mathtt{shenmado}$ 和原串已经不在同一个等价类中了，他早已成为 $\{8\}$ 集合的 <strong>最长子串</strong> 了。</p>
<p>这部分的瑇码～（人生苦短，我用结构体）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> len, fa;</span><br><span class="line">    <span class="comment">//len——最长子串长度,fa——（最长的（不同等价类的）后缀）所在的等价类</span></span><br><span class="line">	<span class="keyword">int</span> ch[<span class="number">27</span>];</span><br><span class="line">	<span class="built_in">node</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ch));</span><br><span class="line">		len = fa = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; T[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> lst = <span class="number">1</span>, tot = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = lst;<span class="comment">//取出当前最长子串所在等价类</span></span><br><span class="line">	<span class="keyword">int</span> np = ++tot;<span class="comment">//开一个新点</span></span><br><span class="line">	T[np].len = T[p].len + <span class="number">1</span>;<span class="comment">//新等价类的len等于原等价类len+1</span></span><br><span class="line">	lst = tot;<span class="comment">//更新最长子串所在类</span></span><br><span class="line">	......</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="keyword">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)<span class="comment">//增量法</span></span><br><span class="line">	&#123;</span><br><span class="line">		Tree.<span class="built_in">add</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="Step-2-：遍历新串后缀，到第一个出现过的子串为止"><a href="#Step-2-：遍历新串后缀，到第一个出现过的子串为止" class="headerlink" title="$Step\ 2$：遍历新串后缀，到第一个出现过的子串为止"></a>$Step\ 2$：遍历新串后缀，到第一个出现过的子串为止</h5><p>每当我们加入一个新字符，可能之前某些子串的 <strong>出现位置</strong>（即 $endpos$ 中的元素）就会变多。</p>
<p>具体地说，如果我们当前加到第 $n$ 位，有些新子串从来 <strong>没出现</strong> 过，需要多开一个 $\{n\}$ 等价类包含它们；有些新子串 <strong>曾经出现</strong> 过，它们的 $endpos$ 中就多一个 $n$ 。</p>
<p>我们需要找到这些新子串的出现位置。</p>
<p>这样的新子串满足什么性质呢？很简单，一定是 <strong>加字符之前</strong> 的原字符串的某个 <strong>后缀</strong> ，再拼接上我们 <strong>现在加的这个字符</strong> $c$ 。（所谓 $endpos$ 者，你甚至都不以 $c$ 为 $end$ ，凭什么让他给你贡献 $endpos$ 呢，这不公平。）</p>
<p>既然是后缀关系，对于拼上 $c$ 的新串，一定存在某一长度的后缀，使得长度 <strong>小于</strong> 它的其它后缀都出现过。</p>
<p><strong>举个例子</strong>，我们的原字符串为 $\mathtt{shenmadongdo}$ ，现在我们加上一个字符 $\mathtt{n}$ ，定然只有 $\mathtt{shenmadongdon,henmadongdon,enmadongdon,\dots,don,on,n,}\varnothing$ 这些串的 $endpos$ 可能会改变。</p>
<p>这其中，只有长度小于 $\mathtt{don}$ 的后缀（$\mathtt{don,on,n,}\varnothing$）的 $endpos$ 将在原有基础上加上 $13$ ，其它的后缀都将归在 $\{13\}$ 这一类中。</p>
<p>这就需要我们从左往右遍历后缀，找到这个第一个出现过的后缀。</p>
<hr>
<p>我们知道，根据『神马氡氡第一定律』，一个字符串 <strong>前面</strong> 加一个字符，将会把原来这个字符串的 $endpos$ <strong>分割成若干（可能为一）份</strong> ，在 $parent\ tree$ 上，表现为 <strong>下分出几棵子树</strong> 。</p>
<p>古语有云：“水能载舟，亦可覆舟（<del>亦可赛艇</del>）”。</p>
<p>这启示我们我们以相反的方面看这一定律。（<del>胡扯</del>）</p>
<p>我们也可以说一个字符串 <strong>前面</strong> 删掉几个字符 ，在 $parent\ tree$ 上，表现为 <strong>向上跳 $fa$（或原地不动）</strong> 。</p>
<p>我们称这是『神马氡氡第一引理』。</p>
<p>那么，一种十分女少的遍历后缀方法就呼之欲出了：在 $parent\ tree$ 上，向上跳 $fa$ 。</p>
<hr>
<p>我们再再放送 $parent\ tree$ ：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xutakwos.png" alt=""></p>
<p>（越看越丑）</p>
<p>以 $\mathtt{shenmadon}$ 为例，我们向上跳一级 $fa$ ，遍历到后缀 $\mathtt{don}$ ，相当于在字符串前面删掉了 $6$ 个字符。再跳一级 $fa$ ，遍历到后缀 $\mathtt{n}$ ，相当于在前面删掉了 $2$ 个字符。</p>
<p>这时，您可能会疑问，这样遍历后缀，难道不会漏掉很多在同一等价类里的后缀吗？这是好的。</p>
<p>我们说，遍历的作用，在于找到 <strong>第一个出现过的后缀</strong> 。</p>
<p>属于同一等价类的子串们，它们 $endpos$ 相同，在原串中的 <strong>出现情况</strong> 也相同。所以，我们只需查看每个等价类中的 <strong>一个串</strong> （这里选用 <strong>最长子串</strong> ），即可判断整个等价类是否曾经出现 。</p>
<p>高明！</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9knd6i8p.png" alt=""></p>
<hr>
<p>至于实现，看看瑇码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*遍历后缀*/</span></span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; !T[p].ch[c])<span class="comment">//前面的p可以单纯地看做防止它跳出SAM</span></span><br><span class="line"><span class="comment">//后面的则是看（p的最长子串+c字符）是否曾经出现</span></span><br><span class="line">&#123;</span><br><span class="line">	T[p].ch[c] = np;<span class="comment">//若未曾出现，则（p的最长子串+c）归于&#123;n&#125;这个等价类里</span></span><br><span class="line">	p = T[p].fa;<span class="comment">//跳fa，遍历下一个后缀</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!p)<span class="comment">//若之前是因跳出SAM而结束，那么说明（∅+c）=c 这个字符都从来没出现过</span></span><br><span class="line">&#123;</span><br><span class="line">	T[np].fa = <span class="number">1</span>;<span class="comment">//看来&#123;n&#125;这个集合需要连接超级根1。</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="Step-3-：自动姬的处理计划一"><a href="#Step-3-：自动姬的处理计划一" class="headerlink" title="$Step\ 3$：自动姬的处理计划一"></a>$Step\ 3$：自动姬的处理计划一</h5><p>还记得的吧，<code>T[p].ch[c]</code> 指向的是一个 <strong>等价类</strong> 。</p>
<p>假设我们已经用以上手段得到（某个长度的后缀+c）所处的 <strong>等价类</strong>（它就是上面瑇码中的 <code>T[p].ch[c]</code> ），能走到这里，说明这个后缀是第一个曾出现过的后缀。</p>
<p>设 $q=T[p].ch[c]$ ，我们需要知道 （ $p$ 的最长子串 + $c$ ） ，是否就是这个 $q$ 的 <strong>最长子串</strong>。这决定着我们该如何修改自动姬的结构。</p>
<p>看来我们需要 $\mathbf{dark}$ 力分讨这个问题。</p>
<p>最凑巧的情况当然是（ $p$ 的最长子串 + $c$ ）就是 $q$ 的最长子串。</p>
<p>嘛，既然这个串是最长子串，那么根据性质二，显然，同等价类的其它子串们都将是它的 <strong>后缀</strong> 。</p>
<p>而我们之所以会揪出这个子串来，是因为这个最长子串的 $endpos$ 集合需要 <strong>增添</strong> 一个 $n$ 。那么根据性质一，它的 <strong>后缀</strong> 们也会增添一个 $n$ 。</p>
<p>那么我们直接令这整个集合 $q$ ，成为 $np$ （它对应 $\{n\}$ 等价类）的 $fa$ 即可。</p>
<p>为什么？根据『神马氡氡第一定律』，$q$ 中增添一个 $n$ ，即 $q$ 的等价类能够额外 <strong>分割</strong> 出一个 $\{n\}$ 等价类 ，即在 $parent\ tree$ 上 $q$ 成为 $np$ 的 $fa$ 。</p>
<p>只需一步操作即可，最终的形态依然保证符合性质。这好吗？这很好。</p>
<hr>
<p><strong>举个例子</strong>，我们当前已经处理到了 $\mathtt{shenmadongdon}$ ，正是大业将成的时候。此时我们应该在后面加上一个 $\mathtt{g}$ ，经过 $Step\ 1$ 的准备，我们开了一个新点 $np$ ，等价类为 $\{14\}$ ，最长子串为 $\mathtt{shenmadongdong}$ 。</p>
<p>经过 $Step\ 2$ 的遍历，我们最终在 $\mathtt{don}$ 这个后缀所处的等价类 $p$ 上停了下来，这个 $\mathtt{don}+\mathtt{g}$ 之前已经出现过了。</p>
<p>我们把 $\mathtt{dong}$ 所在的等价类 $ch[p][‘g’-‘a’]$ 取出来记作 $q$ ，当时这个等价类的最长子串恰好就是 $\mathtt{dong}$ ，于是我们让 $np$ 的 $fa$ 等于 $q$ ，构建出一棵 $parent\ tree$ ：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xutakwos.png" alt=""></p>
<p>（上面描述的操作发生在图上的最右侧，即 $\mathtt{shenmadongdong}$ 所处等价类（$np$）的 $fa$ ，连向 $\mathtt{dong}$ 所处等价类（$q$））</p>
<p>这部分的瑇码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;<span class="comment">//上接上文</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> q = T[p].ch[c];<span class="comment">//取出 q 这个等价类</span></span><br><span class="line">	<span class="keyword">if</span> (T[q].len == T[p].len + <span class="number">1</span>)<span class="comment">//这里是一个转化过的判断条件</span></span><br><span class="line">    <span class="comment">//经过性质四的转化，这句话相当于：q的最长子串=p的最长子串+c</span></span><br><span class="line">	&#123;</span><br><span class="line">		T[np].fa = q;<span class="comment">//q成为 np（即&#123;n&#125;）的 fa</span></span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h5 id="Step-4-：自动姬的处理计划二"><a href="#Step-4-：自动姬的处理计划二" class="headerlink" title="$Step\ 4$：自动姬的处理计划二"></a>$Step\ 4$：自动姬的处理计划二</h5><p>东坡居士曾写道：“人有悲欢离合，月有阴晴圆缺，此事古难全。”</p>
<p>有一说一确实，不可能每次加一个字符都能变出某个等价类的最长子串，不然您的欧气也钛好了。</p>
<p>我们需要进一步考虑 <strong>不是最长子串</strong> 的情况。</p>
<p>神 @<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/user/61430">华莱士</a> 大佬提供了一个妙妙妙的理解方法。</p>
<p>我们用下三角图表示一个字符串的后缀们：</p>
<p>当前我们的原串是 $\mathtt{shenmado}$ 。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9n78yqow.png" alt=""></p>
<p>图中用 $\color{purple}{\texttt{给}}$ 指导最喜欢的颜色标出 <strong>后缀所属的等价类</strong> 。当前这些后缀都归在同一个 $endpos=\{8\}$ 的等价类中。</p>
<p>我们此时将要添加一个字符 $\mathtt{‘n’}$ ，根据 $Step\ 2$ 的遍历，它停在了 $\varnothing\mathtt{+n}=\mathtt{“n”}$ 这个后缀上。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xsrbbrcp.png" alt=""></p>
<p>按照早已设想的道路，$\mathtt{n}$ 这个子串所在等价类的 $endpos$ 应当原先的基础上 <strong>添加</strong> 一个 $9$ ，变成 $\{4,9\}$ 。而其它的后缀 $\mathtt{don,adon}$ 之类的应当归于 $\{9\}$ 。</p>
<p>对于等价类的定义，要求类内的 $endpos$ 相同，但现在我们发现这么一搞以后，现在这个等价类的 $endpos$ 不尽相同了。也就是说，我们需要把它 <strong>裂开</strong> 来，分裂成两个等价类，一部分为 $\{9\}$ ，另一部分为 $\{4,9\}$ 。（即：一部分是曾经出现过的，一部分是曾经没出现过的）</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/j5wjw48n.png" alt=""></p>
<p>以上就是当（ $p$ 中最长子串 + $c$ ）不是 $q$ 中最长子串的大致处理提纲/cy。下面我们来康康细节。</p>
<hr>
<p>我们分裂也不能白嫖空间啊，我们需要新创建一个结点 $nq$ ，来表示拆分出的两部分中，<strong>曾出现过</strong> 的那一部分（这里指图上的 $2$ ）。</p>
<p>之前的瑇码里我们看到，一个结点它有三个属性，$ch,fa,len$ ，我们来康康 $nq$ 需要具备怎样的属性。</p>
<hr>
<p>首先看 $ch$ ，它表示的是在 <strong>后面</strong> 加字符后归在的等价类，肉眼观察法可得，$ch[nq]$ 和原来 $ch[q]$ 其实没有区别。那么 <strong>直接继承</strong>  $q$ 的 $ch$ 就是了。</p>
<p>为什么？ $nq$ 在分裂以前与 $q$ 的差别在且仅在于 $endpos$ ，而在后面加一个字符能转移到哪里，就不在 $endpos$ 决定的范围内了。</p>
<hr>
<p>然后看 $len$ ，在 $Step\ 2$ 中 $p$ 不断跳跳跳最后跳到了新串的某个 <strong>曾经出现</strong> 过的后缀。这个曾经出现的后缀属于的结点是 $q$ ，以 （当前 $p$ 的最长子串+c）的 <strong>长度</strong> 为界限，将分裂出了一块 $nq$ ……</p>
<p>那么显然，$nq$ 的 $len$ 等于（当前 $p$ 的最长子串+c）的长度，也就是 $len(nq)=len(p)+1$ 。</p>
<hr>
<p>最后是 $fa$ 。$fa(q)$ 之前和 $q$ 在树上成父子关系，根据性质四，当时的 $len(fa(q))+1$ 必然等于 $minlen(q)$ ，也就是论 <strong>长度</strong> 而言，原 $len(fa(q))$ 与 $minlen(q)$ <strong>紧密相接</strong>。</p>
<p>分裂后，$minlen(q)$ 必然被归到了 $nq$ 类里，所以 $nq$ 与原 $fa(q)$ <strong>紧密相接</strong>，所以 $fa(nq)=fa(q)$。</p>
<p>同时，$nq$ 是从 $q$ 上 <strong>拆分</strong> 下来的，且 $nq$ 的 $len$ 小于 $q$ ，根据性质〇和一些推理， $nq$ 得变成 $q$ 的新 $fa$ 。</p>
<p>看上去就像一个链表的插入？</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/pw6x521x.png" alt=""></p>
<hr>
<p>但是我们还有一个非常严肃的问题存在，有些结点的 $ch[c]$ 指向的是 $q$ ，但是当我们分裂后，这些 $ch[c]$ 需要指向 $nq$ 。这就非常难搞，我们需要将 $ch$ <strong>重定向</strong> 。 </p>
<p>具体操作方法，我想先放瑇码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (p &amp;&amp; T[p].ch[c] == q)</span><br><span class="line">&#123;</span><br><span class="line">	T[p].ch[c] = nq;</span><br><span class="line">	p = T[p].fa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>……</p>
<p>这个靓仔是不是在哪里见过？</p>
<p>我们把之前遍历后缀的瑇码部分拿出来对比：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (p &amp;&amp; T[p].ch[c] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	T[p].ch[c] = np;</span><br><span class="line">	p = T[p].fa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现相同之处了吧，这说明我们的重定向其实也同时在做一个 <strong>遍历 $p$ 的后缀</strong> 的工作。我们对这些遍历到的 <strong>后缀</strong> 进行重定向，这些后缀的 $ch[c]$ ，需要满足原先指向 $q$ 。</p>
<hr>
<p>以上就是自动姬躯壳的全部组件，我们组装起来观赏一下完整瑇码：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*Step 1*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> len, fa;</span><br><span class="line">	<span class="keyword">int</span> ch[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">int</span> siz;</span><br><span class="line">	<span class="built_in">node</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		siz = len = fa = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ch));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; T[MAX];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> lst = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*Step 2*/</span></span><br><span class="line">	<span class="keyword">int</span> p = lst;</span><br><span class="line">	<span class="keyword">int</span> np = lst = ++tot;</span><br><span class="line">	T[np].len = T[p].len + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; T[p].ch[c] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		T[p].ch[c] = np;</span><br><span class="line">		p = T[p].fa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">	&#123;</span><br><span class="line">		T[np].fa = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="comment">/*Step 3*/</span></span><br><span class="line">		<span class="keyword">int</span> q = T[p].ch[c];</span><br><span class="line">		<span class="keyword">if</span> (T[q].len == T[p].len + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			T[np].fa = q;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*Step 4*/</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> nq = ++tot;</span><br><span class="line">			T[nq] = T[q];</span><br><span class="line">			T[nq].len = T[p].len + <span class="number">1</span>;</span><br><span class="line">			T[q].fa = T[np].fa = nq;</span><br><span class="line">			<span class="keyword">while</span> (p &amp;&amp; T[p].ch[c] == q)</span><br><span class="line">			&#123;</span><br><span class="line">				T[p].ch[c] = nq;</span><br><span class="line">				p = T[p].fa;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h4 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h4><hr>
<h5 id="判断一个串-A-是否是另一个串-B-的子串"><a href="#判断一个串-A-是否是另一个串-B-的子串" class="headerlink" title="判断一个串 $A$ 是否是另一个串 $B$ 的子串"></a>判断一个串 $A$ 是否是另一个串 $B$ 的子串</h5><p>真就把 SAM 当成AC自动姬来用呗。</p>
<p>对 $B$ 建一棵SAM，一个一个吞进 $A$ 的字符，每吞进一个字符，在 SAM 上走对应的 $ch$ 边。（因为 $ch$ 的本质就是在一个串的后面加字符）。</p>
<p>没有板子。</p>
<hr>
<h5 id="本质不同子串个数"><a href="#本质不同子串个数" class="headerlink" title="本质不同子串个数"></a>本质不同子串个数</h5><p>我们知道 SAM 结点的一个很 $\mathbf{dark}$ 的特点：它代表的是一整个 <strong>等价类</strong>，并且根据性质二，它们之间 <strong>没有交</strong> 。</p>
<p>这样我们大致有了个口胡想法，对 <strong>等价类大小</strong> 求和，这样可以做到不重不漏。</p>
<p>那么怎么求和呢，细化地说，我们如何知道一个等价类里有多少元素呢？</p>
<p>根据四， $minlen(u)=maxlen(fa(u))+1$ ，又因为类内长度 <strong>连续</strong> ，那么，类内元素个数 $n=maxlen(u)-(maxlen(fa(u))+1)+1=maxlen(u)-maxlen(u)$ 。</p>
<p>那么只需统计 $\sum(maxlen(u)-maxlen(u))$ 即可～</p>
<p><strong>板子题一</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2408">P2408 不同子串个数</a></p>
<p>放一下瑇码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> ch[<span class="number">27</span>];</span><br><span class="line">	<span class="keyword">int</span> len, fa;</span><br><span class="line">	<span class="built_in">node</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		len = fa = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ch));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; T[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">1</span>, lst = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*SAM 组件*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = lst;</span><br><span class="line">		<span class="keyword">int</span> np = lst = ++tot;</span><br><span class="line">		T[np].len = T[p].len + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (p &amp;&amp; T[p].ch[c] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			T[p].ch[c] = np;</span><br><span class="line">			p = T[p].fa;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			T[np].fa = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> q = T[p].ch[c];</span><br><span class="line">			<span class="keyword">if</span> (T[q].len == T[p].len + <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				T[np].fa = q;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> nq = ++tot;</span><br><span class="line">				T[nq] = T[q];</span><br><span class="line">				T[nq].len = T[p].len + <span class="number">1</span>;</span><br><span class="line">				T[q].fa = T[np].fa = nq;</span><br><span class="line">				<span class="keyword">while</span> (p &amp;&amp; T[p].ch[c] == q)</span><br><span class="line">				&#123;</span><br><span class="line">					T[p].ch[c] = nq;</span><br><span class="line">					p = T[p].fa;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sum += (T[np].len - T[T[np].fa].len);<span class="comment">//统计</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; Tree;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		cin &gt;&gt; c;</span><br><span class="line">		Tree.<span class="built_in">add</span>(c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>板子题二</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4070">[SDOI2016]生成魔咒</a></p>
<p>同，瑇码不放了。</p>
<hr>
<h5 id="获取两个串的最长公共子串的长度"><a href="#获取两个串的最长公共子串的长度" class="headerlink" title="获取两个串的最长公共子串的长度"></a>获取两个串的最长公共子串的长度</h5><p>对于其中任意一个串（称为原串）建SAM，像子串判别一样，一个一个吞进另一个串（称为匹配串）的字符。</p>
<p>但不同的是，子串判别是一旦没有了 $ch[c]$ 的转移就返回 0 ，而获取公共子串则是 “遇事不决先跳 $fa$ ”，相当于在前面 <strong>删掉一些字符</strong> ，再尝试转移一下。同时根据转移到的位置，实时更新当前匹配长度 $cur$ 。</p>
<p>当一个字符处理完后，记当前 $cur$ 为 $maxl[i]$ ，表示从匹配串的第 $i$ 位 <strong>向前</strong>，两串最长匹配了多长。</p>
<p>最终的答案就是 $maxl$ 中最大的一个。</p>
<p><strong>板子题</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/SP1811">SP1811 LCS - Longest Common Substring</a></p>
<p>放一下瑇码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">3e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> len, fa;</span><br><span class="line">	<span class="keyword">int</span> ch[<span class="number">26</span>];</span><br><span class="line">	<span class="built_in">node</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		len = fa = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ch));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; T[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>, lst = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*SAM组件*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = lst;</span><br><span class="line">	<span class="keyword">int</span> np = lst = ++tot;</span><br><span class="line">	T[np].len = T[p].len + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; T[p].ch[c] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		T[p].ch[c] = np;</span><br><span class="line">		p = T[p].fa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		T[np].fa = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> q = T[p].ch[c];</span><br><span class="line">		<span class="keyword">if</span> (T[q].len == T[p].len + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			T[np].fa = q;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> nq = ++tot;</span><br><span class="line">			T[nq] = T[q];</span><br><span class="line">			T[nq].len = T[p].len + <span class="number">1</span>;</span><br><span class="line">			T[q].fa = T[np].fa = nq;</span><br><span class="line">			<span class="keyword">while</span> (p &amp;&amp; T[p].ch[c] == q)</span><br><span class="line">			&#123;</span><br><span class="line">				T[p].ch[c] = nq;</span><br><span class="line">				p = T[p].fa;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">string s;</span><br><span class="line">string t;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxl[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">	<span class="keyword">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">	s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">add</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	len = t.<span class="built_in">length</span>();</span><br><span class="line">	t = <span class="string">&#x27; &#x27;</span> + t;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">1</span>;<span class="comment">//p 当前所在结点</span></span><br><span class="line">	<span class="keyword">int</span> cur = <span class="number">0</span>;<span class="comment">// cur 当前匹配长度</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (T[p].ch[v])<span class="comment">//能转移则转移</span></span><br><span class="line">		&#123;</span><br><span class="line">			cur++;</span><br><span class="line">			p = T[p].ch[v];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (p &amp;&amp; !T[p].ch[v])<span class="comment">//不能转移先跳 fa</span></span><br><span class="line">			&#123;</span><br><span class="line">				p = T[p].fa;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!p)<span class="comment">//倘若跳到头了都不能转移</span></span><br><span class="line">			&#123;</span><br><span class="line">				cur = <span class="number">0</span>;</span><br><span class="line">				p = <span class="number">1</span>;<span class="comment">//则重置之</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cur = T[p].len + <span class="number">1</span>;<span class="comment">//否则转移</span></span><br><span class="line">				p = T[p].ch[v];<span class="comment">//注意更新顺序</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        maxl[i]=cur;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, maxl);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="获取多串的最长公共子串"><a href="#获取多串的最长公共子串" class="headerlink" title="获取多串的最长公共子串"></a>获取多串的最长公共子串</h5><p>首先，我们有一个非常暴力的想法，对除了第一个串以外的所有串建 SAM ， 再把第一个串当作 <strong>匹配串</strong> ，放到这些 SAM 上去跑，一个字符处理完后，对 $maxl$ 取 $\min$ ，最后取 $maxl$ 中的 <strong>最大值</strong>。</p>
<p><del>其次，以上是正解。</del></p>
<p>为什么？</p>
<p>$maxl$ 的定义是匹配串第 $i$ 位往前最长匹配到了多长。</p>
<p>这个氡氡显然 <strong>只与</strong> 匹配串，也就是第一个串有关。那么，在每一次跑之间，它们跑出来的信息是可以 <strong>叠加</strong> 的。</p>
<p>那么我们多次取 $\min$ ，也是被允许的 QaQ 。</p>
<p><strong>板子题一：</strong> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/SP1812">LCS2 - Longest Common Substring II</a></p>
<p>板，以下是瑇码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> len, fa;</span><br><span class="line">	<span class="keyword">int</span> ch[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">int</span> siz;</span><br><span class="line">	<span class="built_in">node</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		siz = len = fa = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ch));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; T[MAX];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> lst = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SAM组件*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = lst;</span><br><span class="line">	<span class="keyword">int</span> np = lst = ++tot;</span><br><span class="line">	T[np].len = T[p].len + <span class="number">1</span>;</span><br><span class="line">	T[np].siz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; T[p].ch[c] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		T[p].ch[c] = np;</span><br><span class="line">		p = T[p].fa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">	&#123;</span><br><span class="line">		T[np].fa = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> q = T[p].ch[c];</span><br><span class="line">		<span class="keyword">if</span> (T[q].len == T[p].len + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			T[np].fa = q;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> nq = ++tot;</span><br><span class="line">			T[nq] = T[q];</span><br><span class="line">			T[nq].siz = <span class="number">0</span>;</span><br><span class="line">			T[nq].len = T[p].len + <span class="number">1</span>;</span><br><span class="line">			T[q].fa = T[np].fa = nq;</span><br><span class="line">			<span class="keyword">while</span> (p &amp;&amp; T[p].ch[c] == q)</span><br><span class="line">			&#123;</span><br><span class="line">				T[p].ch[c] = nq;</span><br><span class="line">				p = T[p].fa;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string t;<span class="comment">//第一个串，即匹配串</span></span><br><span class="line"><span class="keyword">char</span> s[MAX];<span class="comment">//因为不得不用scanf输入所以被迫用char*</span></span><br><span class="line"><span class="keyword">int</span> maxl[MAX];<span class="comment">//t[i]向前最长匹配到多长</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*多次建SAM，需要初始化*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		T[i] = <span class="built_in">node</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	tot = lst = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">int</span> kk = t.<span class="built_in">length</span>();</span><br><span class="line">	t = <span class="string">&#x27; &#x27;</span> + t;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">memset</span>(maxl, <span class="number">63</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(maxl));<span class="comment">//赋极大值</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>) != <span class="number">-1</span>)<span class="comment">//它不说有多少个串就很烦</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">add</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);<span class="comment">//建SAM</span></span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*跳SAM，跑匹配*/</span></span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kk; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v = T[p].ch[t[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">			<span class="keyword">if</span> (v)</span><br><span class="line">			&#123;</span><br><span class="line">				p = v;</span><br><span class="line">				cur++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span> (p &amp;&amp; !T[p].ch[t[i] - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">				&#123;</span><br><span class="line">					p = T[p].fa;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					p = <span class="number">1</span>;</span><br><span class="line">					cur = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					cur = T[p].len + <span class="number">1</span>;</span><br><span class="line">					p = T[p].ch[t[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			maxl[i] = <span class="built_in">min</span>(maxl[i], cur);<span class="comment">//对maxl[i]取min</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kk; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, maxl[i]);<span class="comment">//取maxl中最大的</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>板子题二：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2463">[SDOI2008]Sandy的卡片</a></p>
<p>对 <strong>差分数组</strong> 做多串匹配就好力。</p>
<hr>
<h5 id="求第-k-大子串"><a href="#求第-k-大子串" class="headerlink" title="求第 $k$ 大子串"></a>求第 $k$ 大子串</h5><p>在之前的应用中，您一定已经熟练运用 SAM 暴切各种子串计数题了。（</p>
<p>而求第 $k$ 大子串正是基于子串统计，您必然又能切个爽。</p>
<p>这一大类问题又细分成两小类：本质不同和位置不同。</p>
<p>我们逐一阐述。</p>
<p><strong>本质不同</strong> 要求我们忽略 <strong>出现位置</strong> 的差异进行计数，对于每一位字符，根据字典序判定大小。</p>
<p>首先，我们需要根据SAM上 $ch$ 的转移，构建出一张 DAG 。再以 $1$ 号结点（代表空串的结点）为根，取一棵 <strong>26叉生成树</strong> （严谨来说不是，但这样感性理解就够了）。</p>
<p>然后，我们要在这个树上<del>瞎jb</del>跳。</p>
<p>具体地，当我们到达了某个点，我们从 $a$～$z$ 枚举出边，若该子树所包含的子串数 <strong>小于</strong> $k$ ，则跳过，当前 $k$ <strong>减去</strong>该子树内子串的个数，决策下一条出边。</p>
<p>直到找到第一条出边，其去向子树的 $size$ <strong>大于等于</strong> 了当前的 $k$ ，则跳向该子树，相当于当前位选择了 <strong>这条出边指向的字符</strong> ，进入下一位的决策……</p>
<p>讲得不明不白，建议作者多学点语文再来这里说话。</p>
<p>如果是不懂思想可以左转 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/quest233/zi-ti-suan-fa-xue-xi-shi-kuang">《紫题算法学习实况》</a> $fhq-treap$ 实现查询第 $k$ 大部分（<del>无端推销</del>）。</p>
<p>建议直接看这部分的瑇码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	k--;<span class="comment">//先减去自己</span></span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>)<span class="comment">//若为0说明这就是第k大</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)<span class="comment">//枚举出边</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (T[u].ch[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[T[u].ch[i]] &lt; k)<span class="comment">//若小于则跳过</span></span><br><span class="line">			&#123;</span><br><span class="line">				k -= dp[T[u].ch[i]];<span class="comment">//减去这些子串</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + i);<span class="comment">//该位选择了这个字符</span></span><br><span class="line">				<span class="built_in">dfs</span>(T[u].ch[i], k);<span class="comment">//进入下一位的决策</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们注意到瑇码里有个 $dp$ 数组，他是干甚么的？<del>根据注释可知</del>，这代表某个 <strong>子树内子串</strong> 的数量。</p>
<p>但如何求 $dp$ 呢？我们用树形 $dp$ 来搞。</p>
<p>这就是赤裸裸的 <strong>子树和</strong> 问题，那么这个 $\orange{\texttt{普及-}}$ 树形dp就没有手也行了：</p>
<script type="math/tex; mode=display">dp_u=1+\sum_{v\in son(u)}dp_v</script><p>下面是瑇码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dp[u])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)<span class="comment">//遍历儿子</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (T[u].ch[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">DP</span>(T[u].ch[i]);</span><br><span class="line">			dp[u] += dp[T[u].ch[i]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>行百里者半九十，我们乘胜追击，把 <strong>位置不同</strong> 一起淦掉。</p>
<p>仔细观察前几题的瑇码会发现，笔者像背板似的在 SAM 还维护了一个东西：</p>
<p><code>T[].siz</code></p>
<p>它是来干嘛的？</p>
<p>我们先认真撕♂尻这样一个问题，我们在SAM里加点，加哪些点的时候会有新串产生，加哪些点的时候不会呢？</p>
<p>加 $np$ 的时候一定是会产生新串的，这点根据定义就可知， $np$ 本身就是我们在原串后 <strong>新加字符</strong> 时的产物。</p>
<p>加 $nq$ 的时候呢？我们其实没有新字符吞进自动姬，只是自动姬自己内部的结点 <strong>裂开来</strong> 而已，串还是那些串，不过是分到了两个等价类罢了/kk 。</p>
<p>所以我们说加 $np$ 会产生新串，加 $nq$ 不会。</p>
<p>那么这个 <code>T[].siz</code> 其实就是某个点 <strong>对子串数的贡献</strong> 。我们对 <code>T[np].siz</code> 初始化为 $1$  ， 对 <code>T[nq].siz</code> 初始化为 $0$ 。 </p>
<p>_需要注意的是 siz 不等于某结点代表的子串数，它是一种贡献，可以看作是一种 <strong>差分标记</strong>（或许可以这么理解？）_</p>
<p>再放送SAM加字符瑇码，加深印象（<del>水字数</del>）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">int</span> np = lst = ++tot;</span><br><span class="line">	T[np].siz = <span class="number">1</span>;<span class="comment">//mark</span></span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		.......</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> nq = ++tot;</span><br><span class="line">			T[nq] = T[q];</span><br><span class="line">			T[nq].siz = <span class="number">0</span>;<span class="comment">//mark</span></span><br><span class="line">			......</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时我们再跑树形 dp ，就得换一个转移方程了。</p>
<p>我们需要先把每个结点 <strong>对应的子串数</strong> 获取出来，我们说 $siz$ 相当于 <strong>差分标记</strong> 其实是有原因的，见下qwq：（ $dp2$ 代表某结点（等价类）中的 <strong>子串数</strong> ）</p>
<script type="math/tex; mode=display">dp2_u=T[u].siz +\sum_{v\in son(u)}dp2_v</script><p>然后再跑常规的路径统计：</p>
<script type="math/tex; mode=display">dp_u=dp2_{u}+\sum_{v\in son(u)}dp_v</script><p>好吧依然是没有手也行。</p>
<p><strong>板子题一</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/SP7258">SP7258 SUBLEX - Lexicographical Substring Search</a></p>
<p>只要求本质不同，连 siz 都不用写。</p>
<p>瑇码详见后面。</p>
<p><strong>板子题二</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3975">[TJOI2015]弦论</a></p>
<p>抓～紧～时～间～打～板～子～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SAM组件*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> len, fa;</span><br><span class="line">	<span class="keyword">int</span> siz;</span><br><span class="line">	<span class="keyword">int</span> ch[<span class="number">26</span>];</span><br><span class="line">	<span class="built_in">node</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		len = fa = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ch));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; T[MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">1</span>, lst = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = lst;</span><br><span class="line">		<span class="keyword">int</span> np = lst = ++tot;</span><br><span class="line">		T[np].siz = <span class="number">1</span>;<span class="comment">//mark</span></span><br><span class="line">		T[np].len = T[p].len + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (p &amp;&amp; !T[p].ch[c])</span><br><span class="line">		&#123;</span><br><span class="line">			T[p].ch[c] = np;</span><br><span class="line">			p = T[p].fa;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!p)</span><br><span class="line">		&#123;</span><br><span class="line">			T[np].fa = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> q = T[p].ch[c];</span><br><span class="line">			<span class="keyword">if</span> (T[q].len == T[p].len + <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				T[np].fa = q;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> nq = ++tot;</span><br><span class="line">				T[nq] = T[q];</span><br><span class="line">				T[nq].siz = <span class="number">0</span>;<span class="comment">//mark</span></span><br><span class="line">				T[nq].len = T[p].len + <span class="number">1</span>;</span><br><span class="line">				T[q].fa = T[np].fa = nq;</span><br><span class="line">				<span class="keyword">while</span> (p &amp;&amp; T[p].ch[c] == q)</span><br><span class="line">				&#123;</span><br><span class="line">					T[p].ch[c] = nq;</span><br><span class="line">					p = T[p].fa;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">namespace</span> st1<span class="comment">//本质不同</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> dp[MAX];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//树形dp，求子树和</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (dp[u])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (T[u].ch[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">DP</span>(T[u].ch[i]);</span><br><span class="line">				dp[u] += dp[T[u].ch[i]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span><span class="comment">//求第k大</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		k--;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (T[u].ch[i])</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (dp[T[u].ch[i]] &lt; k)</span><br><span class="line">				&#123;</span><br><span class="line">					k -= dp[T[u].ch[i]];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">					kk = <span class="number">1</span>;</span><br><span class="line">					<span class="built_in">dfs1</span>(T[u].ch[i], k);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MAIN</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">DP</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> k;</span><br><span class="line">		cin &gt;&gt; k;</span><br><span class="line">		<span class="built_in">dfs1</span>(<span class="number">1</span>, k + <span class="number">1</span>);<span class="comment">//是k+1，因为这会被空串消耗一次</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="comment">// namespace st1</span></span><br><span class="line"><span class="keyword">namespace</span> st2</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> dp2[MAX];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="keyword">int</span> next, to;</span><br><span class="line">	&#125; e[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> head[MAX], eid = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		e[++eid].next = head[x];</span><br><span class="line">		e[eid].to = y;</span><br><span class="line">		head[x] = eid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DP2</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//树形dp，求每个结点对应子串数</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dp2[u] = T[u].siz;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="built_in">DP2</span>(v);</span><br><span class="line">			dp2[u] += dp2[v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> f[MAX];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">redfs</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//再次树形dp，求子树和</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		f[u] = dp2[u];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (T[u].ch[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (!f[T[u].ch[i]])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">redfs</span>(T[u].ch[i]);</span><br><span class="line">				&#125;</span><br><span class="line">				f[u] += f[T[u].ch[i]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span><span class="comment">//求第k大</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		k -= dp2[u];<span class="comment">//注意：这里被消耗的是 dp2[u] 这么多</span></span><br><span class="line">		<span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (T[u].ch[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (f[T[u].ch[i]] &lt; k)</span><br><span class="line">				&#123;</span><br><span class="line">					k -= f[T[u].ch[i]];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">					<span class="built_in">dfs2</span>(T[u].ch[i], k);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">MAIN</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Tree.tot; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">adde</span>(T[i].fa, i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">DP2</span>(<span class="number">1</span>);</span><br><span class="line">		dp2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> k;</span><br><span class="line">		cin &gt;&gt; k;</span><br><span class="line">		<span class="built_in">redfs</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (k &gt; f[<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs2</span>(<span class="number">1</span>, k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="comment">// namespace st2</span></span><br><span class="line"><span class="keyword">char</span> s[MAX];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree.<span class="built_in">add</span>(s[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> opt;</span><br><span class="line">	cin &gt;&gt; opt;</span><br><span class="line">	<span class="keyword">if</span> (opt)</span><br><span class="line">	&#123;</span><br><span class="line">		st2::<span class="built_in">MAIN</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		st1::<span class="built_in">MAIN</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说句闲话</strong>：或许 <strong>“本质不同”</strong> 其实就是 <strong>“位置不同”</strong> 的 dp2=1 的特殊情况罢……</p>
<hr>
<h5 id="获取循环同构的出现情况"><a href="#获取循环同构的出现情况" class="headerlink" title="获取循环同构的出现情况"></a>获取循环同构的出现情况</h5><p>首先你需要知道甚么是循环同构，我们把一个字符串 $t$ 的 <strong>第一个字符放到最后</strong> ，就形成了一个新串，如此往复，它一共会形成 $t.length$ 个新串。</p>
<p>我们把这些新串拿去在另一个串上匹配，看看能匹配上多少。</p>
<p>深得暴力要义的神仙一定已经准备打好多串匹配的代码了，但是除非你是松怪，否则出题人不可能不卡掉你。</p>
<p>我们需要 <strong>深入了解</strong> 后缀自动姬的工作机理。</p>
<p>我们知道跳 $fa$ 相当于在前面删字符，跳 $ch$ 相当于在后面加字符，所以……</p>
<p>我知道了，<del>但你出言不逊是</del> ，我们只需要玩 <strong>转</strong> 后缀自动姬的精妙结构即可，具体步骤如下：</p>
<p>_设匹配串原长为 $n$_</p>
<ol>
<li><p>先对被匹配的串建一只 SAM </p>
</li>
<li><p>读入匹配串，用 <strong>子串判定</strong> 类似的方法，能转移则转移，不能转移就跳 $fa$ ，不断在SAM上跳结点。</p>
</li>
<li><p>把整个串都跳完以后，看看当前跳到的结点的 $len$ 是否 <strong>等于 $n$</strong> 。若等于，则说明这是一种在原串中出现过的串，统计进贡献。</p>
</li>
<li><p>着手在末尾添加字符。照样是能转移则转移，不能转移就跳 $fa$ 。</p>
</li>
<li><p>着手删去第一个字符。如果 $n-1$ <strong>小于</strong> 了该结点的最大长度 $len$ ，$\mathbf{dark}$ 力跳 $fa$ ，否则啥也不干。</p>
</li>
<li><p>看看当前跳到的结点的 $len$ 是否 <strong>等于 $n$</strong> 。若等于，则说明这是一种在原串中出现过的串，统计进贡献。</p>
</li>
<li><p>如此往复 4.5.6 三步，进行 $n-1$ 遍即可。</p>
</li>
</ol>
<p><strong>板子题：</strong> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF235C">CF235C Cyclical Quest</a></p>
<p>太 板 了，具体实现看瑇码+注释。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">2e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SAM组件*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> len, fa;</span><br><span class="line">	<span class="keyword">int</span> ch[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">int</span> siz;</span><br><span class="line">	<span class="built_in">node</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		siz = len = fa = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ch));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; T[MAX];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> lst = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next, to;</span><br><span class="line">&#125; e[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].next = head[x];</span><br><span class="line">	e[eid].to = y;</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = lst;</span><br><span class="line">	<span class="keyword">int</span> np = lst = ++tot;</span><br><span class="line">	T[np].len = T[p].len + <span class="number">1</span>;</span><br><span class="line">	T[np].siz = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; T[p].ch[c] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		T[p].ch[c] = np;</span><br><span class="line">		p = T[p].fa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">	&#123;</span><br><span class="line">		T[np].fa = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> q = T[p].ch[c];</span><br><span class="line">		<span class="keyword">if</span> (T[q].len == T[p].len + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			T[np].fa = q;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> nq = ++tot;</span><br><span class="line">			T[nq] = T[q];</span><br><span class="line">			T[nq].siz = <span class="number">0</span>;</span><br><span class="line">			T[nq].len = T[p].len + <span class="number">1</span>;</span><br><span class="line">			T[q].fa = T[np].fa = nq;</span><br><span class="line">			<span class="keyword">while</span> (p &amp;&amp; T[p].ch[c] == q)</span><br><span class="line">			&#123;</span><br><span class="line">				T[p].ch[c] = nq;</span><br><span class="line">				p = T[p].fa;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*dfs处理各个等价类的出现次数*/</span></span><br><span class="line"><span class="keyword">int</span> vis[MAX], dp[MAX];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[u] = T[u].siz;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">		dp[u] += dp[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">int</span> CC;</span><br><span class="line">	cin &gt;&gt; CC;</span><br><span class="line">	<span class="keyword">int</span> kk = t.<span class="built_in">length</span>();</span><br><span class="line">	t = <span class="string">&#x27; &#x27;</span> + t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kk; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">add</span>(t[i] - <span class="string">&#x27;a&#x27;</span>);<span class="comment">//增量法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">adde</span>(T[i].fa, i);<span class="comment">//连边</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> C = <span class="number">1</span>; C &lt;= CC; C++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		string s;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		<span class="keyword">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">		s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">1</span>, cur = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)<span class="comment">//先跳匹配串，对应步骤2</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (p &amp;&amp; T[p].ch[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p = T[p].fa;</span><br><span class="line">				cur = T[p].len;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">			<span class="keyword">if</span> (T[p].ch[s[i] - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				cur++;</span><br><span class="line">				p = T[p].ch[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (cur == len)<span class="comment">//统计，对应步骤3</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[p] &lt; C)</span><br><span class="line">			&#123;</span><br><span class="line">				ans += dp[p];</span><br><span class="line">				vis[p] = C;<span class="comment">//打标记，以防重复统计</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len - <span class="number">1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (p &amp;&amp; T[p].ch[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)<span class="comment">//末尾添加字符，对应步骤4</span></span><br><span class="line">			&#123;</span><br><span class="line">				p = T[p].fa;</span><br><span class="line">				cur = T[p].len;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (T[p].ch[s[i] - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				cur++;</span><br><span class="line">				p = T[p].ch[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (cur &gt; len &amp;&amp; --cur == T[T[p].fa].len)<span class="comment">//前面删字符，对应步骤5</span></span><br><span class="line">			&#123;</span><br><span class="line">				p = T[p].fa;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (cur == len)<span class="comment">//统计，对应步骤6</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (vis[p] &lt; C)<span class="comment">//为防止清空标记太耗时，故看标记的标号，以辨别不同的询问</span></span><br><span class="line">				&#123;</span><br><span class="line">					ans += dp[p];</span><br><span class="line">					vis[p] = C;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="广义-SAM"><a href="#广义-SAM" class="headerlink" title="广义 SAM"></a>广义 SAM</h5><p>不会，不懂，不想写。（鸽子三连）</p>
<hr>
<hr>
<h3 id="text-LCT-（动态树）"><a href="#text-LCT-（动态树）" class="headerlink" title="$\text{LCT}$ （动态树）"></a>$\text{LCT}$ （动态树）</h3><p><del>“一杯茶，一包烟，一棵LCT调亿天。”</del></p>
<hr>
<h4 id="这是神马东东？"><a href="#这是神马东东？" class="headerlink" title="这是神马东东？"></a>这是神马东东？</h4><p>一种维护树上信息的 <strong>灵活</strong> 的数据结构。（<del>灵活，指在网上看到无数种不同的写法</del>），其最大的特点在于能够 <strong>动态加边断边</strong> 。</p>
<p>您会在接下来很多地方见识到所谓“灵活”的一面。</p>
<hr>
<h4 id="原理？"><a href="#原理？" class="headerlink" title="原理？"></a>原理？</h4><p>把序列上问题强行上树可以变成 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5354">毒瘤</a> ，相反地，把树上问题剖到序列上就会变得清新。</p>
<p>于是 <strong>树链剖分</strong> 横空出世，其下有重剖、长剖、虚实链剖分三类。</p>
<p>重剖和长剖比较守序，它们都是按树形态的 <strong>某一特征</strong> 去剖分。</p>
<p>到了虚实链剖分就开始放飞自我了，怎么剖分是随着人为的操作去决定的。作为一个 <strong>灵活</strong> 的数据结构， $\text{LCT}$ 选择的就是虚实链剖分。</p>
<p>树剖需要一个珂爱的DS来帮助维护剖出的一条一条 <strong>链信息</strong> ，因为我们有加边删边， <strong>相对静态</strong> 的线段树就显得朝不保夕。我们把目光投向了平衡树。</p>
<p>在那么多平衡树里， $splay$ 受到了人类的青睐，它对结点的 <strong>添加、删除、移动</strong> 可以说是行云流水，流畅异常。</p>
<p>所以我们选中 $splay$ 作为辅助维护链信息的DS（后文称之为辅助树），而这里的 $splay$ ，瑇码更近似于《文艺平衡树》。</p>
<p>_闲话：其实 fhq-treap <a target="_blank" rel="noopener" href="https://immortalco.blog.uoj.ac/blog/2342">也能做</a> qwq ，只是多了个 log 罢了_</p>
<hr>
<h4 id="实现？"><a href="#实现？" class="headerlink" title="实现？"></a>实现？</h4><p>接下来，我们尝试用这个 “灵活” 的 LCT ，来实现加边、删边、路径加、路径乘、路径求和。</p>
<p><del>为了装腔作势借以吓人，</del> 我们列举一下一棵 LCT 需要打的珂怕的函数们：</p>
<ul>
<li><p>正统 $splay$ 系：$iden$，$push_up$，$push_down$</p>
</li>
<li><p>$splay\;\times\;LCT$ 混血 （趋近LCT国情的 $splay$ 写法改造）：$isroot$，$rotate$，$splay$</p>
</li>
<li><p>$LCT$ 本地居民：$access$，$make_root$，$split$，$find$，$link$，$cut$</p>
</li>
</ul>
<h4 id="作者意识到自己LCT只会背板子，得找时间深♂入重学"><a href="#作者意识到自己LCT只会背板子，得找时间深♂入重学" class="headerlink" title="作者意识到自己LCT只会背板子，得找时间深♂入重学"></a>作者意识到自己LCT只会背板子，得找时间深♂入重学</h4><hr>
<h3 id="回滚莫队"><a href="#回滚莫队" class="headerlink" title="回滚莫队"></a>回滚莫队</h3><p><del>果然还是小清新数据结构适合我。</del></p>
<hr>
<h4 id="这是神马氡氡"><a href="#这是神马氡氡" class="headerlink" title="这是神马氡氡"></a>这是神马氡氡</h4><p>如果我有一个区间询问，是 $\mathcal{O}(1)$ 插入， $\mathcal{O}(inf)$ 删除的。</p>
<p>普通的莫队在这里就GG了，因为他不可避免地要删除。</p>
<p>此时回滚莫队横空出世。</p>
<p>这是一种能有效鸽掉 <strong>插入/删除</strong> 之间任意一种操作的高级膜队技巧。</p>
<hr>
<h4 id="思想？？？"><a href="#思想？？？" class="headerlink" title="思想？？？"></a>思想？？？</h4><p>删除不能，那我还不能暴力呗。</p>
<p>这是一个臭数组，已经被野兽先辈偷偷用 $sqrt(n)$ 分好了块：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/paxjq6ke.png" alt=""></p>
<p>假设我们求 $[3,5]$ 的区间众数，这玩意加入新元素很轻松，但是删除元素就有些危机。 </p>
<p>从 $L$ 到 $R$ ，这是 $L$ （3），这是 $R$ （5）。<del>这些边我不加，这些边我不加</del>！</p>
<p>暴力怎么做？暴力是不是？装桶，装桶，装桶，然后 $for$ 循环查询。</p>
<p>这个是要用的，先打好。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">baoli</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		c[num[i]]++;<span class="comment">//装桶装桶</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (c[num[i]] &gt; c[ans])<span class="comment">//for循环查询</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans = num[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)<span class="comment">//珍爱生命，远离memset</span></span><br><span class="line">	&#123;</span><br><span class="line">		c[num[i]]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个暴力看上去十分 naive ，接下来，回滚莫队将会展现块与块之间的信息交流的真正妙处。</p>
<p>对于这个 $[3,5]$ 的区间查询，我们先把两个指针，都拉到 $3$ 所在这个块的右边，夹出一块 <strong>空区间</strong>。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/grrkm8jn.png" alt=""></p>
<p>_注：L指针永远指向一格的左边，R指针永远指向一格的右边，以此表示[L,R]是闭的。_</p>
<p>首先我们优先移动 $R$ 指针，它会不断移移移，一路上 <code>add(++R)</code> 。</p>
<p>当我们把 $R$ 移到 $5$ 的时候，我们先 <strong>在这停顿</strong> ，记录下此时更新到的 <strong>众数</strong> $maxx$ ，开一个变量 $store=maxx$ ，显然 $store=1$ 。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/yql5a08z.png" alt=""></p>
<p>这时，我们再向左移动 $L$ 指针，它会不断移移移，一路上 <code>add(--L)</code> 。</p>
<p>等我们移到 $3$ 的时候，我们获得了对于该询问的答案，记录之。</p>
<p>这时我们要询问 $[4,5]$ 了，但我们意识到一个很严肃的问题：<strong>如果删了众数，我们的程序无法知道他的继承人是谁</strong>。</p>
<p>我们之前不是保存了一个 $store$ 表示上图当时情况下的 $maxx$ 吗，我们选择在回答完 $[3,5]$ 后 <strong>恢复</strong> $L$ 指针到 <strong>块右边界</strong> 。</p>
<p>由此一来，两个指针又形成了上图的形势，我们又可以重新任用我们的 $store$ 作为 $maxx$ 了。</p>
<p>以下是处理询问部分的瑇码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*tot——当前处理的询问排序后的编号 ，i——该询问左端点所在块 */</span></span><br><span class="line"><span class="keyword">while</span> (R &lt; q[tot].r)<span class="comment">//移右指针</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">add</span>(++R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> store = maxx;<span class="comment">//在这停顿</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (L &gt; q[tot].l)<span class="comment">//移左指针</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">add</span>(--L);</span><br><span class="line">&#125;</span><br><span class="line">COUT[q[tot].id] = maxx;<span class="comment">//保存答案</span></span><br><span class="line"></span><br><span class="line">maxx = store;<span class="comment">//重新任用store作为maxx</span></span><br><span class="line"><span class="keyword">while</span> (L &lt;= rm[i])<span class="comment">//恢复现场</span></span><br><span class="line">&#123;</span><br><span class="line">	cnt[num[L++]]--;<span class="comment">//把被加上的cnt减回来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可能会感到困惑，为什么又有一个 $tot$ ，又有一个 $i$ 。我们到底在枚举什么？</p>
<p>其实理解了上述思想就自证不难了，我们每次需要把 $L$ 指针移到块右边界，又因膜队的精髓在于尽可能鸽掉 <strong>端点的移动</strong> ，所以我们必然是枚举 <strong>块（i）</strong> 更河里，而 $tot$ 只是顺带着枚举一枚举。</p>
<p>但是还有一个问题，我们每次是把 $R$ 端点右移，我们不能左移 $R$ ，因为左移意味着 <strong>删除</strong> ，而 $R$ 一开始又是在块的右边界上，也就默认了这个询问必然会 <strong>跨块</strong> ，那不跨块的询问怎么办？</p>
<p>别忘了我们的暴力怎么做。不跨块询问区间内元素是 $\sqrt{N}$ 级别的，自然可以放心大胆地暴力。</p>
<p>所以核心瑇码就是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i++)<span class="comment">//B是块数，这里是枚举块</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">	maxx = <span class="number">0</span>;<span class="comment">//归零面对新块</span></span><br><span class="line">    </span><br><span class="line">	R = rm[i];<span class="comment">//R指针放在右边界</span></span><br><span class="line">	<span class="keyword">while</span> (block[q[tot].l] == i)<span class="comment">//对于所有左端点在这个块里的</span></span><br><span class="line">	&#123;</span><br><span class="line">		L = rm[i] + <span class="number">1</span>;<span class="comment">//左端点移到右边界+1，以表空区间</span></span><br><span class="line">		<span class="keyword">if</span> (q[tot].r - q[tot].l &lt;= M)<span class="comment">//小于根号，暴力好耶</span></span><br><span class="line">		&#123;</span><br><span class="line">			COUT[q[tot].id] = <span class="built_in">baoli</span>(q[tot].l, q[tot].r);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//不再重复</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (R &lt; q[tot].r)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">add</span>(++R);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> store = maxx;</span><br><span class="line">			<span class="keyword">while</span> (L &gt; q[tot].l)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">add</span>(--L);</span><br><span class="line">			&#125;</span><br><span class="line">			COUT[q[tot].id] = maxx;</span><br><span class="line">			maxx = store;</span><br><span class="line">			<span class="keyword">while</span> (L &lt;= rm[i])</span><br><span class="line">			&#123;</span><br><span class="line">				cnt[num[L++]]--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tot++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您 naive 地随手上了一个奇偶排序优化，那么之前的努力全部木大。</p>
<p>因为右端点只许右移，所以排序时同块的询问只能以 <strong>右端点递增</strong> 排序。</p>
<p>我们甚至可以用回滚莫队水掉大部分普通莫队的题，复杂度也没差，几乎就是上位了。（当然询问的东西太大（比如一个栈），不能低复杂度保存和重新启用时，还是只能普通莫队）</p>
<hr>
<h4 id="劲爆例题："><a href="#劲爆例题：" class="headerlink" title="劲爆例题："></a>劲爆例题：</h4><p><strong>板子题</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT1219">歴史の研究</a></p>
<p><del>比【模板】还模板的模板题。</del></p>
<p>要求的是 $\max\{num[i]\cdot cnt[num[i]]\}$ 。</p>
<p>这个东西好增不好删，我们着手使用只增不删回滚莫队。</p>
<p>$\text{add}$ 时不断更新 $maxx$ ，回答完一个询问就直接洗地。</p>
<p>存在一个注意点是，这题需要离散化，而上面公式里的第一个 $num[i]$ 应是 <strong>离散化前</strong> 的原值。（<del>可能只有我这种弱智才会因为这个犯错</del>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, id;</span><br><span class="line">&#125; q[MAX];</span><br><span class="line"><span class="keyword">int</span> block[MAX];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a, query b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (block[a.l] != block[b.l])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, Q;</span><br><span class="line"><span class="keyword">int</span> M, B;</span><br><span class="line"><span class="keyword">int</span> cnt[MAX];</span><br><span class="line"><span class="keyword">int</span> num[MAX];</span><br><span class="line"><span class="keyword">int</span> tmp[MAX];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(tmp, num, <span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">	<span class="built_in">sort</span>(tmp + <span class="number">1</span>, tmp + <span class="number">1</span> + N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		num[i] = <span class="built_in">lower_bound</span>(tmp + <span class="number">1</span>, tmp + <span class="number">1</span> + N, num[i]) - tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt[num[p]]++;</span><br><span class="line">	sum = <span class="built_in">max</span>(sum, tmp[num[p]] * cnt[num[p]]);</span><br><span class="line">    <span class="comment">//因为原数组被复制到了tmp数组里去，num[p]其实是其下标</span></span><br><span class="line">    <span class="comment">//所以tmp[num[p]]就是原值了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">baoli</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> kel = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		c[num[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		kel = <span class="built_in">max</span>(kel, c[num[i]] * tmp[num[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		c[num[i]]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> kel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lm[MAX], rm[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B = N / M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		lm[i] = rm[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		rm[i] = lm[i] + M - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (N % M)</span><br><span class="line">	&#123;</span><br><span class="line">		B++;</span><br><span class="line">		lm[B] = rm[B - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		rm[B] = N;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> COUT[MAX];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; Q;</span><br><span class="line">	M = <span class="built_in">sqrt</span>(N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">		block[i] = (i - <span class="number">1</span>) / M + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; q[i].l &gt;&gt; q[i].r;</span><br><span class="line">		q[i].id = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + Q, cmp);</span><br><span class="line">	<span class="built_in">pre</span>();</span><br><span class="line">	<span class="built_in">lsh</span>();<span class="comment">//离散化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*回滚莫队板子*/</span></span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">		sum = <span class="number">0</span>;</span><br><span class="line">		R = rm[i];</span><br><span class="line">		<span class="keyword">while</span> (block[q[tot].l] == i)</span><br><span class="line">		&#123;</span><br><span class="line">			L = rm[i] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (q[tot].r - q[tot].l &lt;= M)</span><br><span class="line">			&#123;</span><br><span class="line">				COUT[q[tot].id] = <span class="built_in">baoli</span>(q[tot].l, q[tot].r);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span> (q[tot].r &gt; R)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">add</span>(++R);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">int</span> store = sum;</span><br><span class="line">				<span class="keyword">while</span> (q[tot].l &lt; L)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">add</span>(--L);</span><br><span class="line">				&#125;</span><br><span class="line">				COUT[q[tot].id] = sum;</span><br><span class="line">				sum = store;</span><br><span class="line">				<span class="keyword">while</span> (L &lt;= rm[i])</span><br><span class="line">				&#123;</span><br><span class="line">					cnt[num[L++]]--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			tot++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; COUT[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>板子题二</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5906">【模板】回滚莫队&amp;不删除莫队</a></p>
<p><del>不板的丢人模板题</del></p>
<p>要求 <strong>相距最远的相同数</strong> 的距离。</p>
<p>某个数的 <strong>极左/极右出现位置</strong> ($fir[i],rig[i]$) 或许很好装，也便于 $\mathcal{O}(1)$ 更新， $\mathcal{O}(1)$ 算答案（ $rig[i]-fir[i]$ ）。</p>
<p>但是我们洗地会极其低效，何出此言？</p>
<p>因为极左这个 <strong>“极”</strong> 字意味着我们不是那么容易恢复现场。举个例子：（<del>这个数组里的臭气被稍加稀释</del>）</p>
<p>回答完 $[1,6]$ 这个询问后，我们是把 $L$ 指针恢复到块右边界，一路上把 $fir[num[i]]$ 清空成 $0$ 。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1gwhgvak.png" alt=""></p>
<p>但如果我们把 $fir[4]$ 清空成 $0$ ，这说明它不再出现。可事实上，$4$ 这个数却确确实实存在于 $L$ 和  $R$ 之间。</p>
<p>如果接下来查询的是 $[2,6]$ ，我们就出锅了，因为我们不再知道在 $3$ 号位置上还有一只 $4$ 。</p>
<p>意识到 $fir$ 的能力是有极限（右边界）的， <strong>维护的数的位置</strong> 越是在 <strong>左端点所在块</strong> 外，清空效力就越鞭长莫及。</p>
<p><del>所以，我不维护啦，JOJO！</del></p>
<p>这里就分出三种情况来：</p>
<ul>
<li><p>对于所有相同数都在块内的情况，我们 $fir$ 是可以顺利完成清空的（从左往右扫，最终清空全块）。</p>
</li>
<li><p>对于一个相同数在块内，一个相同数在块外的情况，即使不小心误清空也不会出锅。反正这个数也只剩一只了，而题目要求的是相距最远的 <strong>两个</strong>，本就统计不进答案。</p>
</li>
<li><p>但有时会出现 <strong>两个相同数都在块外</strong> 的情况，所以我们需要对这种情况进行异化处理。</p>
</li>
</ul>
<p>我们改变 <strong>极左位置</strong>（ $fir$ ） 的定义是：在 <strong>该块右边界之后</strong> 的极左位置。这样我们就可以对两个相同数 <strong>都在块外</strong> 的情况进行 <strong>块内清空后</strong> 的查询。</p>
<p>然而我们不能大E，这样的话，拿什么去算 <strong>两个相同数都在块内</strong> 的答案呢？</p>
<p>我们致远星地发现在同一次查询中，传入 $\text{add}$ 的 $L$ 永远 <strong>递减</strong> ，也就是说，其实我们每次传进去的 $L$ 就已经是这个位置上的数的 <strong>极左位置</strong> 了。</p>
<p>那么也不需要开新数组，以下是 $\text{add}$ 的瑇码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> opt)</span><span class="comment">//opt——若这次移的是L则为1，反之为2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (rig[num[p]] == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//即使我是一个在块内的数</span></span><br><span class="line">        <span class="comment">//但当块外没有相同数的时候，我就是极右的位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			rig[num[p]] = p;</span><br><span class="line">		&#125;</span><br><span class="line">		maxx = <span class="built_in">max</span>(maxx, rig[num[p]] - p);<span class="comment">//直接用 p 就好了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (opt == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (fir[num[p]] == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//因为 R 永远递增</span></span><br><span class="line">        <span class="comment">//所以如果没有块外极左数，那么这个就是了</span></span><br><span class="line">		&#123;</span><br><span class="line">			fir[num[p]] = p;</span><br><span class="line">			dq.<span class="built_in">push_back</span>(p);</span><br><span class="line">       		<span class="comment">//dq 存一些需要清空 fir 的位置</span></span><br><span class="line">            <span class="comment">//到时候对 dq 里的元素一一清空就是</span></span><br><span class="line">		&#125;</span><br><span class="line">		rig[num[p]] = p;<span class="comment">//同上的理由，直接用 p 就好了</span></span><br><span class="line">		maxx = <span class="built_in">max</span>(maxx, rig[num[p]] - fir[num[p]]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很好很好，那么该什么时候清空呢？我们奉行一条原则：</p>
<p>『块内信息在 <strong>单次询问结束</strong> 后清空，块外信息在 <strong>块内所有询问结束</strong> 后清空』</p>
<p>首先，对于 $fir$ 数组不用急着清空，因为这是右边界往后，块外的事了。</p>
<p>其次，对于不在块内的 $rig[i]$ 不用急着清空，原因同上。</p>
<p>换言之，我们只需在一次询问后清空在 <strong>块内</strong> 的 $rig$ 们就可以了。</p>
<p>等到这一块的询问们都已经完成，我们就可以清空 $fir$ 和 $rig$ ，具体要清空的位置已经装到 $dq$ 里了。之所以要存起来再清空，是因为 memset/no。</p>
<p>全瑇码装填：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">4e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*莫队组件*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">&#125; q[MAX];</span><br><span class="line"><span class="keyword">int</span> block[MAX];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a, query b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (block[a.l] != block[b.l])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (a.r != b.r)</span><br><span class="line">		<span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">	<span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, Q;</span><br><span class="line"><span class="keyword">int</span> lm[MAX], rm[MAX];</span><br><span class="line"><span class="keyword">int</span> B, M;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	M = <span class="built_in">sqrt</span>(N);</span><br><span class="line">	B = N / M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		block[i] = (i - <span class="number">1</span>) / M + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		lm[i] = rm[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		rm[i] = lm[i] + M - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (N % M)</span><br><span class="line">	&#123;</span><br><span class="line">		B++;</span><br><span class="line">		lm[B] = rm[B - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		rm[B] = N;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*离散化*/</span></span><br><span class="line"><span class="keyword">int</span> tmp[MAX];</span><br><span class="line"><span class="keyword">int</span> num[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memcpy</span>(tmp, num, <span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">	<span class="built_in">sort</span>(tmp + <span class="number">1</span>, tmp + <span class="number">1</span> + N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		num[i] = <span class="built_in">lower_bound</span>(tmp + <span class="number">1</span>, tmp + <span class="number">1</span> + N, num[i]) - tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*add*/</span></span><br><span class="line"><span class="keyword">int</span> fir[MAX], rig[MAX];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line"><span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (rig[num[p]] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			rig[num[p]] = p;</span><br><span class="line">		&#125;</span><br><span class="line">		maxx = <span class="built_in">max</span>(maxx, rig[num[p]] - p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (opt == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (fir[num[p]] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			fir[num[p]] = p;</span><br><span class="line">			dq.<span class="built_in">push_back</span>(p);</span><br><span class="line">		&#125;</span><br><span class="line">		rig[num[p]] = p;</span><br><span class="line">		maxx = <span class="built_in">max</span>(maxx, rig[num[p]] - fir[num[p]]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*暴力怎么做？！*/</span></span><br><span class="line"><span class="keyword">int</span> ll[MAX], rr[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">baoli</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!ll[num[i]])</span><br><span class="line">		&#123;</span><br><span class="line">			ll[num[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		rr[num[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, rr[num[i]] - ll[num[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll[num[i]] = rr[num[i]] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="built_in">pre</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">lsh</span>();</span><br><span class="line">	cin &gt;&gt; Q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; q[i].l &gt;&gt; q[i].r;</span><br><span class="line">		q[i].id = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + Q, cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		R = rm[i];</span><br><span class="line">		maxx = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (block[q[tot].l] == i)</span><br><span class="line">		&#123;</span><br><span class="line">			L = rm[i] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (q[tot].r - q[tot].l &lt;= M)</span><br><span class="line">			&#123;</span><br><span class="line">				ans[q[tot].id] = <span class="built_in">baoli</span>(q[tot].l, q[tot].r);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span> (R &lt; q[tot].r)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">add</span>(++R, <span class="number">2</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">int</span> store = maxx;</span><br><span class="line">				<span class="keyword">while</span> (L &gt; q[tot].l)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">add</span>(--L, <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				ans[q[tot].id] = maxx;</span><br><span class="line">				maxx = store;</span><br><span class="line">				<span class="keyword">while</span> (L &lt;= rm[i])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (rig[num[L]] == L)<span class="comment">//清空块内rig</span></span><br><span class="line">                    <span class="comment">//等价于其极右位置在该块右边界之前</span></span><br><span class="line">					&#123;</span><br><span class="line">						rig[num[L]] = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					L++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			tot++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dq.<span class="built_in">size</span>(); j++)<span class="comment">//清空fir和块外rig</span></span><br><span class="line">		&#123;</span><br><span class="line">			rig[num[dq[j]]] = <span class="number">0</span>;</span><br><span class="line">			fir[num[dq[j]]] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dq.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个板题一点也不板/fn</p>
<hr>
<p><strong>板子题三</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4137">Rmq Problem / mex</a></p>
<p>让我 <del>DIO</del> 回滚莫队来切这道线段树题。</p>
<p>我们之前说，回滚莫队可以咕掉删除和插入中的任意一种，但是我们还没见到 <strong>咕掉插入</strong> 的回滚莫队。</p>
<p>那么这道就是了。</p>
<p>我们发现删除操作非常容易，看看新删的数是不是不出现了，如果不出现了是不是可以更新答案了。</p>
<p>但加入操作就面临着和 $\color{purple}{\texttt{給朝}}$ 一样的危机——找不到继承人。</p>
<p>那么加入操作不咕也得咕了。</p>
<p>怎么咕？我们把咕删除的回滚莫队换个皮即可。</p>
<p>先把之前的板子 再 放 送 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> L = <span class="number">1</span>, R = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i++)<span class="comment">//B是块数，这里是枚举块</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">	maxx = <span class="number">0</span>;<span class="comment">//归零面对新块</span></span><br><span class="line">    </span><br><span class="line">	R = rm[i];<span class="comment">//R指针放在右边界</span></span><br><span class="line">	<span class="keyword">while</span> (block[q[tot].l] == i)<span class="comment">//对于所有左端点在这个块里的</span></span><br><span class="line">	&#123;</span><br><span class="line">		L = rm[i] + <span class="number">1</span>;<span class="comment">//左端点移到右边界+1，以表空区间</span></span><br><span class="line">		<span class="keyword">if</span> (q[tot].r - q[tot].l &lt;= M)<span class="comment">//暴力</span></span><br><span class="line">		&#123;</span><br><span class="line">			COUT[q[tot].id] = <span class="built_in">baoli</span>(q[tot].l, q[tot].r);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (R &lt; q[tot].r)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">add</span>(++R);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> store = maxx;</span><br><span class="line">			<span class="keyword">while</span> (L &gt; q[tot].l)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">add</span>(--L);</span><br><span class="line">			&#125;</span><br><span class="line">			COUT[q[tot].id] = maxx;</span><br><span class="line">			maxx = store;</span><br><span class="line">			<span class="keyword">while</span> (L &lt;= rm[i])</span><br><span class="line">			&#123;</span><br><span class="line">				cnt[num[L++]]--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tot++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出我们咕删除的回滚莫队是从一个 <strong>空区间</strong> 一步一步加元素来获取到询问区间的，这个过程中只有加没有删。</p>
<p>那么我们咕加入的回滚莫队就是从一个 <strong>满区间</strong> 一步一步删元素来获取到询问区间的，这个过程中只有删没有加。</p>
<p>看上去就像这样？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i++)</span><br><span class="line">&#123;</span><br><span class="line">	mex = kk;<span class="comment">//kk是整个数组的mex，这个可以O(n)预处理</span></span><br><span class="line">	<span class="keyword">while</span> (R &lt; N) <span class="comment">//移动右指针到尽头</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (num[++R] &lt;= N + <span class="number">1</span>)<span class="comment">//mex答案一定 N+1 以下，这个随便证明</span></span><br><span class="line">		&#123;</span><br><span class="line">			cnt[num[R]]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (L &lt; lm[i]) <span class="comment">//移动左指针到左边界</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">del</span>(L++);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//这样一来我们框出了一个 [lm[i],N] 的区间</span></span><br><span class="line">    <span class="comment">//可以保证这一块的所有询问一定在这个区间中发生</span></span><br><span class="line">    </span><br><span class="line">	kk = mex;</span><br><span class="line">	<span class="keyword">while</span> (block[q[tot].l] == i)<span class="comment">//大体相同</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (block[q[tot].r] == i)<span class="comment">//和作差等价的写法，换换口味</span></span><br><span class="line">		&#123;</span><br><span class="line">			COUT[q[tot].id] = <span class="built_in">baoli</span>(q[tot].l, q[tot].r);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (R &gt; q[tot].r)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">del</span>(R--);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> store = mex;</span><br><span class="line">			<span class="keyword">while</span> (L &lt; q[tot].l)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">del</span>(L++);</span><br><span class="line">			&#125;</span><br><span class="line">			COUT[q[tot].id] = mex;</span><br><span class="line">			mex = store;</span><br><span class="line">			<span class="keyword">while</span> (L &gt; lm[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (num[--L] &lt;= N + <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					cnt[num[L]]++;<span class="comment">//恢复L指针到左边界</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tot++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个 $\text{del}$ 函数里面是肾么呢？</p>
<p>正如我们之前说的“康康新删的数是不是不出现了，如果不出现了是不是可以更新答案了”。这个很好写，在此不表。</p>
<p>还有一个问题，这个排序还能按源赖这么排吗？</p>
<p>答案是否定的，因为你的 $R$ 指针将会从右往左递减，所以应在 $L$ 同块时将 $R$ <strong>降序</strong> 排列。</p>
<p>那么你就可以把回滚莫队板子改几个bit直接爆切此题了！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">&#125; q[MAX];</span><br><span class="line"><span class="keyword">int</span> block[MAX];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query a, query b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (block[a.l] != block[b.l])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a.r &gt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, Q, M, B;</span><br><span class="line"><span class="keyword">int</span> num[MAX], cnt[MAX];</span><br><span class="line"><span class="keyword">int</span> mex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num[p] &lt;= N + <span class="number">1</span>) <span class="comment">//答案上界为N+1，所以只统计到N+1</span></span><br><span class="line">	&#123;</span><br><span class="line">		cnt[num[p]]--;</span><br><span class="line">		<span class="keyword">if</span> (cnt[num[p]] == <span class="number">0</span>) <span class="comment">//如果有一个数被删没了</span></span><br><span class="line">		&#123;</span><br><span class="line">			mex = <span class="built_in">min</span>(mex, num[p]); <span class="comment">//看看这个数能不能作新mex</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">baoli</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">//暴力，交了一发没锅</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (num[i] &lt;= N + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			c[num[i]]++;</span><br><span class="line">			<span class="keyword">while</span> (c[ans]) <span class="comment">//找到下一个没出现的</span></span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) <span class="comment">//恢复现场</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (num[i] &lt;= N + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			c[num[i]]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> lm[MAX], rm[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> <span class="comment">//预处理每块左右界</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B = N / M; <span class="comment">//块数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		lm[i] = rm[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		rm[i] = lm[i] + M - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (N % M) <span class="comment">//如果不能整除</span></span><br><span class="line">	&#123;</span><br><span class="line">		B++; <span class="comment">//开一边角块</span></span><br><span class="line">		lm[B] = rm[B - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		rm[B] = N;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[MAX];</span><br><span class="line"><span class="keyword">int</span> COUT[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; Q;</span><br><span class="line">	M = <span class="built_in">sqrt</span>(N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">		block[i] = (i - <span class="number">1</span>) / M + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (num[i] &lt;= N + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt[num[i]]++; <span class="comment">//用于求最初mex</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (cnt[mex])</span><br><span class="line">	&#123;</span><br><span class="line">		mex++; <span class="comment">//得到全局mex</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; q[i].l &gt;&gt; q[i].r;</span><br><span class="line">		q[i].id = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pre</span>();</span><br><span class="line">	<span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + Q, cmp);</span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">1</span>, R = N;</span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> kk = mex;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		mex = kk;</span><br><span class="line">		<span class="keyword">while</span> (R &lt; N) <span class="comment">//移动右指针到尽头</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (num[++R] &lt;= N + <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cnt[num[R]]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (L &lt; lm[i]) <span class="comment">//移动左指针到</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">del</span>(L++);</span><br><span class="line">		&#125;</span><br><span class="line">		kk = mex;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (block[q[tot].l] == i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (block[q[tot].r] == i)</span><br><span class="line">			&#123;</span><br><span class="line">				COUT[q[tot].id] = <span class="built_in">baoli</span>(q[tot].l, q[tot].r);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span> (R &gt; q[tot].r)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">del</span>(R--);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">int</span> store = mex;</span><br><span class="line">				<span class="keyword">while</span> (L &lt; q[tot].l)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">del</span>(L++);</span><br><span class="line">				&#125;</span><br><span class="line">				COUT[q[tot].id] = mex;</span><br><span class="line">				mex = store;</span><br><span class="line">				<span class="keyword">while</span> (L &gt; lm[i])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (num[--L] &lt;= N + <span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						cnt[num[L]]++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			tot++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; COUT[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h3 id="Polya-定理"><a href="#Polya-定理" class="headerlink" title="Polya 定理"></a>Polya 定理</h3><p>你会发现 qst 这个废物甚至连定理的名字都打不出来，好在问题不是很大。</p>
<hr>
<h4 id="这是神马东东"><a href="#这是神马东东" class="headerlink" title="这是神马东东"></a>这是神马东东</h4><p>Polya 定理是一种通过计算置换群来数出染色方案的一种神仙玩意，当然这只是数学菜鸡的口胡理解，也就图一乐，真要看严谨说法还得看队爷们的论文。</p>
<hr>
<h4 id="性感理解置换"><a href="#性感理解置换" class="headerlink" title="性感理解置换"></a>性感理解置换</h4><ul>
<li>我们把 $(^{1\ 2\ 3\ 4\ 5\ 6}_{1\ 3\ 2\ 5\ 6\ 4})$ 这样的上面是一个排列，下面是一个排列的东东叫做置换。</li>
<li>可以把他看作是一个加密规则，加密的过程相当于把一个上面的数替换成下面的数。</li>
<li>我们总是能从置换里找到一些循环，比如 $(^{1\ 2\ 3\ 4\ 5\ 6}_{1\ 3\ 2\ 5\ 6\ 4})$ 就由 $(^{1}_{1})(^{2\ 3}_{3\ 2})(^{4\ 5\ 6}_{5\ 6\ 4})$ 三个循环组成。</li>
<li>“组成”这个动词显得非常 naive ，我们一般称：<strong>这个置换是这些循环的乘积</strong>。</li>
<li>不动点，顾名思义，就是经过置换后不变的元素。</li>
<li>对于置换，我们也定义了两个置换的乘积：$P_1=\binom{1\ \ 2\ \ 3\ \ 4}{a_1\ a_2\ a_3\ a_4},P_2=\binom{a_1\ a_2\ a_3\ a_4}{b_1\ b_2\ b_3\ b_4},P_1*P_2=\binom{1\ \ 2\ \ 3\ \ 4}{b_1\ b_2\ b_3\ b_4}$</li>
<li>看上去就像原序列先经过 $P_1$ 加密规则加密后的密文，再用 $P_2$ 加密一遍？</li>
<li>置换群就是一堆置换的集合。</li>
</ul>
<hr>
<h4 id="Burnside-引理"><a href="#Burnside-引理" class="headerlink" title="Burnside 引理"></a>Burnside 引理</h4><p>事实上直接背诵这个引理的内容就完全够用了，如果要去强行理解那些“稳定化子”啥的概念的话可能一不小心就会掉进群论的深渊（（</p>
<p>有些题目让我们数一些对象的染色方案，这些染色方案会有一个“置换等价”的限制，即：</p>
<p><strong>如果通过某种特定的变换，两组染色方案可以互相转化，则称这两个方案是本质相同的。</strong></p>
<p>Burnside 引理就是用来数这种受“置换等价”限制的玩意的。</p>
<p>你可以在各大网站上看到这个引理名字的无数种翻译，什么“烧边”啊，“伯恩赛德”啊，为了不至于造成差异，这里直接采用英文。</p>
<p>在 Burnside 引理中，我们用 <strong>染色方案的置换</strong> 来表达变换的动作，那题目给出的这些变换就组成了一个置换群。</p>
<p>设 $G$ 是给出的置换群，$C(f)$ 是置换 $f$ 中不动点的个数，$N(G,C)$ 表示所有本质不同的染色方案种类数。</p>
<p>其内容如下：</p>
<script type="math/tex; mode=display">
N(G,C)=\dfrac{\sum_{f\in G}C(f)}{|G|}</script><p>用人话翻译一遍，就是：染色方案的数量是 <strong>所有置换中不动点个数 </strong>的平均数。</p>
<p>现在您可能还是一头雾水，不妨下面我们尝试运用这一武器来数一些东西。</p>
<p><strong>试看看：</strong></p>
<p>有一个 $2\times2$ 的方格，我们可以将每一格染成红色或白色，<strong>如果通过旋转一定角度，两组染色方案可以互相转化，则称这两个方案是本质相同的</strong>，求本质不同染色方案数。</p>
<p><del>本质不同波兰国旗计数</del></p>
<p>我们先把所有染色方案列出来，一共有 $2^4=16$ 种。 </p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7wgd42cy.png" alt=""></p>
<p>题目给出了置换等价的信息是旋转等价，胡乱思尻一下就知道其实只有四种可能的旋转角度（默认顺时针）：0°，90°，180°，270°。</p>
<p>我们把染色方案从1到16标号，用旋转90度作为栗子，我们尝试用置换来表达【旋转90度】这一动作：</p>
<script type="math/tex; mode=display">
\binom{1\;2\;3\;4\;5\;6\;7\;8\;9\;10\;11\;12\;13\;14\;15\;16}{1\;3\;5\;2\;4\;7\;8\;9\;6\;11\;10\;13\;14\;15\;12\;16}</script><p>X号元素置换到Y号，就代表X号染色方案旋转90°达到Y号方案。（你也大可理解成X号是Y号方案旋转90°得来，只不过要换一种写法，不动点的个数还是一样的qaq）</p>
<p>那么扳手指头就知道这一置换有 2 个不动点。</p>
<p>把所有旋转情况的不动点个数都扳出来后，再套上珂爱的 Burnside 引理求解：</p>
<script type="math/tex; mode=display">
N=\dfrac{16+2+4+2}{4}=6</script><p>那么本质不同的 <del>波兰国旗</del> 染色方案就有 6 种辣，<del>经过手玩验证</del> ，这一答案是正确的。</p>
<hr>
<h4 id="Polya-定理-1"><a href="#Polya-定理-1" class="headerlink" title="Polya 定理"></a>Polya 定理</h4><p>刚才扳手指头的过程让我们感到苦涩（<del>至少我打 Latex 打得很苦涩</del>），如果我们数的不是波兰国旗而是俄罗斯国旗甚至泰国国旗，那我们的手指恐怕有些危机。</p>
<p>而 Polya 定理的出现挽救 OIer 于水深火热之中（（</p>
<p>Polya 定理并不依赖于求出置换群的过程，也就是说，我们不需要求出染色方案的置换群就可以直接数。</p>
<p>其内容大致如下。</p>
<p>我们之前是用【染色方案的置换】来表达一个动作的，但事实上，这样的数据往往是巨大多量的。</p>
<p>这时我们发现，在旋转过程中，染色对象内部的各个元素也存在一个置换关系，比如这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/z926nywz.png" alt=""></p>
<p>旋转 90° 的变换，其实对象内部存在置换 $\binom{1\ 2\ 3\ 4}{3\ 1\ 4\ 2}$ 。</p>
<p>如果我们不求出各个染色方案之间的置换，而只关注于染色对象内部的元素的置换，就把处理的置换规模从 $M^N$ 级别转化成了 $N$ 。</p>
<p>我们知道一个置换可以拆分成几个循环的乘积，设 $R(f)$ 为置换 $f$ 中的循环个数（这里的置换是 <strong>对象内部元素</strong> 的置换），$M$ 为颜色数，我们有：</p>
<script type="math/tex; mode=display">
N=\dfrac{\sum_{f\in G}M^{R(f)}}{|G|}</script><p>还是一样的题，我们用 Polya 定理来切这道题：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7wgd42cy.png" alt=""></p>
<p>转 90° 会带来对象内元素什么样的置换？之前已经提到了，是 $\binom{1\ 2\ 3\ 4}{3\ 1\ 4\ 2}$ ，这个置换中有 1 个循环。</p>
<p>同理，转 180° 的置换是 $\binom{1\ 2\ 3\ 4}{4\ 3\ 2\ 1}$ ，这个置换中有 2 个循环。</p>
<p>而转 270° 有 1 个循环，转 0° 有 4 个循环。</p>
<p>那么答案就是：</p>
<script type="math/tex; mode=display">
N=\dfrac{2^1+2^2+2^1+2^4}{4}=6</script><p>这和我们烧边烧出来的结果是一样的。</p>
<p>好耶！</p>
<p>数波兰国旗非常无聊且枯燥，因为循环节用脚趾头也能数出来，接下来我们尝试数项链。</p>
<p>我们定义一串项链由一圈珠（<del>柱</del>）子串成，它满足旋转同构，即旋转一定角度后相同则本质相同。</p>
<h3 id="咕咕咕！"><a href="#咕咕咕！" class="headerlink" title="咕咕咕！"></a>咕咕咕！</h3>
            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2021年04月18日 16:33</p>
        <p>原始链接： <a class="post-url" href="/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5-II/" title="紫题算法学习实况 II">https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5-II/</a></p>
        <footer>
            <a href="https://quest233.github.io">
                <img src="/images/150879.png" alt="quest_2">
                quest_2
            </a>
        </footer>
    </div>
</div>

      
        
            

        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5-II/&title=《紫题算法学习实况 II》 — quest233的博客&pic=https://quest233.github.ioimages/150879.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5-II/&title=《紫题算法学习实况 II》 — quest233的博客&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5-II/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《紫题算法学习实况 II》 — quest233的博客&url=https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5-II/&via=https://quest233.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5-II/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5-II/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/“知识”决定命运/" class="color4">“知识”决定命运</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#2021-01-09%EF%BC%9A%E6%84%89%E6%82%A6%E6%BB%9A%E5%8E%BBwhk%EF%BC%8C%E6%9C%AC%E6%96%87%E5%BA%94%E8%AF%A5%E9%95%BF%E6%9C%9F%E4%B8%8D%E6%9B%B4%E4%BA%86%EF%BC%88%E5%92%95%EF%BC%89"><span class="post-toc-text">2021-01-09：愉悦滚去whk，本文应该长期不更了（咕）</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#2021-01-17%EF%BC%9A%E7%88%AC%E5%9B%9E%E6%9C%BA%E6%88%BF%E9%87%8D%E6%96%B0%E9%98%85%E8%AF%BB%E4%BA%86%E4%B8%80%E4%B8%8B%E6%9C%AC%E6%96%87%EF%BC%8C%E4%BF%AE%E4%BA%86%E5%A4%A7%E9%87%8F%E8%AF%AD%E6%96%87%E9%94%85"><span class="post-toc-text">2021-01-17：爬回机房重新阅读了一下本文，修了大量语文锅</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SAM"><span class="post-toc-text">SAM</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#endpos-%EF%BC%9F"><span class="post-toc-text">$endpos$ ？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%80%A7%E8%B4%A8%E3%80%87%EF%BC%9A%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%B8%AA%E5%AD%90%E4%B8%B2%E7%9A%84%E5%90%8E%E7%BC%80%E4%BB%AC%EF%BC%8C%E8%B6%8A%E9%95%BF%E7%9A%84%E5%90%8E%E7%BC%80%E6%89%80%E6%8B%A5%E6%9C%89-endpos-%E9%9B%86%E5%90%88%E8%B6%8A%E5%B0%8F%EF%BC%8C%E5%8F%8D%E4%B9%8B%E5%88%99%E5%8F%8D%E4%B9%8B%E3%80%82"><span class="post-toc-text">性质〇：对于一个子串的后缀们，越长的后缀所拥有 $endpos$ 集合越小，反之则反之。</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%80%A7%E8%B4%A8%E4%B8%80%EF%BC%9A%E5%A6%82%E6%9E%9C%E4%B8%A4%E4%B8%AA%E5%AD%90%E4%B8%B2%E7%9A%84-endpos-%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%88%99%E4%B8%80%E4%B8%AA%E4%B8%AD%E7%9A%84%E5%AD%90%E4%B8%B2%E5%BF%85%E7%84%B6%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%9A%84%E5%90%8E%E7%BC%80"><span class="post-toc-text">性质一：如果两个子串的 $endpos$ 有相同的元素，则一个中的子串必然为另一个的后缀</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%80%A7%E8%B4%A8%E4%BA%8C%EF%BC%9A%E4%B8%A4%E4%B8%AA%E5%AD%90%E4%B8%B2-a-b-%EF%BC%8C%E8%A6%81%E4%B9%88%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%9A%84-endpos-%E5%8C%85%E5%90%AB%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%9A%84%EF%BC%8C%E8%A6%81%E4%B9%88%E4%B8%A4%E8%80%85%E7%9A%84-endpos-%E6%B2%A1%E6%9C%89%E4%BA%A4%E9%9B%86%E3%80%82"><span class="post-toc-text">性质二：两个子串 $a,b$ ，要么其中一个的 $endpos$ 包含另一个的，要么两者的 $endpos$ 没有交集。</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%80%A7%E8%B4%A8%E4%B8%89%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%8A%8A%E6%89%80%E6%9C%89-endpos-%E9%9B%86%E5%90%88%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E4%B8%B2%E5%BD%92%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%AD%89%E4%BB%B7%E7%B1%BB%E9%87%8C%EF%BC%8C%E9%82%A3%E4%B9%88%E6%AF%8F%E4%B8%AA-endpos-%E7%9A%84%E7%AD%89%E4%BB%B7%E7%B1%BB%E9%87%8C%E7%9A%84%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6%E8%BF%9E%E7%BB%AD%E3%80%82"><span class="post-toc-text">性质三：如果把所有 $endpos$ 集合完全相同的子串归在一个等价类里，那么每个 $endpos$ 的等价类里的子串长度连续。</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%8F%92%E6%92%AD%EF%BC%9A-parent-tree-%EF%BC%9F"><span class="post-toc-text">插播：$parent\ tree$ ？</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%80%A7%E8%B4%A8%E5%9B%9B%EF%BC%9A%E5%A6%82%E6%9E%9C%E4%B8%A4%E4%B8%AA%E7%AD%89%E4%BB%B7%E7%B1%BB-A-B-%EF%BC%8C%E5%9C%A8-parent-tree-%E4%B8%8A-B-%E6%98%AF-A-%E7%9A%84%E7%88%B6%E4%BA%B2-%EF%BC%8C%E9%82%A3%E4%B9%88-B-%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6-1%EF%BC%8C%E4%B8%80%E5%AE%9A%E7%AD%89%E4%BA%8E-A-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6%E3%80%82"><span class="post-toc-text">性质四：如果两个等价类 $A,B$ ，在 $parent\ tree$ 上 $B$ 是 $A$ 的父亲 ，那么 $B$ 的最长子串的长度+1，一定等于 $A$ 的最短子串的长度。</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9E%84%E5%BB%BA%E4%B8%80%E5%8F%B0%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E5%A7%AC"><span class="post-toc-text">构建一台后缀自动姬</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Step-0-%EF%BC%9A%E6%9C%89%E5%85%B3%E5%8F%98%E9%87%8F"><span class="post-toc-text">$Step\ 0$：有关变量</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Step-1-%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="post-toc-text">$Step\ 1$：构建前的准备工作</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Step-2-%EF%BC%9A%E9%81%8D%E5%8E%86%E6%96%B0%E4%B8%B2%E5%90%8E%E7%BC%80%EF%BC%8C%E5%88%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BA%E7%8E%B0%E8%BF%87%E7%9A%84%E5%AD%90%E4%B8%B2%E4%B8%BA%E6%AD%A2"><span class="post-toc-text">$Step\ 2$：遍历新串后缀，到第一个出现过的子串为止</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Step-3-%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%A7%AC%E7%9A%84%E5%A4%84%E7%90%86%E8%AE%A1%E5%88%92%E4%B8%80"><span class="post-toc-text">$Step\ 3$：自动姬的处理计划一</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Step-4-%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%A7%AC%E7%9A%84%E5%A4%84%E7%90%86%E8%AE%A1%E5%88%92%E4%BA%8C"><span class="post-toc-text">$Step\ 4$：自动姬的处理计划二</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link"><span class="post-toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56

&#x2F;*Step 1*&#x2F;
struct node
&amp;#123;
	int len, fa;
	int ch[26];
	int siz;
	node()
	&amp;#123;
		siz &#x3D; len &#x3D; fa &#x3D; 0;
		memset(ch, 0, sizeof(ch));
	&amp;#125;
&amp;#125; T[MAX];
int tot &#x3D; 1;
int lst &#x3D; 1;


void add(int c)
&amp;#123;
	&#x2F;*Step 2*&#x2F;
	int p &#x3D; lst;
	int np &#x3D; lst &#x3D; ++tot;
	T[np].len &#x3D; T[p].len + 1;
	while (p &amp;&amp; T[p].ch[c] &#x3D;&#x3D; 0)
	&amp;#123;
		T[p].ch[c] &#x3D; np;
		p &#x3D; T[p].fa;
	&amp;#125;
	if (!p)
	&amp;#123;
		T[np].fa &#x3D; 1;
	&amp;#125;
	else
	&amp;#123;
    	&#x2F;*Step 3*&#x2F;
		int q &#x3D; T[p].ch[c];
		if (T[q].len &#x3D;&#x3D; T[p].len + 1)
		&amp;#123;
			T[np].fa &#x3D; q;
		&amp;#125;
        
        &#x2F;*Step 4*&#x2F;
		else
		&amp;#123;
			int nq &#x3D; ++tot;
			T[nq] &#x3D; T[q];
			T[nq].len &#x3D; T[p].len + 1;
			T[q].fa &#x3D; T[np].fa &#x3D; nq;
			while (p &amp;&amp; T[p].ch[c] &#x3D;&#x3D; q)
			&amp;#123;
				T[p].ch[c] &#x3D; nq;
				p &#x3D; T[p].fa;
			&amp;#125;
		&amp;#125;
	&amp;#125;
&amp;#125;
</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8"><span class="post-toc-text">简单应用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E4%B8%B2-A-%E6%98%AF%E5%90%A6%E6%98%AF%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%B8%B2-B-%E7%9A%84%E5%AD%90%E4%B8%B2"><span class="post-toc-text">判断一个串 $A$ 是否是另一个串 $B$ 的子串</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%9C%AC%E8%B4%A8%E4%B8%8D%E5%90%8C%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0"><span class="post-toc-text">本质不同子串个数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="post-toc-text">获取两个串的最长公共子串的长度</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2"><span class="post-toc-text">获取多串的最长公共子串</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%B1%82%E7%AC%AC-k-%E5%A4%A7%E5%AD%90%E4%B8%B2"><span class="post-toc-text">求第 $k$ 大子串</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BE%AA%E7%8E%AF%E5%90%8C%E6%9E%84%E7%9A%84%E5%87%BA%E7%8E%B0%E6%83%85%E5%86%B5"><span class="post-toc-text">获取循环同构的出现情况</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%B9%BF%E4%B9%89-SAM"><span class="post-toc-text">广义 SAM</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#text-LCT-%EF%BC%88%E5%8A%A8%E6%80%81%E6%A0%91%EF%BC%89"><span class="post-toc-text">$\text{LCT}$ （动态树）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%99%E6%98%AF%E7%A5%9E%E9%A9%AC%E4%B8%9C%E4%B8%9C%EF%BC%9F"><span class="post-toc-text">这是神马东东？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="post-toc-text">原理？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="post-toc-text">实现？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BD%9C%E8%80%85%E6%84%8F%E8%AF%86%E5%88%B0%E8%87%AA%E5%B7%B1LCT%E5%8F%AA%E4%BC%9A%E8%83%8C%E6%9D%BF%E5%AD%90%EF%BC%8C%E5%BE%97%E6%89%BE%E6%97%B6%E9%97%B4%E6%B7%B1%E2%99%82%E5%85%A5%E9%87%8D%E5%AD%A6"><span class="post-toc-text">作者意识到自己LCT只会背板子，得找时间深♂入重学</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9B%9E%E6%BB%9A%E8%8E%AB%E9%98%9F"><span class="post-toc-text">回滚莫队</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%99%E6%98%AF%E7%A5%9E%E9%A9%AC%E6%B0%A1%E6%B0%A1"><span class="post-toc-text">这是神马氡氡</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%80%9D%E6%83%B3%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="post-toc-text">思想？？？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%B2%E7%88%86%E4%BE%8B%E9%A2%98%EF%BC%9A"><span class="post-toc-text">劲爆例题：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Polya-%E5%AE%9A%E7%90%86"><span class="post-toc-text">Polya 定理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%99%E6%98%AF%E7%A5%9E%E9%A9%AC%E4%B8%9C%E4%B8%9C"><span class="post-toc-text">这是神马东东</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%80%A7%E6%84%9F%E7%90%86%E8%A7%A3%E7%BD%AE%E6%8D%A2"><span class="post-toc-text">性感理解置换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Burnside-%E5%BC%95%E7%90%86"><span class="post-toc-text">Burnside 引理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Polya-%E5%AE%9A%E7%90%86-1"><span class="post-toc-text">Polya 定理</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%92%95%E5%92%95%E5%92%95%EF%BC%81"><span class="post-toc-text">咕咕咕！</span></a>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2021/04/17/%E8%81%94%E5%90%88%E7%9C%81%E9%80%89%E5%88%92%E6%B0%B4%E8%AE%B0/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          联合省选划水记
        
      </span>
    </a>
  
  
    <a href="/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">紫题算法学习实况</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
          <div id="uyan_frame"></div>
  <script src="http://v2.uyan.cc/code/uyan.js?uid=true"></script>

    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2021 quest_2<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://quest233.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 0
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/solutions/" style="font-size: 20px;">solutions</a> <a href="/tags/water/" style="font-size: 10px;">water</a> <a href="/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/" style="font-size: 15px;">“知识”决定命运</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/2021/04/17/About/#more">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/solutions/" style="font-size: 20px;">solutions</a> <a href="/tags/water/" style="font-size: 10px;">water</a> <a href="/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/" style="font-size: 15px;">“知识”决定命运</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>