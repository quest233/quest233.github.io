<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="referrer" content="no-referrer" />
  
  <title>紫题算法学习实况 | quest233的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="quest_2" />
  
  <meta name="description" content="因为进不去复赛就只能休养休养生息，整点算法学学。和同机房的神仙相比，窝挖的坑实在是太多了 $OvO$ 。 2020-10-21：竟然与he老爷讲课撞车了，两相对比显然突出窝的菜2020-11-16：CSP-S又垫底了，可以安心写博客力2020-12-26：该文章已停更，光标几乎卡的动不了了 《实况一》（本文）中包含的内容：  点分治  点分树  fhq  网络流  杜教筛    点分治“每天就是">
<meta property="og:type" content="article">
<meta property="og:title" content="紫题算法学习实况">
<meta property="og:url" content="https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5/index.html">
<meta property="og:site_name" content="quest233的博客">
<meta property="og:description" content="因为进不去复赛就只能休养休养生息，整点算法学学。和同机房的神仙相比，窝挖的坑实在是太多了 $OvO$ 。 2020-10-21：竟然与he老爷讲课撞车了，两相对比显然突出窝的菜2020-11-16：CSP-S又垫底了，可以安心写博客力2020-12-26：该文章已停更，光标几乎卡的动不了了 《实况一》（本文）中包含的内容：  点分治  点分树  fhq  网络流  杜教筛    点分治“每天就是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/dnj580bl.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/oigtkvmd.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/t0fekm4g.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/sbd676vz.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/jvjbfh6p.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/8is0o5v5.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/ezfg3y6n.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/m6iqkoed.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/wzkq03ll.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/6qvz39u7.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/9js2l1lk.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/x3x1qn0y.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/mvau49ej.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/648rdi1u.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/fzwy996m.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/phk99zjp.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/pr82ttfy.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/4h37evq5.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/l1mggdnp.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/24xf1ztt.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/i7k25dmu.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/pic/2669.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/pssyi5aw.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/pic/37260.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/hctsarux.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/hxevwuo8.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/5hec6crl.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/zow878de.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/m8c4a1c0.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/qgpn1rls.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/hu55cdoh.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/ma6s1pkz.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/0n61w7i0.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/b90eyk77.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/3lmb71x0.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/0rk5db7y.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/bzhlnt5c.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/pssyi5aw.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/fu63025z.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/2ztswi4d.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/zow878de.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/4nc0stxw.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/i1qlnrf1.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/hu55cdoh.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/h5t8vgit.png">
<meta property="article:published_time" content="2021-04-17T07:10:13.000Z">
<meta property="article:modified_time" content="2021-08-03T02:16:32.464Z">
<meta property="article:author" content="quest_2">
<meta property="article:tag" content="“知识”决定命运">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.luogu.com.cn/upload/image_hosting/dnj580bl.png">
  
  
    <link rel="icon" href="images/62224.png">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">quest_2&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/2021/04/17/About/#more">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/150879.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        quest_2&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        “知识”决定命运
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-紫题算法学习实况" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      紫题算法学习实况
    </h1>
    <div class="post-title-bar">
      <ul>
          
        <li>
          <i class="fa fa-calendar"></i>  2021-04-17
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <hr>
<h6 id="因为进不去复赛就只能休养休养生息，整点算法学学。"><a href="#因为进不去复赛就只能休养休养生息，整点算法学学。" class="headerlink" title="因为进不去复赛就只能休养休养生息，整点算法学学。"></a><del>因为进不去复赛就只能休养休养生息，整点算法学学。</del></h6><p>和同机房的神仙相比，窝挖的坑实在是太多了 $OvO$ 。</p>
<h6 id="2020-10-21：竟然与he老爷讲课撞车了，两相对比显然突出窝的菜"><a href="#2020-10-21：竟然与he老爷讲课撞车了，两相对比显然突出窝的菜" class="headerlink" title="2020-10-21：竟然与he老爷讲课撞车了，两相对比显然突出窝的菜"></a>2020-10-21：竟然与he老爷讲课撞车了，两相对比显然突出窝的菜</h6><h6 id="2020-11-16：CSP-S又垫底了，可以安心写博客力"><a href="#2020-11-16：CSP-S又垫底了，可以安心写博客力" class="headerlink" title="2020-11-16：CSP-S又垫底了，可以安心写博客力"></a>2020-11-16：CSP-S又垫底了，可以安心写博客力</h6><h6 id="2020-12-26：该文章已停更，光标几乎卡的动不了了"><a href="#2020-12-26：该文章已停更，光标几乎卡的动不了了" class="headerlink" title="2020-12-26：该文章已停更，光标几乎卡的动不了了"></a>2020-12-26：该文章已停更，光标几乎卡的动不了了</h6><hr>
<p>《实况一》（本文）中包含的内容：</p>
<ul>
<li><p>点分治</p>
</li>
<li><p>点分树</p>
</li>
<li><p>fhq</p>
</li>
<li><p>网络流</p>
</li>
<li><p>杜教筛</p>
</li>
</ul>
<hr>
<h3 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h3><p>“<del>每天就是切一些 N 倍经验题，维持维持生活这样子。</del>”</p>
<h4 id="处理什么问题："><a href="#处理什么问题：" class="headerlink" title="处理什么问题："></a>处理什么问题：</h4><p>大部分是树上点对距离问题，当然还有一些变形。（<del>树论毒瘤爪巴</del>）</p>
<p>如果给您一棵树，让您查询树上是否存在两点距离为 $K$ 。您没学过点分治，您怎么做？</p>
<p>您说，您会暴力 $O(n^2)$ 枚举点对查询其距离！</p>
<p>抱歉，点分治是可以 $O(n\log n)$ 的。</p>
<h4 id="思想是什么："><a href="#思想是什么：" class="headerlink" title="思想是什么："></a>思想是什么：</h4><p>现在讲一下思想。</p>
<p>树上两点之间，路径唯一 ，<strong>两点通向LCA的路径的并</strong>，即为两点之间的路径。</p>
<p>这种路径要分类无非两种：过 <strong>全树的根</strong> 结点的，和 <strong>不过根</strong> 结点的。</p>
<p>或者换种说法，LCA是全树的根结点的，或者不是根结点的。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/dnj580bl.png" alt=""></p>
<p>（超喜欢这个字体 $AwA$ ）</p>
<p>分类讨论绝对是树学界存在的最恶心的玩意。不会真的有人在代码里分类讨论吧，不会吧不会吧。</p>
<p>我想把这两种情况 <strong>归为一类</strong> 。</p>
<p>大眼观察法看出 $Type\ 2$ 在以粉色点为根的时候就可以归纳为一种 $Type\ 1$ 。</p>
<p>$Type\ 1$ 多好求，两点到 $LCA$ 距离一加就是了。</p>
<p>显然，我们要从根结点一层一层地递归下去求解。</p>
<p>获得了 $O(level\cdot n)$ （ $level$ 是树的深度）的优秀复杂度！</p>
<p>然后当场就被链卡回了 $O(n^2)$ 。</p>
<p>我们发现，它被卡了，究其原因就是因为树的形态太 $hentai$ 。</p>
<p>一棵树，存不存在距离为 $K$ 的点对，和让谁来当根有关系吗？</p>
<p>没有关系。</p>
<p>那我们就该选一个好亿点的点来当根哇。</p>
<p>这个“好亿点”，具体指的就是，以它来当根，能使 <strong>树的深度最小</strong> 。</p>
<h5 id="这里有一个概念叫树的重心："><a href="#这里有一个概念叫树的重心：" class="headerlink" title="这里有一个概念叫树的重心："></a>这里有一个概念叫树的重心：</h5><p>我们知道在一棵树上，删去一个点后，剩下的部分必然不联通。</p>
<p>如果一个点删去它后，剩余的几部分中 <strong>大的那一块最小</strong> ，则我们说这个点是这个树的重心。</p>
<p>不难感觉到，如果以一棵树的重心为根，它的佐佑两边会最为“平衡”。</p>
<p>在最美好的愿景下，每层以重心作根可以做到把树二等分。</p>
<p>那二等分又二等分，最终能控制在 $\log n$ 的递归层数。</p>
<p>获得了 $O(n \log n)$ 的优秀复杂度！（大喜）</p>
<p>撒花撒花～</p>
<h4 id="劲爆习题："><a href="#劲爆习题：" class="headerlink" title="劲爆习题："></a>劲爆习题：</h4><p><strong>模板题：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3806">P3806 【模板】点分治1 </a> ：（想不到叭，模板就是紫的 $QwQ$ ）</p>
<p>给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。</p>
<p>裸题，8说了，该说的都在注释里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*前向星存图组件*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125; e[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> N, M, SUM;</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].to = y;</span><br><span class="line">	e[eid].next = head[x];</span><br><span class="line">	e[eid].val = w;</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*求重心组件*/</span></span><br><span class="line"><span class="keyword">int</span> cent;<span class="comment">//指重心的编号</span></span><br><span class="line"><span class="keyword">int</span> size[MAX], son[MAX];<span class="comment">//size:其子树（包括自己）的大小 son:最大儿子的大小</span></span><br><span class="line"><span class="keyword">int</span> vis[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	size[u] = <span class="number">1</span>;</span><br><span class="line">	son[u] = <span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == lst || vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">getroot</span>(v, u);</span><br><span class="line">		size[u] += size[v];</span><br><span class="line">		son[u] = <span class="built_in">max</span>(son[u], size[v]);<span class="comment">//更新最终儿子</span></span><br><span class="line">	&#125;</span><br><span class="line">	son[u] = <span class="built_in">max</span>(son[u], SUM - son[u]);<span class="comment">//可能子树外的部分更大</span></span><br><span class="line">    <span class="comment">//SUM实时更新成当前要求重心的树的大小</span></span><br><span class="line">	<span class="keyword">if</span> (son[u] &lt; son[cent])</span><br><span class="line">	&#123;</span><br><span class="line">		cent = u;<span class="comment">//更新</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*点分治组件*/</span></span><br><span class="line"><span class="keyword">int</span> dis[MAX], apr[MAX], cntapr;</span><br><span class="line"><span class="comment">//dis:到“当前处理到的子树”的根结点的距离</span></span><br><span class="line"><span class="comment">//apr:一个子树级别的桶，存所有出现过的距离</span></span><br><span class="line"><span class="comment">//cntapr:桶大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	apr[++cntapr] = dis[u];<span class="comment">//装桶</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to, w = e[i].val;</span><br><span class="line">		<span class="keyword">if</span> (v == lst || vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dis[v] = dis[u] + w;<span class="comment">//更新距离</span></span><br><span class="line">		<span class="built_in">getdis</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> query[MAX], ans[<span class="number">10000007</span>], judge[<span class="number">10000007</span>];</span><br><span class="line"><span class="comment">//query:询问，这里采用离线回答做法</span></span><br><span class="line"><span class="comment">//ans:对于每一个询问的答案（0/1 表示有或没有）</span></span><br><span class="line"><span class="comment">//judge:一个整树级别的大桶</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; clear;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)<span class="comment">//这里是遍历每一棵子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> w = e[i].val;</span><br><span class="line">        dis[v] = w;</span><br><span class="line">        cntapr = <span class="number">0</span>;<span class="comment">//清桶</span></span><br><span class="line">        <span class="built_in">getdis</span>(v, u);<span class="comment">//这里是往下搜（遍历到的这棵子树）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cntapr; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= M; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (query[k] - apr[j] &gt;= <span class="number">0</span> &amp;&amp; judge[query[k] - apr[j]])<span class="comment">//若和他拼起来能达到K的距离出现过</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans[k] = <span class="number">1</span>;<span class="comment">//则这是可拼出K的答案</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntapr; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            clear.<span class="built_in">push</span>(apr[i]);</span><br><span class="line">            judge[apr[i]] = <span class="number">1</span>;<span class="comment">//装大桶</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">while</span> (!clear.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		judge[clear.<span class="built_in">front</span>()] = <span class="number">0</span>;</span><br><span class="line">		clear.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	judge[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">calc</span>(u);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		SUM = size[v];</span><br><span class="line">		son[<span class="number">0</span>] = INF;</span><br><span class="line">		cent = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">getroot</span>(v, <span class="number">0</span>);<span class="comment">//获取新重心</span></span><br><span class="line">		<span class="built_in">solve</span>(cent);<span class="comment">//以重心为根递归</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1.</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> fr, to, val;</span><br><span class="line">		cin &gt;&gt; fr &gt;&gt; to &gt;&gt; val;</span><br><span class="line">		<span class="built_in">adde</span>(fr, to, val);</span><br><span class="line">		<span class="built_in">adde</span>(to, fr, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; query[i];</span><br><span class="line">	&#125;</span><br><span class="line">	son[<span class="number">0</span>] = SUM = N;</span><br><span class="line">	<span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>(cent);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ans[i])</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;AYE\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;NAY\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>次模板题：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4178">P4178 Tree</a></p>
<p>由上题的询问存在与否变成了询问 <strong>点对数</strong> ，要求变成了 <strong>小于等于</strong> 。</p>
<p>点分治的板子该打还是打，但要改一下 $\operatorname{calc}$ 函数。</p>
<p><strong>上一题的策略是</strong>：存桶，查能和它拼成 $K$ 的距离是否存在。</p>
<p>但我们这么整是因为题目要求的是等于 $K$ ，所以能拼的距离是唯一确定哒。</p>
<p>可这题是不确定的，所以得换一种思路。</p>
<p>我们尝试把所有出现过的距离排个序，有两个指针 $L$ 和 $R$ 从数组两边往中间逐步压缩。</p>
<p>$L$ 指向的距离和 $R$ 指向的距离，会拼出一种可能的距离。</p>
<p>可以证明这样能不重不漏地拼出树上存在的每一种 <strong>两点距离</strong> 。</p>
<p>甚至可以在线/fad/fad 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug cout</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125; e[MAX];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].to = y;</span><br><span class="line">	e[eid].next = head[x];</span><br><span class="line">	e[eid].val = w;</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> size[MAX], son[MAX], cent, vis[MAX];</span><br><span class="line"><span class="keyword">int</span> N, M, SUM, K;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	size[u] = <span class="number">1</span>;</span><br><span class="line">	son[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == lst || vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">getroot</span>(v, u);</span><br><span class="line">		size[u] += size[v];</span><br><span class="line">		son[u] = <span class="built_in">max</span>(son[u], size[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	son[u] = <span class="built_in">max</span>(son[u], SUM - son[u]);</span><br><span class="line">	<span class="keyword">if</span> (son[u] &lt; son[cent])</span><br><span class="line">	&#123;</span><br><span class="line">		cent = u;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[MAX], apr[MAX], cntapr = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	apr[++cntapr] = dis[u];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == lst || vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dis[v] = dis[u] + e[i].val;</span><br><span class="line">		<span class="built_in">getdis</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans, query[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dis[u] = w;</span><br><span class="line">	cntapr = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">getdis</span>(u, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">sort</span>(apr + <span class="number">1</span>, apr + <span class="number">1</span> + cntapr);</span><br><span class="line">	<span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = cntapr; l &lt; r;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (apr[l] + apr[r] &lt;= K)</span><br><span class="line">        <span class="comment">//若这两种距离拼出的长度小于等于K</span></span><br><span class="line">		&#123;</span><br><span class="line">			answer += r - l;</span><br><span class="line">            <span class="comment">//那么r取他们之间的其他数也会小于等于K</span></span><br><span class="line">            <span class="comment">//因为排过序了，r往左移只会更小</span></span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			r--;<span class="comment">//否则就取更小的r</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ans += <span class="built_in">calc</span>(u, <span class="number">0</span>);</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to, w = e[i].val;</span><br><span class="line">		<span class="keyword">if</span> (vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans -= <span class="built_in">calc</span>(v, w);</span><br><span class="line">		SUM = size[v];</span><br><span class="line">		cent = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">getroot</span>(v, u);</span><br><span class="line">		<span class="built_in">solve</span>(cent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> fr, to, val;</span><br><span class="line">		cin &gt;&gt; fr &gt;&gt; to &gt;&gt; val;</span><br><span class="line">		<span class="built_in">adde</span>(fr, to, val);</span><br><span class="line">		<span class="built_in">adde</span>(to, fr, val);</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; K;</span><br><span class="line">	cent = <span class="number">0</span>;</span><br><span class="line">	SUM = son[<span class="number">0</span>] = N;</span><br><span class="line">	<span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>(cent);</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>次次模板题：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2634">[国家集训队]聪聪可可</a> </p>
<p>这回求的是距离是 $3$ 的倍数的点对数。照样改 $\operatorname{calc}$ 。</p>
<p>带了亿亿亿亿亿点思维，但是易见平凡（雾。</p>
<p>装桶的思路还是不变，但是开这么多桶贞德合理吗？</p>
<p>两个数 $A,B$ 的 <strong>和</strong>  $\bmod 3$ 余 $0$ 。则跑不出三种情况：</p>
<ul>
<li><p>$A \bmod 3=0 , B \bmod 3=0 $</p>
</li>
<li><p>$A \bmod 3=1 , B \bmod 3=2$ </p>
</li>
<li><p>$A \bmod 3=2 , B \bmod 3=1$ </p>
</li>
</ul>
<p>开三个桶来计数，$tong_0,tong_1,tong_2$分别存 $\pmod 3=0,\pmod 3=1,\pmod 3=2$ 。</p>
<p>那么来个小加法原理就有了： </p>
<script type="math/tex; mode=display">ans=tong_1\cdot tong_2\ +\ tong_2\cdot tong_1\ +\ tong_0\cdot tong_0</script><p>小心输出格式，甚至要约分。（淦</p>
<p><del>您吊打国集</del></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">2e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125; e[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].to = y;</span><br><span class="line">	e[eid].next = head[x];</span><br><span class="line">	e[eid].val = w;</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> size[MAX], son[MAX], SUM;</span><br><span class="line"><span class="keyword">int</span> vis[MAX];</span><br><span class="line"><span class="keyword">int</span> cent;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	size[u] = <span class="number">1</span>;</span><br><span class="line">	son[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == lst || vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">getroot</span>(v, u);</span><br><span class="line">		size[u] += size[v];</span><br><span class="line">		son[u] = <span class="built_in">max</span>(son[u], size[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	son[u] = <span class="built_in">max</span>(son[u], SUM - son[u]);</span><br><span class="line">	<span class="keyword">if</span> (son[u] &lt; son[cent])</span><br><span class="line">	&#123;</span><br><span class="line">		cent = u;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> tong[<span class="number">3</span>], dis[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tong[dis[u] % <span class="number">3</span>]++;<span class="comment">//相应的桶++</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == lst || vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dis[v] = dis[u] + e[i].val;</span><br><span class="line">		<span class="built_in">getdis</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dis[u] = w;</span><br><span class="line">	tong[<span class="number">0</span>] = tong[<span class="number">1</span>] = tong[<span class="number">2</span>] = <span class="number">0</span>;<span class="comment">//先清空</span></span><br><span class="line">	<span class="built_in">getdis</span>(u, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> tong[<span class="number">1</span>] * tong[<span class="number">2</span>] * <span class="number">2</span> + tong[<span class="number">0</span>] * tong[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//如上公式算得答案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ans += <span class="built_in">calc</span>(u, <span class="number">0</span>);</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to, w = e[i].val;</span><br><span class="line">		<span class="keyword">if</span> (vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans -= <span class="built_in">calc</span>(v, w);</span><br><span class="line">		SUM = size[v];</span><br><span class="line">		cent = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">getroot</span>(v, u);</span><br><span class="line">		<span class="built_in">solve</span>(cent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> G = __gcd(ans, N * N);</span><br><span class="line">	cout &lt;&lt; ans / G &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; N * N / G &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> fr, to, val;</span><br><span class="line">		cin &gt;&gt; fr &gt;&gt; to &gt;&gt; val;</span><br><span class="line">		<span class="built_in">adde</span>(fr, to, val);</span><br><span class="line">		<span class="built_in">adde</span>(to, fr, val);</span><br><span class="line">	&#125;</span><br><span class="line">	SUM = N;</span><br><span class="line">	son[<span class="number">0</span>] = SUM;</span><br><span class="line">	<span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>(cent);</span><br><span class="line">	<span class="built_in">output</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>次次次模板题</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4149">[IOI2011]Race</a> </p>
<p><del>刚爆踩完集训队，马上就IOI了（笑</del>）</p>
<p>这题和纯模板题又有差别，在距离符合的情况下要求路径上边数最少。还是改 $\operatorname{calc}$ 。</p>
<p>像这种多条件下求人上人的题目，多半是平衡树或堆。</p>
<p>因为要求的并非 <strong>全部路径</strong> 最优的一个，而是有条件限制（距离定为 $K$ ）。</p>
<p>所以只能打平衡树了……</p>
<p>吗？</p>
<p>人生苦短，我用 $set+lower_bound$ 。遍历所有出现过的距离，查找的是能和它拼成 $K$ 的长度中边数最少的。</p>
<p>因为题目大毒瘤，所以加了亿点卡常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIT set<span class="meta-string">&lt;PII&gt;</span>::iterator</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>, bj = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			bj = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">	&#123;</span><br><span class="line">		num = num * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		ch = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bj ? -num : num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125; e[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].to = y;</span><br><span class="line">	e[eid].next = head[x];</span><br><span class="line">	e[eid].val = w;</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, K, SUM;</span><br><span class="line"><span class="keyword">int</span> size[MAX], son[MAX];</span><br><span class="line"><span class="keyword">int</span> vis[MAX];</span><br><span class="line"><span class="keyword">int</span> cent;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	size[u] = <span class="number">1</span>;</span><br><span class="line">	son[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == lst || vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">getroot</span>(v, u);</span><br><span class="line">		size[u] += size[v];</span><br><span class="line">		son[u] = <span class="built_in">Max</span>(son[u], size[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	son[u] = <span class="built_in">Max</span>(son[u], SUM - son[u]);</span><br><span class="line">	<span class="keyword">if</span> (son[u] &lt; son[cent])</span><br><span class="line">	&#123;</span><br><span class="line">		cent = u;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">set&lt;PII&gt; s;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">PII apr[MAX];</span><br><span class="line"><span class="keyword">int</span> cntapr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dis[MAX];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst, <span class="keyword">int</span> path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (path &gt; ans || dis[u] &gt; K)</span><br><span class="line">    <span class="comment">//到题解区学的剪枝，其实不难理解</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	apr[++cntapr] = <span class="built_in">MP</span>(dis[u], path);</span><br><span class="line">    <span class="comment">//装桶，第一维是长度，第二维是路径上的边数。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == lst || vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dis[v] = dis[u] + e[i].val;</span><br><span class="line">		<span class="built_in">getdis</span>(v, u, path + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s.<span class="built_in">clear</span>();</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="built_in">MP</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> v = e[i].to, w = e[i].val;</span><br><span class="line">		<span class="keyword">if</span> (vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cntapr = <span class="number">0</span>;<span class="comment">//清空</span></span><br><span class="line">		dis[v] = w;</span><br><span class="line">		<span class="built_in">getdis</span>(v, u, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//现在 apr 数组里装得是v这棵子树上，各种新产生的路径</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cntapr; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> d = apr[j].first, p = apr[j].second;</span><br><span class="line">            <span class="comment">//取出距离和边数</span></span><br><span class="line">			SIT pos = s.<span class="built_in">lower_bound</span>(<span class="built_in">MP</span>(K - d, <span class="number">0</span>));</span><br><span class="line">            <span class="comment">//查能拼的长度</span></span><br><span class="line">			<span class="keyword">if</span> (pos != s.<span class="built_in">end</span>() &amp;&amp; pos-&gt;first + d == K)</span><br><span class="line">			&#123;</span><br><span class="line">				ans = <span class="built_in">Min</span>(ans, pos-&gt;second + p);<span class="comment">//反复取min</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//装进set</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cntapr; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			s.<span class="built_in">insert</span>(apr[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cent = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">getroot</span>(u, u);</span><br><span class="line">	vis[cent] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">calc</span>(cent);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = head[cent]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		SUM = size[v];</span><br><span class="line">		<span class="built_in">solve</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> fr, to, val;</span><br><span class="line">		fr = <span class="built_in">read</span>(), to = <span class="built_in">read</span>(), val = <span class="built_in">read</span>();</span><br><span class="line">		fr++;</span><br><span class="line">		to++;<span class="comment">//因为这题的申必编号从0开始，所以全体编号加1处理</span></span><br><span class="line">		<span class="built_in">adde</span>(fr, to, val);</span><br><span class="line">		<span class="built_in">adde</span>(to, fr, val);</span><br><span class="line">	&#125;</span><br><span class="line">	cent = <span class="number">0</span>;</span><br><span class="line">	SUM = son[<span class="number">0</span>] = N;</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (ans == <span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="点分树（动态点分治）"><a href="#点分树（动态点分治）" class="headerlink" title="点分树（动态点分治）"></a>点分树（动态点分治）</h3><p><del>“我真傻，真的，我以为三倍经验黑题躺在任务列表里就迟早会被切掉，谁知道等我切掉的时候已经掉紫了。”</del></p>
<h4 id="处理什么问题：-1"><a href="#处理什么问题：-1" class="headerlink" title="处理什么问题："></a>处理什么问题：</h4><p>带修树上点对距离查询。这里的“修”不会改变树的形态。</p>
<p>您会说：“我 $O(1)$ 修改，每次查询都 $O(n \log n)$ 跑一遍点分治不香吗？” 这是一种 $O(q\cdot n\log n)$ 的优秀算(bao)法(li)。</p>
<p>抱歉，点分树可以达到 $O(q\log n)$ 的效率。如果算上它上边套的别的数据结构（比如平衡树哇，堆哇），也一般能有 $O(q\log^2 n)$ 的高性能。</p>
<h4 id="思想是什么：-1"><a href="#思想是什么：-1" class="headerlink" title="思想是什么："></a>思想是什么：</h4><p>想想您的暴力为什么会有这么大的复杂度。</p>
<p>找重心，回答询问，修改，又找重心，又回答询问，又修改……</p>
<p>看得出，您的做法有不少重复的操作。</p>
<p>尝试优(tou)化(gong)算(jian)法(liao)。</p>
<p>询问和修改我们都不敢偷懒，只能从找重心开刀。</p>
<p>我们发现，因为树的形态始终不变，找到的重心永远都是那几个。</p>
<p>又想到，我们每一次统计答案（ $\operatorname{calc}$ ），总是在递归重心时的 $\operatorname{solve}$ 函数里。这是否表明一个重心点，它还能表示一些其他的有关答案的信息呢？</p>
<p>必然是可以的，我们甚至还能用取重心的搜索序建出一棵树来。这棵树就称作点分树。</p>
<p>接下来，我们声称：两个点在原树上的距离为他们的 <strong>真实距离</strong> 。（区别于点分树上的距离）</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/oigtkvmd.png" alt=""></p>
<p>我这是一棵树（确信），树上有 $6$ 个顶点。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/t0fekm4g.png" alt=""></p>
<p>我取重心 $4$ 作为根，我开一个 $tong_4$ 装以 $4$ 为根的子树中出现的 <strong>点到根的真实距离</strong> 情况。 （右边是当前 <strong>点分树</strong> 的形态）</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/sbd676vz.png" alt=""></p>
<p>我取重心 $2$ 为根，距离情况再装桶。</p>
<p>如此往复。最终得到了图上的所有信息。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jvjbfh6p.png" alt=""></p>
<p>这些信息是可以在 $O(n\log n)$ 时间内得到的。下面考虑修改：</p>
<p>如果我们要修改原树上 $1\ 2$ 之间的边权，从 $val=1$ 改为 $val=2$ 。哪些桶里装的值会受影响？</p>
<p>大眼观察法， $tong_2$ 和 $tong_4$ 会受影响。</p>
<p>可见会受到修改的影响的，是这条边 <strong>在点分树上</strong> 的祖先们。</p>
<p>我们往下递归找重心时，记录一下每个重心是 <strong>从谁递归过来</strong> 的，记之为 $fa$ 。（一般点分树的题不用建出真正的点分树形态，比如像这里只要记录其 <strong>点分树上</strong> 的父亲 $fa$ 即可）。</p>
<p>向上跳 $fa$ ，每跳到一个点，修改相应的数据结构。 （像这里就是修改桶里的值～）</p>
<p>我们珂以保证：这样跳 $fa$ 可以只跳 $\log n$ 次。</p>
<p>原因？</p>
<p>点分治拥有的 $\log n$ 的优秀递归层数，使得点分树的层数也能控制在 $\log n$ 。</p>
<p>而查询更是轻松，只需直接调用数据结构里的信息就可了。</p>
<p>妙到家。</p>
<h4 id="劲爆习题：-1"><a href="#劲爆习题：-1" class="headerlink" title="劲爆习题："></a>劲爆习题：</h4><p>模板题： <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/SP2939">QTREE5 - Query on a tree V</a> </p>
<p>其实不是很板。/kk</p>
<p><strong>修改</strong>：翻转颜色，<strong>查询</strong>：给定 $u$ ，求树上距 $u$ 最近白点。</p>
<p>一上来就整点“好康的”。可以充分感受点分树的恶意。(bushi</p>
<p>查询的是最值，那就不是开桶那么简单了。</p>
<p>我们要开堆。</p>
<p>每个点必然要开一个堆，装的是它的 <strong>点分树子树</strong> 里的点，到它的 <strong>真实距离</strong> 。（因为是最 <strong>小</strong> 值，所以开小根堆）</p>
<p>因为有时会有白点变成黑的，无法计入答案，所以要写一个 <strong>可删堆</strong> $AwA$ 。</p>
<p>这其实算得上一种小 $trick$ ，下面有放代码的。</p>
<p>那么修改操作即为：</p>
<ul>
<li><p>一个点 $P$ 变白了 $\rightarrow$ 跳到其 <strong>点分树上</strong> 的父亲 $FA$  $\rightarrow$ 往 $FA$ 的堆里塞一个表示 $P$ 到 $FA\ $  <strong>真实距离</strong> 的元素 $\rightarrow$ 跳到更高一级的 $FA$ $\rightarrow$ 塞元素 $\rightarrow\; \cdots$ </p>
</li>
<li><p>一个点 $P$ 变黑了 $\rightarrow$ 跳到其 <strong>点分树上</strong> 的父亲 $FA$  $\rightarrow$ 在 $FA$ 的堆里删去表示 $P$ 到 $FA\ $  <strong>真实距离</strong> 的元素 $\rightarrow$ 跳到更高一级的 $FA$ $\rightarrow$ 删元素 $\rightarrow\; \cdots$</p>
</li>
</ul>
<p>都维护了这么多东西了，那么查询操作就有 手 就 行。我们要查询一个点 $P$ 的最近白点。</p>
<p>扫一遍它在 <strong>点分树</strong> 上的所有祖先。为什么是点分树？因为一个点的距离信息都保存在了它点分树上祖先的堆里，所以是在点分树上跳祖先。</p>
<p>取出祖先 $FA$ 位置上堆的堆顶，这个堆顶就是所有过 $FA$ 的 <strong>真实路径</strong> 中最短的一条。</p>
<p>这个堆顶和 $P$ 到 $FA$ 的 <strong>真实距离</strong> 可以拼起来，形成一个如树上路径 $Case\ 1$ 的两点点距。</p>
<p>不断上跳 $FA$ ，对点距多次取 $min$ 。最终就能得到答案辣！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUN(u) for (int i = head[(u)]; i; i = e[i].next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GI greater<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*存图组件*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">	<span class="keyword">int</span> to;</span><br><span class="line">&#125; e[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].to = y;</span><br><span class="line">	e[eid].next = head[x];</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*点分治组件*/</span></span><br><span class="line"><span class="keyword">int</span> size[MAX], son[MAX], vis[MAX];</span><br><span class="line"><span class="keyword">int</span> cent, N, Q, SUM;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	size[u] = <span class="number">1</span>;</span><br><span class="line">	son[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">RUN</span>(u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == lst || vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">get_root</span>(v, u);</span><br><span class="line">		size[u] += size[v];</span><br><span class="line">		son[u] = <span class="built_in">max</span>(son[u], size[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	son[u] = <span class="built_in">max</span>(son[u], SUM - son[u]);</span><br><span class="line">	<span class="keyword">if</span> (son[u] &lt; son[cent])</span><br><span class="line">	&#123;</span><br><span class="line">		cent = u;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">27</span>][MAX], dep[MAX];</span><br><span class="line"><span class="comment">//dis：表示某点到其fa的真实距离</span></span><br><span class="line"><span class="comment">//第二维是指该点的编号 第一维是指“这是它的第几级祖先” </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dep：表示该点在点分树上的深度，这决定了它上面有几级祖先。</span></span><br><span class="line"><span class="keyword">int</span> fa[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst, <span class="keyword">int</span> stp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dis[stp][u] = dis[stp][lst] + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">RUN</span>(u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (vis[v] || v == lst)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">getdis</span>(v, u, stp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*点分树组件*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> stp)</span><span class="comment">//stp：遍历到的点分树深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*点分治板子*/</span></span><br><span class="line">	dep[u] = stp;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">RUN</span>(u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dis[stp][u] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">getdis</span>(v, u, stp);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="built_in">RUN</span>(u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cent = <span class="number">0</span>;</span><br><span class="line">		son[<span class="number">0</span>] = INF;</span><br><span class="line">		SUM = size[v];</span><br><span class="line">		<span class="built_in">get_root</span>(v, u);</span><br><span class="line">		<span class="built_in">get_root</span>(cent, u);</span><br><span class="line">		fa[cent] = u;<span class="comment">//一个点在点分树上的父亲即是它“从谁递归过来”</span></span><br><span class="line">		<span class="built_in">solve</span>(cent, stp + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, GI&gt; rema[MAX], dele[MAX];</span><br><span class="line"><span class="comment">//可删堆，现在还看不出什么高妙，详情见 query</span></span><br><span class="line"><span class="comment">//我们称rema为剩余堆，dele为删除堆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> color[MAX];<span class="comment">//颜色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = dep[x]; i; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (color[x] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			rema[u].<span class="built_in">push</span>(dis[i][x]);</span><br><span class="line">            <span class="comment">//若原为黑，则现在变为白，加点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			dele[u].<span class="built_in">push</span>(dis[i][x]);</span><br><span class="line">             <span class="comment">//若原为白，则现在变为黑，删点</span></span><br><span class="line">		&#125;</span><br><span class="line">		u = fa[u];<span class="comment">//跳fa</span></span><br><span class="line">	&#125;</span><br><span class="line">	color[x] = <span class="number">1</span> - color[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = x, ans = INF;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = dep[x]; i; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (!rema[u].<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!dele[u].<span class="built_in">empty</span>() &amp;&amp; dele[u].<span class="built_in">top</span>() == rema[u].<span class="built_in">top</span>())</span><br><span class="line">            <span class="comment">//若一个元素同时出现在剩余堆和删除堆，则这是一个被删除过的元素。</span></span><br><span class="line">			&#123;</span><br><span class="line">				dele[u].<span class="built_in">pop</span>();</span><br><span class="line">				rema[u].<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//阴阳人滚出优先队列</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				ans = <span class="built_in">min</span>(ans, dis[i][x] + rema[u].<span class="built_in">top</span>());</span><br><span class="line">                <span class="comment">//反复取min</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		u = fa[u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans == INF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> fr, to;</span><br><span class="line">		cin &gt;&gt; fr &gt;&gt; to;</span><br><span class="line">		<span class="built_in">adde</span>(fr, to);</span><br><span class="line">		<span class="built_in">adde</span>(to, fr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	cin &gt;&gt; Q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> opt;</span><br><span class="line">		cin &gt;&gt; opt;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> num;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			<span class="built_in">update</span>(num);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> num;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query</span>(num) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>冲高端题</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2056">[ZJOI2007]捉迷藏</a> </p>
<p>是ZJOI远古题！</p>
<p><del>显然那时候浙江省选的毒瘤综合征就已经在潜伏期了</del>。</p>
<p>相比上题，没有了确定的 $u$ ，而是要在全树上查最大值。</p>
<p>上题要考虑的范围那么小，还仅仅卡着复杂度过题，这次有那么多条边要枚举。带毒瘤，爬了爬了。</p>
<p>想想有没有什么“高妙”做法。</p>
<p>全树最大值，所以我们需要开一个全局的大根堆，维护 <strong>点分树</strong> 上的最大 <strong>点对真实距离</strong> 。记此堆为 $\mathtt{ALL}$ 。</p>
<p>上道题 “每个点开一个堆，装它的 <strong>点分树子树</strong> 里的点，到它的 <strong>真实距离</strong> ” 的思路依然保留。记这些堆为 $\mathtt{subtofa[1…n]}$ </p>
<p>但仅有一个 $\mathtt{subtofa}$ 堆无法直接维护 $\mathtt{ALL}$ 。我们可以再整一个堆用于过渡。</p>
<p>先更改 $\mathtt{subtofa[1…n]}$ 的定义为：“每个点（称它为 $u$ ）开一个堆，装 $u$ 的 <strong>点分树子树</strong> 里的点，到 $u$ 的<strong>父亲的真实距离</strong> ”（差别在于真实距离是到它父亲的）。</p>
<p>再开一个堆表示 “对于一个点 $u$ 在 <strong>点分树</strong> 中的每个儿子 $v$ ，都把 $\mathtt{subtofa[v]}$ 中最大的一个装进这个堆里”。记这种堆为 $\mathtt{fainsub[1…n]}$ 。</p>
<p>代码中的这句话可以彰显出其关系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fainsub[u].<span class="built_in">push</span>(subtofa[cent].<span class="built_in">top</span>());</span><br><span class="line">        <span class="comment">//存进subtofa的最大值</span></span><br></pre></td></tr></table></figure>
<p>而关于 $\mathtt{fainsub}$ 和 $\mathtt{ALL}$ ，可以看出 $\mathtt{ALL}$ 里装的东西始终为： 每个 $\mathtt{fainsub}$ 中，堆顶的 <strong>两个长度的和</strong> （参考以 $Case\ 1$ 的形式拼接两个长度，以形成一条路径） 。</p>
<p>更新 $\mathtt{ALL}$ 堆的代码实现～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins_ALL</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fainsub[u].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ALL.<span class="built_in">push</span>(fainsub[u].<span class="built_in">top</span>() + fainsub[u].<span class="built_in">second</span>());</span><br><span class="line">        <span class="comment">//ALL是自定义的“可删堆”类型，second取出的是其第二大的元素</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您对定义感到疑惑，这里给出一种感性理解（<del>毕竟我也给这道题题解的各种定义看自闭过</del>）：$\texttt{subtofa}$ 维护的是纵向的距离最大值， $\mathtt{fainsub}$ 维护的是横向的距离最大值。</p>
<p>给出一张图助于理解：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8is0o5v5.png" alt=""></p>
<p>如果点 $u$ 关灯，则将像上题一样，不断跳 $fa$ ，将 $\mathtt{subtofa[u].top()}$ 加入这个 $fa$ 的 $\mathtt{fainsub[fa]}$ ，再将新的 $\mathtt{fainsub[fa]}$ 装进 $\mathtt{ALL}$ 。</p>
<p>若开灯，则将以上操作改为删除元素。</p>
<p>自认为说的很详尽了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUN(u) for (int i = head[(u)]; i; i = e[i].next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GI greater<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*存边组件*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">	<span class="keyword">int</span> to;</span><br><span class="line">&#125; e[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> N, Q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].to = y;</span><br><span class="line">	e[eid].next = head[x];</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*封装可删堆*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">removable_priority_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>&gt; rema, dele;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dele.<span class="built_in">push</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rema.<span class="built_in">push</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!rema.<span class="built_in">empty</span>() &amp;&amp; !dele.<span class="built_in">empty</span>() &amp;&amp; dele.<span class="built_in">top</span>() == rema.<span class="built_in">top</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			dele.<span class="built_in">pop</span>();</span><br><span class="line">			rema.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> rema.<span class="built_in">top</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">second</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> maxx = <span class="built_in">top</span>();</span><br><span class="line">		rema.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="built_in">top</span>();</span><br><span class="line">		rema.<span class="built_in">push</span>(maxx);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rema.<span class="built_in">size</span>() - dele.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; subtofa[MAX], fainsub[MAX], ALL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用 fainsub 更新全局 ALL*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_ALL</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fainsub[u].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ALL.<span class="built_in">remove</span>(fainsub[u].<span class="built_in">top</span>() + fainsub[u].<span class="built_in">second</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins_ALL</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fainsub[u].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ALL.<span class="built_in">push</span>(fainsub[u].<span class="built_in">top</span>() + fainsub[u].<span class="built_in">second</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*点分治组件*/</span></span><br><span class="line"><span class="keyword">int</span> size[MAX], son[MAX];</span><br><span class="line"><span class="keyword">int</span> cent, SUM;</span><br><span class="line"><span class="keyword">int</span> vis[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	size[u] = <span class="number">1</span>;</span><br><span class="line">	son[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">RUN</span>(u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (v == lst || vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">getroot</span>(v, u);</span><br><span class="line">		size[u] += size[v];</span><br><span class="line">		son[u] = <span class="built_in">max</span>(son[u], size[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	son[u] = <span class="built_in">max</span>(son[u], SUM - son[u]);</span><br><span class="line">	<span class="keyword">if</span> (son[u] &lt; son[cent])</span><br><span class="line">	&#123;</span><br><span class="line">		cent = u;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">27</span>][MAX];</span><br><span class="line"><span class="keyword">int</span> color[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst, <span class="keyword">int</span> stp, <span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	subtofa[root].<span class="built_in">push</span>(stp);</span><br><span class="line">	<span class="built_in">RUN</span>(u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (vis[v] || v == lst)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">getdis</span>(v, u, stp + <span class="number">1</span>, root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">RUN</span>(u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cent = <span class="number">0</span>;</span><br><span class="line">		son[<span class="number">0</span>] = INF;</span><br><span class="line">		SUM = size[v];</span><br><span class="line">		<span class="built_in">getroot</span>(v, u);</span><br><span class="line">		fa[cent] = u;<span class="comment">//记录fa</span></span><br><span class="line">		<span class="built_in">getdis</span>(v, u, <span class="number">1</span>, cent);</span><br><span class="line">		fainsub[u].<span class="built_in">push</span>(subtofa[cent].<span class="built_in">top</span>());</span><br><span class="line">        <span class="comment">//存进subtofa的最大值</span></span><br><span class="line">		<span class="built_in">solve</span>(cent);</span><br><span class="line">	&#125;</span><br><span class="line">	fainsub[u].<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//可以自己到自己</span></span><br><span class="line">	<span class="built_in">ins_ALL</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*LCA组件（蒟蒻太蔡了打了个倍增）*/</span></span><br><span class="line"><span class="keyword">int</span> dep[MAX], lg[MAX];</span><br><span class="line"><span class="keyword">int</span> father[MAX][<span class="number">27</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCA_prework</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dep[u] = dep[lst] + <span class="number">1</span>;</span><br><span class="line">	father[u][<span class="number">0</span>] = lst;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		father[u][i] = father[father[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (e[i].to == lst)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">LCA_prework</span>(e[i].to, u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dep[x] &lt; dep[y])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (dep[x] &gt; dep[y])</span><br><span class="line">	&#123;</span><br><span class="line">		x = father[x][lg[dep[x] - dep[y]] - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x == y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = lg[dep[x]] - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (father[x][i] != father[y][i])</span><br><span class="line">		&#123;</span><br><span class="line">			x = father[x][i];</span><br><span class="line">			y = father[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis_on_real</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dep[x] + dep[y] - dep[<span class="built_in">LCA</span>(x, y)] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*开灯*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn_on</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">del_ALL</span>(u);</span><br><span class="line">	fainsub[u].<span class="built_in">remove</span>(<span class="number">0</span>);<span class="comment">//首先不能自己到自己了</span></span><br><span class="line">	<span class="built_in">ins_ALL</span>(u);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> now = u; fa[now]; now = fa[now])<span class="comment">//跳fa</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> D = <span class="built_in">dis_on_real</span>(u, fa[now]);</span><br><span class="line">		<span class="built_in">del_ALL</span>(fa[now]);<span class="comment">//先取出第一层</span></span><br><span class="line">		<span class="keyword">if</span> (subtofa[now].<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			fainsub[fa[now]].<span class="built_in">remove</span>(subtofa[now].<span class="built_in">top</span>());</span><br><span class="line">            <span class="comment">//取出第二层</span></span><br><span class="line">		&#125;</span><br><span class="line">		subtofa[now].<span class="built_in">remove</span>(D);<span class="comment">//铲除祸根</span></span><br><span class="line">		<span class="keyword">if</span> (subtofa[now].<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			fainsub[fa[now]].<span class="built_in">push</span>(subtofa[now].<span class="built_in">top</span>());<span class="comment">//放回</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ins_ALL</span>(fa[now]);<span class="comment">//放回</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*关灯*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn_off</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//见上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">del_ALL</span>(u);</span><br><span class="line">	fainsub[u].<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">ins_ALL</span>(u);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> now = u; fa[now]; now = fa[now])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> D = <span class="built_in">dis_on_real</span>(u, fa[now]);</span><br><span class="line">		<span class="built_in">del_ALL</span>(fa[now]);</span><br><span class="line">		<span class="keyword">if</span> (subtofa[now].<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			fainsub[fa[now]].<span class="built_in">remove</span>(subtofa[now].<span class="built_in">top</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		subtofa[now].<span class="built_in">push</span>(D);</span><br><span class="line">		<span class="keyword">if</span> (subtofa[now].<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			fainsub[fa[now]].<span class="built_in">push</span>(subtofa[now].<span class="built_in">top</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ins_ALL</span>(fa[now]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*多此一举的修改函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (color[u] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">turn_on</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">turn_off</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> black;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		lg[i] = lg[i - <span class="number">1</span>] + (i == (<span class="number">1</span> &lt;&lt; lg[i - <span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> fr, to;</span><br><span class="line">		cin &gt;&gt; fr &gt;&gt; to;</span><br><span class="line">		<span class="built_in">adde</span>(fr, to);</span><br><span class="line">		<span class="built_in">adde</span>(to, fr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">LCA_prework</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	SUM = N;</span><br><span class="line">	cent = <span class="number">0</span>;</span><br><span class="line">	son[<span class="number">0</span>] = INF;</span><br><span class="line">	<span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">solve</span>(cent);</span><br><span class="line">	black = N;</span><br><span class="line">	cin &gt;&gt; Q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> opt;</span><br><span class="line">		cin &gt;&gt; opt;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (black == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (black == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; ALL.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> w;</span><br><span class="line">			cin &gt;&gt; w;</span><br><span class="line">			<span class="keyword">if</span> (color[w] == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				black++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				black--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">update</span>(w);</span><br><span class="line">			color[w] = <span class="number">1</span> - color[w];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有三倍经验 $AwA$ ：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4115">Qtree4</a> （这题要小心带边权） <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/SP2666">QTREE4 - Query on a tree IV</a> （我至今没卡完的常）</p>
<p><strong>阴间题：</strong><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3920">[WC2014]紫荆花之恋</a></p>
<p><del>我 不 会（逃</del></p>
<p>以后来填坑。</p>
<hr>
<h3 id="无旋-treap"><a href="#无旋-treap" class="headerlink" title="无旋 $treap$"></a>无旋 $treap$</h3><p><del>“这个splay就是逊啦！”</del></p>
<p>早就学过 $splay$ ，但每次敲完都会出锅，总是要对着板子全文比较。</p>
<p>导致给了窝一个刻板印象：<strong>平衡树=不行</strong>。</p>
<p><del>平衡树什么时候时候才能站起来？气抖冷。</del></p>
<p>直到窝开始盘算着学无旋 $treap$ 。</p>
<hr>
<h4 id="这是什么："><a href="#这是什么：" class="headerlink" title="这是什么："></a>这是什么：</h4><p>一种基于分裂合并操作的 $treap$ ，可以跑持久化，但不能很轻松地维护 $LCT$ 。</p>
<p>最重要的是，它很短。而且板子极为好背，针不戳。</p>
<hr>
<h4 id="思想是什么：-2"><a href="#思想是什么：-2" class="headerlink" title="思想是什么："></a>思想是什么：</h4><hr>
<h5 id="前置知识：知道普通-treap-的形态与性质。"><a href="#前置知识：知道普通-treap-的形态与性质。" class="headerlink" title="前置知识：知道普通 $treap$ 的形态与性质。"></a>前置知识：知道普通 $treap$ 的形态与性质。</h5><p>考虑一棵 $treap$ ，他在 $val$ 的维度上维持二叉搜索树的性质，在 $prio$ 维度上维持堆的性质。如下图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ezfg3y6n.png" alt=""></p>
<p>即：</p>
<ol>
<li><p>其中序遍历为原序列的 <strong>按 $val$ 的有序排列</strong>（二叉搜索树的性质）</p>
</li>
<li><p>对于任何一棵子树，都满足 <strong>根的 $prio$ 值大于儿子的</strong> $prio$ （堆的性质） </p>
</li>
</ol>
<hr>
<h5 id="无旋-treap-的特性："><a href="#无旋-treap-的特性：" class="headerlink" title="无旋 $treap$ 的特性："></a>无旋 $treap$ 的特性：</h5><p>_（接下来的叙述将会围绕着如何使无旋 $treap$ 完成 ”加点、删点、查第 $k$ 大、查排名、查前驱后继“ 来展开！）_ </p>
<p>人群当中突然钻出来一个奆佬，表示发现了一个二叉搜索树的巧妙性质：</p>
<p>以任意一个 <strong>在值域当中的数 $val$</strong> 为分割线，一定能将二叉搜索树分成  “小于等于 $val$” 与 “大于 $val$” 两部分，且这两部分分开来看也各是一棵二叉搜索树。</p>
<p>还是以原来这棵树为例，如果我们从 $val=5$ 切割：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/m6iqkoed.png" alt=""></p>
<p>（更正：右半边 $val=1$ 的结点对应标号应为 $4$ ）</p>
<p>我们发现这一个数就把他分（ $\operatorname{split}$ ）成了两棵二叉搜索树。</p>
<p>我们借助这一性质，来尝试进行一些操作。</p>
<hr>
<h6 id="加点："><a href="#加点：" class="headerlink" title="加点："></a>加点：</h6><p>首先考虑，我们直接加点时，往往只能做到把新点挂在外围。然后再经过胡乱操作（ 如 $splay$ 中的 $\operatorname{rotate}$ ）保送这个新点到该去的位置。</p>
<p>而无旋 $treap$ 则没有这样的烦恼。</p>
<p>倘若我们要加一个 $val=2$ 的点，我们先把原树按 $2$  $\operatorname{split}$ 出了 $L,R$ 两棵子树。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/wzkq03ll.png" alt=""></p>
<p>这时，我们创造一个游离的结点，保存新元素的值。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6qvz39u7.png" alt=""></p>
<p>如此实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> son[<span class="number">2</span>];<span class="comment">//左右儿子</span></span><br><span class="line">	<span class="keyword">int</span> val;<span class="comment">//val值</span></span><br><span class="line">	<span class="keyword">int</span> prio;<span class="comment">//随机赋给其的prio值，用于建出一个堆</span></span><br><span class="line">	<span class="keyword">int</span> size;<span class="comment">//以之为根的子树大小</span></span><br><span class="line">&#125; T[MAX];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(a) T[(a)].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(a) T[(a)].son[1]<span class="comment">//宏定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ROOT, cnt =  <span class="number">0</span>;<span class="comment">//根、当前点的编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//造一个游离点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T[++cnt].size = <span class="number">1</span>;</span><br><span class="line">	T[cnt].val = x;</span><br><span class="line">	T[cnt].prio = <span class="built_in">rand</span>();</span><br><span class="line">	<span class="built_in">ls</span>(cnt) = <span class="built_in">rs</span>(cnt) = <span class="number">0</span>;<span class="comment">//各种初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，我们发现原来的平衡树，它裂了（悲），但问题不大，我们可以想办法合并（ $\operatorname{merge}$ ）。</p>
<p>因为我们合并以后，需要仍然保持 $treap$ 的性质。故应判断需要合并的两棵树的 <strong>树根的 $prio$ 值的大小关系</strong> 。谁的 $prio$ 的更小，谁就挂在对方的下面。（怪）</p>
<p>这样我们先将这个游离点与左树 $\operatorname{merge}$ ，再将左树与右树 $\operatorname{merge}$ 即可～</p>
<p>（图被我弄丢了ToT <del>，或许可以使用上面那张图格物致知？</del>）</p>
<p>那么，当我们在加点过程中，把一个不平衡的二叉搜索树 <strong>裂开来</strong> ，再以一种平衡的方式 <strong>合并</strong> 回去，就能起到“制衡”的作用辣！$AwA$</p>
<p>该部分代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//更新size</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T[p].size = T[<span class="built_in">ls</span>(p)].size + T[<span class="built_in">rs</span>(p)].size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> &amp;L, <span class="keyword">int</span> &amp;R)</span></span></span><br><span class="line"><span class="function"><span class="comment">//p,x:当前递归到的点、需要加的值</span></span></span><br><span class="line"><span class="function"><span class="comment">//&amp;L,&amp;R:传进来两个地址来把最后分出的L,R树的根结点编号运出去</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!p)<span class="comment">//递归边界</span></span><br><span class="line">	&#123;</span><br><span class="line">		L = <span class="number">0</span>;</span><br><span class="line">		R = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T[p].val &lt;= x)<span class="comment">//判断条件，分裂（背板即可）</span></span><br><span class="line">	&#123;</span><br><span class="line">		L = p;</span><br><span class="line">		<span class="built_in">split</span>(<span class="built_in">rs</span>(p), x, <span class="built_in">rs</span>(p), R);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		R = p;</span><br><span class="line">		<span class="built_in">split</span>(<span class="built_in">ls</span>(p), x, L, <span class="built_in">ls</span>(p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> Lroot, <span class="keyword">int</span> Rroot)</span><span class="comment">//合并的左右树根</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Lroot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Rroot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!Rroot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Lroot;</span><br><span class="line">	&#125;<span class="comment">//倘若另一边为空，则不用和空气贴贴了，直接返回</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (T[Lroot].prio &lt; T[Rroot].prio)<span class="comment">//否则判断谁在下面</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rs</span>(Lroot) = <span class="built_in">merge</span>(<span class="built_in">rs</span>(Lroot), Rroot);</span><br><span class="line">        <span class="comment">//返回的值是两树合并后的大树的树根</span></span><br><span class="line">		<span class="built_in">push_up</span>(Lroot);</span><br><span class="line">		<span class="keyword">return</span> Lroot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ls</span>(Rroot) = <span class="built_in">merge</span>(Lroot, <span class="built_in">ls</span>(Rroot));</span><br><span class="line">		<span class="built_in">push_up</span>(Rroot);</span><br><span class="line">		<span class="keyword">return</span> Rroot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, x, l, r);<span class="comment">//先裂开来</span></span><br><span class="line">	<span class="built_in">add</span>(x);<span class="comment">//创造游离点</span></span><br><span class="line">	ROOT = <span class="built_in">merge</span>(<span class="built_in">merge</span>(l, cnt), r);</span><br><span class="line">    <span class="comment">//先合并左树和新点，再合并左树和右树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="删点："><a href="#删点：" class="headerlink" title="删点："></a>删点：</h6><p>不会真的有人删点是去把目标结点清空的吧，不会吧不会吧。</p>
<p>$splay$ 删点的做法是把它 $\operatorname{rotate}$ 到根然后往虚空里一丢。</p>
<p>可无旋 $treap$ 之所以叫“无旋”，就是因为它没有旋转的操作。</p>
<p>我们充分利用无旋 $treap$ 的特性，大力将要删的结点 $u$ 从全树上 $\operatorname{split}$ 出来，再将 <strong>除去 $u$ 的剩余几部分</strong> 大力 $\operatorname{merge}$ 回去。最终就能收获一个不带 $u$ 的新树辣！</p>
<p>图示如下 $AwA$ ：（假设我们现在要删值为 $x=6$ 的点）</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9js2l1lk.png" alt=""></p>
<p>先裂开来。再排除 $val=x=6$ 的 $3$ 号点，进行如此合并。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/x3x1qn0y.png" alt=""></p>
<p>这部分的代码实现～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l, r, tmp;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, x, l, tmp);<span class="comment">//先将大于x的部分split出来</span></span><br><span class="line">	<span class="built_in">split</span>(l, x - <span class="number">1</span>, l, r);<span class="comment">//再将小于x的部分split出来</span></span><br><span class="line">	r = <span class="built_in">merge</span>(<span class="built_in">ls</span>(r), <span class="built_in">rs</span>(r));<span class="comment">//为防止R的儿子分崩离析，先合并其儿子</span></span><br><span class="line">	ROOT = <span class="built_in">merge</span>(<span class="built_in">merge</span>(l, r), tmp);<span class="comment">//按顺序合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么只用担心 $R$ 的儿子分崩离析？</strong></p>
<p>因为他的位置很尴尬，他的左儿子可能会被 $x-1$ 的一刀砍断，右儿子可能会被 $x$ 的一刀砍断。（惨 R 惨）</p>
<hr>
<h6 id="查第-k-大："><a href="#查第-k-大：" class="headerlink" title="查第 $k$ 大："></a>查第 $k$ 大：</h6><p>因为这是一棵二叉搜索树，所以用脚想都知道一种可行的方法是中序遍历再查。</p>
<p>而且这种方法复杂度还不赖，甚至有 $O(n)$ ！（<del>暴力之耻</del>）</p>
<p>可是你清醒一点，这是一棵平衡树，他的常数不可谓不小。</p>
<p>再者说之后我们的 $pre$ 和 $nxt$ 函数也要用到它（好像有点剧透？）。</p>
<p>我们希望找到一个复杂度优秀的做法。</p>
<p>我们突然想到，我们 $treap$ 的结点信息里，似乎还保存了一个 $size$ 变量。</p>
<p>$\color{black}\mathtt{D}\color{red}\mathtt{Pair}$ 神说过，优化的第二种方式是 <strong>“可并的操作一起处理” 。</strong></p>
<p>如果我们明明知道左子树里根本没有 $k$ 这么多个元素，也就不可能存在第 $k$ 大的数。那我们凭什么往里面去递归。</p>
<p>这 <strong>给</strong> 了我们一个启发，根据 $size$ 确定递归范围，逐层找到对应位置。</p>
<p>代码实现如下～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getkth</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (K &lt;= T[<span class="built_in">ls</span>(p)].size)<span class="comment">//如果左子树里的的确确有k这么多的元素</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">getkth</span>(<span class="built_in">ls</span>(p), K);<span class="comment">//就找这其中的第k个 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (K == T[<span class="built_in">ls</span>(p)].size + <span class="number">1</span>)<span class="comment">//如果发现当前就是你要找的那个</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> p;<span class="comment">//返回</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getkth</span>(<span class="built_in">rs</span>(p), K - T[<span class="built_in">ls</span>(p)].size - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//否则，左子树把k消耗掉了T[ls(p)].size，自己又消耗掉了1</span></span><br><span class="line">    <span class="comment">//则在右子树里查第k - T[ls(p)].size - 1位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="获取元素排名："><a href="#获取元素排名：" class="headerlink" title="获取元素排名："></a>获取元素排名：</h6><p>这一操作用的不多，随便口胡一下（<del>逃</del></p>
<p>我们把一个元素以它的 $val$ 值 $split$ 出来。这时人群当中钻出来一个 $dalao$ ，他说：“我知道了，$L$ 树里的元素全都是比它小的！”</p>
<p>u1s1，qs。</p>
<p>有 $T[ls(p)].size$ 这么多的元素比它小，那么显而易见地，这个元素的排名就是 $T[ls(p)].size+1$ 。</p>
<p>别忘了 $\operatorname{merge}$ 回去。</p>
<p>代码如下～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrank</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, K - <span class="number">1</span>, l, r);<span class="comment">//按k-1 split出来</span></span><br><span class="line">	<span class="keyword">int</span> ans = T[l].size + <span class="number">1</span>;<span class="comment">//获得排名</span></span><br><span class="line">	ROOT = <span class="built_in">merge</span>(l, r);<span class="comment">//合并回去</span></span><br><span class="line">	<span class="keyword">return</span> ans;<span class="comment">//返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="查前驱："><a href="#查前驱：" class="headerlink" title="查前驱："></a>查前驱：</h6><p>我们之前提（<del>剧透</del>）到查前驱也是要用到查 $k$ 小值这一操作，想必各位一定已经YY出了做法了吧。</p>
<p>实则很简单，我们查前驱，实则就是要找小于 $x$ 的元素中，最大的一个，我们把小于 $x$ 的部分 $\operatorname{split}$ 出来后，取出这一部分的第 $T[L].size$ 位元素就可了。</p>
<p>别忘了 $\operatorname{merge}$ 回去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, x - <span class="number">1</span>, l, r);<span class="comment">//将小于x的部分分离出来</span></span><br><span class="line">	<span class="keyword">int</span> ans = T[<span class="built_in">getkth</span>(l, T[l].size)].val;<span class="comment">//取第T[l].size位</span></span><br><span class="line">	ROOT = <span class="built_in">merge</span>(l, r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="查后缀："><a href="#查后缀：" class="headerlink" title="查后缀："></a>查后缀：</h6><p>后缀与前驱同理，不多加赘述：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nxt</span><span class="params">(<span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, K, l, r);<span class="comment">//将大于x的部分分离出来</span></span><br><span class="line">	<span class="keyword">int</span> ans = T[<span class="built_in">getkth</span>(r, <span class="number">1</span>)].val;<span class="comment">//取第1位</span></span><br><span class="line">	ROOT = <span class="built_in">merge</span>(l, r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>得，这就是无旋 $treap$ 吗，i了i了。</p>
<hr>
<h4 id="劲爆习题"><a href="#劲爆习题" class="headerlink" title="劲爆习题:"></a>劲爆习题:</h4><p><strong>模板题</strong>：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3369">【模板】普通平衡树</a></p>
<p>板子题首当其 <strong>冲</strong> ！</p>
<p>要求的就是之前的六个操作，码一遍就 VAN 事了。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(a) T[(a)].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(a) T[(a)].son[1]</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> N, ROOT, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> son[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> fa;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">int</span> prio;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">&#125; T[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创造新点*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt++;</span><br><span class="line">	T[cnt].size = <span class="number">1</span>;</span><br><span class="line">	T[cnt].val = x;</span><br><span class="line">	T[cnt].prio = <span class="built_in">rand</span>();</span><br><span class="line">	<span class="built_in">ls</span>(cnt) = <span class="built_in">rs</span>(cnt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*整合子树信息*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T[p].size = T[<span class="built_in">ls</span>(p)].size + T[<span class="built_in">rs</span>(p)].size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*分裂*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> &amp;L, <span class="keyword">int</span> &amp;R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">	&#123;</span><br><span class="line">		L = <span class="number">0</span>;</span><br><span class="line">		R = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T[p].val &lt;= x)</span><br><span class="line">	&#123;</span><br><span class="line">		L = p;</span><br><span class="line">		<span class="built_in">split</span>(<span class="built_in">rs</span>(p), x, <span class="built_in">rs</span>(p), R);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		R = p;</span><br><span class="line">		<span class="built_in">split</span>(<span class="built_in">ls</span>(p), x, L, <span class="built_in">ls</span>(p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*合并*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> Lroot, <span class="keyword">int</span> Rroot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Lroot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Rroot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!Rroot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Lroot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T[Lroot].prio &lt; T[Rroot].prio)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rs</span>(Lroot) = <span class="built_in">merge</span>(<span class="built_in">rs</span>(Lroot), Rroot);</span><br><span class="line">		<span class="built_in">push_up</span>(Lroot);</span><br><span class="line">		<span class="keyword">return</span> Lroot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ls</span>(Rroot) = <span class="built_in">merge</span>(Lroot, <span class="built_in">ls</span>(Rroot));</span><br><span class="line">		<span class="built_in">push_up</span>(Rroot);</span><br><span class="line">		<span class="keyword">return</span> Rroot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, x, l, r);</span><br><span class="line">	<span class="built_in">add</span>(x);</span><br><span class="line">	ROOT = <span class="built_in">merge</span>(<span class="built_in">merge</span>(l, cnt), r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l, r, p;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, x, l, p);</span><br><span class="line">	<span class="built_in">split</span>(l, x - <span class="number">1</span>, l, r);</span><br><span class="line">	r = <span class="built_in">merge</span>(<span class="built_in">ls</span>(r), <span class="built_in">rs</span>(r));</span><br><span class="line">	ROOT = <span class="built_in">merge</span>(<span class="built_in">merge</span>(l, r), p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查第K大*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getkth</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (K &lt;= T[<span class="built_in">ls</span>(p)].size)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">getkth</span>(<span class="built_in">ls</span>(p), K);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (K == T[<span class="built_in">ls</span>(p)].size + <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getkth</span>(<span class="built_in">rs</span>(p), K - T[<span class="built_in">ls</span>(p)].size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取排名*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrank</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, K - <span class="number">1</span>, l, r);</span><br><span class="line">	<span class="keyword">int</span> ans = T[l].size + <span class="number">1</span>;</span><br><span class="line">	ROOT = <span class="built_in">merge</span>(l, r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取前驱*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, K - <span class="number">1</span>, l, r);</span><br><span class="line">	<span class="keyword">int</span> ans = T[<span class="built_in">getkth</span>(l, T[l].size)].val;</span><br><span class="line">	ROOT = <span class="built_in">merge</span>(l, r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取后继*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nxt</span><span class="params">(<span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, K, l, r);</span><br><span class="line">	<span class="keyword">int</span> ans = T[<span class="built_in">getkth</span>(r, <span class="number">1</span>)].val;</span><br><span class="line">	ROOT = <span class="built_in">merge</span>(l, r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="number">20050418</span>);<span class="comment">//窝npy的生日ww</span></span><br><span class="line">	<span class="keyword">int</span> Q;</span><br><span class="line">	cin &gt;&gt; Q;</span><br><span class="line">	<span class="keyword">while</span> (Q--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> opt, num;</span><br><span class="line">		cin &gt;&gt; opt;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			<span class="built_in">insert</span>(num);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			<span class="built_in">erase</span>(num);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			cout &lt;&lt; <span class="built_in">getrank</span>(ROOT, num) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			cout &lt;&lt; T[<span class="built_in">getkth</span>(ROOT, num)].val &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			cout &lt;&lt; <span class="built_in">pre</span>(num) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">6</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			cout &lt;&lt; <span class="built_in">nxt</span>(num) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p><strong>EX-模板题</strong> ：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3391">【模板】文艺平衡树</a></p>
<p>CSP到了，我向佛祖许愿，希望我的平衡树能实现区间翻转。</p>
<p>佛说：“我的正解是 $splay$ ，那你这在无旋 $treap$ 上如何实现？”</p>
<p>我说：“无旋 $treap$ 的区间处理能力之强。它可以用两次 $\operatorname{split}$ 轻松取出一段区间。”</p>
<p><del>“ splay 做得到吗？”（拉狗行为）</del></p>
<p>佛说：“你翻转了区间，那你这还能叫二叉搜索树吗，你的 $\operatorname{split}$ 不是废了？”</p>
<p>我说：“我的 $\operatorname{split}$ 是按 $size$ 分裂的，这样才可以确定这个区间在原序列上的位置。”（详见代码）</p>
<p>佛说：“不行，单单只是取出一段区间来个 ODT 也能做到，你有什么好说的。”</p>
<p>我说：“那就打一下 $tag$ 。同一区间翻转两次=全部木大。”</p>
<p>佛说：“不行，我这是一棵平衡树，又不是什么线段树。”</p>
<p>我说：“那我就把标记，打在 <strong>分离出来的区间</strong> 的根上，到时候标记下传的时候只需要一番大力 $swap$ 。”</p>
<p>佛说：“不行，我还是不知道怎么打标记。”</p>
<p>我说：“那就来一张图演示一下这一流程。”</p>
<p>（本图不代表最终要操作的序列，但不影响观看）</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mvau49ej.png" alt=""></p>
<p>佛说：“不行，我不知道什么时候该下传标记。”</p>
<p>我说：“打过线段树的都知道，不到 <strong>修改</strong> 或 <strong>查询</strong> 的时候是不用 $push_down$ 的。这里也是如此。”</p>
<p>“修改是没有什么用得上下传标记的地方的，毕竟每次我们分离出一段区间的时候，往往只是在这里打个 $tag$ 。从来没有 <strong>影响过其他地方</strong> 的 $tag$ 。”</p>
<p>“而查询，基于 <strong>『二叉搜索树的中序遍历是它所代表的原序列』</strong> 这一重要思想，我们应该在输出的时候 $push_down$ 就可以了。</p>
<p>佛说：“不行，那你这 $push_down$ 函数里面要干什么事情。”</p>
<p>我说：“我们观察到，翻转一个区间，可以看作是一个位置为对称轴，将一段区间 <strong>左右翻转</strong> 得来。”</p>
<p>“知道了这一个条件，我们有了一种强烈的意识，在平衡树上交换一个结点的 <strong>左右两孩子</strong> ，等价于在序列上将一个元素的 <strong>左右两边交换</strong> 。”</p>
<p>佛说：“我不信。”</p>
<p>我说：“手模一下不是有手就行？”</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/648rdi1u.png" alt=""></p>
<p>“我们先把6号结点的 $tag$ 先处理了，再把标记往下传，递归进行 ‘<strong>交换左右儿子</strong>’ 这一动作直到叶子结点不就是了。”</p>
<p>佛说：“不行，我是伸手党，我要看代码。”</p>
<p>我说：“彳亍。”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T[p].tag == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(<span class="built_in">ls</span>(p), <span class="built_in">rs</span>(p));<span class="comment">//交换左右两儿子</span></span><br><span class="line">	T[<span class="built_in">ls</span>(p)].tag ^= <span class="number">1</span>;<span class="comment">//下传标记</span></span><br><span class="line">	T[<span class="built_in">rs</span>(p)].tag ^= <span class="number">1</span>;</span><br><span class="line">	T[p].tag = <span class="number">0</span>;<span class="comment">//清空标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>佛哭了，说：”这样就能AC了。“</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*无旋treap基础组件，因码风而异*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(a) T[(a)].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(a) T[(a)].son[1]</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> ROOT;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">int</span> son[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">int</span> tag;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> prio;</span><br><span class="line">&#125; T[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T[p].size = T[<span class="built_in">ls</span>(p)].size + T[<span class="built_in">rs</span>(p)].size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下传标记*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T[p].tag == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(<span class="built_in">ls</span>(p), <span class="built_in">rs</span>(p));</span><br><span class="line">	T[<span class="built_in">ls</span>(p)].tag ^= <span class="number">1</span>;</span><br><span class="line">	T[<span class="built_in">rs</span>(p)].tag ^= <span class="number">1</span>;</span><br><span class="line">	T[p].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创造一个新结点*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T[++cnt].val = x;</span><br><span class="line">	T[cnt].prio = <span class="built_in">rand</span>();</span><br><span class="line">	T[cnt].size = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">ls</span>(cnt) = <span class="built_in">rs</span>(cnt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*分离*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> &amp;L, <span class="keyword">int</span> &amp;R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">push_down</span>(p);</span><br><span class="line">	<span class="keyword">if</span> (!x)</span><br><span class="line">	&#123;</span><br><span class="line">		L = <span class="number">0</span>;</span><br><span class="line">		R = p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T[<span class="built_in">ls</span>(p)].size &lt; x)<span class="comment">//这样才能精准定位在原序列上</span></span><br><span class="line">	&#123;</span><br><span class="line">		L = p;</span><br><span class="line">		<span class="built_in">split</span>(<span class="built_in">rs</span>(p), x - T[<span class="built_in">ls</span>(p)].size - <span class="number">1</span>, <span class="built_in">rs</span>(p), R);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		R = p;</span><br><span class="line">		<span class="built_in">split</span>(<span class="built_in">ls</span>(p), x, L, <span class="built_in">ls</span>(p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*合并*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> Lroot, <span class="keyword">int</span> Rroot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Lroot || !Rroot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Rroot + Lroot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_down</span>(Lroot);</span><br><span class="line">	<span class="built_in">push_down</span>(Rroot);</span><br><span class="line">	<span class="keyword">if</span> (T[Lroot].prio &gt;= T[Rroot].prio)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rs</span>(Lroot) = <span class="built_in">merge</span>(<span class="built_in">rs</span>(Lroot), Rroot);</span><br><span class="line">		<span class="built_in">push_up</span>(Lroot);</span><br><span class="line">		<span class="keyword">return</span> Lroot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ls</span>(Rroot) = <span class="built_in">merge</span>(Lroot, <span class="built_in">ls</span>(Rroot));</span><br><span class="line">		<span class="built_in">push_up</span>(Rroot);</span><br><span class="line">		<span class="keyword">return</span> Rroot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入，其实是用来初始化 treap 用的*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, p - <span class="number">1</span>, l, r);</span><br><span class="line">	<span class="built_in">add</span>(x);</span><br><span class="line">	<span class="comment">// cout &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">	ROOT = <span class="built_in">merge</span>(<span class="built_in">merge</span>(l, cnt), r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*翻转*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>, p3 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, r, p1, p2);<span class="comment">//右边断开，剩下的装在p1里</span></span><br><span class="line">	<span class="built_in">split</span>(p1, l - <span class="number">1</span>, p1, p3);<span class="comment">//左边断开，剩下的装在p3里</span></span><br><span class="line">    <span class="comment">//这时我们取出的区间，其实就是以p3为根这棵树</span></span><br><span class="line">    </span><br><span class="line">	T[p3].tag ^= <span class="number">1</span>;<span class="comment">//打tag</span></span><br><span class="line">	ROOT = <span class="built_in">merge</span>(<span class="built_in">merge</span>(p1, p3), p2);<span class="comment">//合并回去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*中序遍历输出*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_down</span>(p);</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">ls</span>(p));</span><br><span class="line">	cout &lt;&lt; T[p].val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">rs</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="number">20050418</span>);<span class="comment">//窝npy的生日qwq</span></span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">insert</span>(i, i);<span class="comment">//初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (M--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> l, r;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="built_in">reverse</span>(l, r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(ROOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>次模板题</strong>： <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1486">[NOI2004]郁闷的出纳员</a></p>
<p>一道深刻考验选手对无旋 $treap$ 内层原理的（<del>毒瘤</del>）好题。</p>
<p>这题要求：1.全局加减 $k$ ，2.删去小于 $val$ 的所有元素 ，3.插入一个元素 ， 4.查询第 $k$ 大。</p>
<p>首先一眼发现，因为加减都是全局加减，所以根本没有必要真的加在每一个元素上，随手开个 $delta$ ，表示 <strong>全局的改变量</strong> 。</p>
<p>而剩下与数值有关的，只有一个 “<strong>删去小于 $val$ 的所有元素</strong>” 操作了。</p>
<p>因为我们手上有 $delta$ ，我们可以顺理成章地把这一操作看作 “<strong>删去小于 $val-delta$ 的所有元素</strong>” 。</p>
<p>_（以元素值为参考系（误），元素值增加了delta，可以看作是这个val减小了delta）_</p>
<p>“真正的勇士，敢于面对直接枚举元素的复杂度。”（$\times$）</p>
<p>“真正的勇士，敢于面对 TLE 0 。”（$\surd$）</p>
<p>你意识到无旋 $treap$ 的 $\operatorname{split}$ 的作用就是将原树分成  “ <strong>小于等于 $val$</strong> ” 与 “ <strong>大于 $val$</strong> ” 两部分。</p>
<p>那我们以 $val-delta$ 分，不就可以让我们分离出来的左树，装的都是小于 $val-delta$ 的元素了？</p>
<p>分离完了以后直接使 <strong>全树的 ROOT 等于右树的根</strong> ，相当于把左树里这些小于 $val$ 的数全部逐入虚空。</p>
<p>这样便可实现删点。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(a) T[(a)].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(a) T[(a)].son[1]</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> N, ROOT, cnt = <span class="number">0</span>, delta = <span class="number">0</span>;<span class="comment">//delta为改变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> son[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> fa;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">int</span> prio;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">&#125; T[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创造新点*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt++;</span><br><span class="line">	T[cnt].size = <span class="number">1</span>;</span><br><span class="line">	T[cnt].val = x;</span><br><span class="line">	T[cnt].prio = <span class="built_in">rand</span>();</span><br><span class="line">	<span class="built_in">ls</span>(cnt) = <span class="built_in">rs</span>(cnt) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*整合子树信息*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T[p].size = T[<span class="built_in">ls</span>(p)].size + T[<span class="built_in">rs</span>(p)].size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*分裂*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> &amp;L, <span class="keyword">int</span> &amp;R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">	&#123;</span><br><span class="line">		L = <span class="number">0</span>;</span><br><span class="line">		R = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T[p].val &lt;= x)</span><br><span class="line">	&#123;</span><br><span class="line">		L = p;</span><br><span class="line">		<span class="built_in">split</span>(<span class="built_in">rs</span>(p), x, <span class="built_in">rs</span>(p), R);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		R = p;</span><br><span class="line">		<span class="built_in">split</span>(<span class="built_in">ls</span>(p), x, L, <span class="built_in">ls</span>(p));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*合并*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> Lroot, <span class="keyword">int</span> Rroot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Lroot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Rroot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!Rroot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Lroot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T[Lroot].prio &lt; T[Rroot].prio)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">rs</span>(Lroot) = <span class="built_in">merge</span>(<span class="built_in">rs</span>(Lroot), Rroot);</span><br><span class="line">		<span class="built_in">push_up</span>(Lroot);</span><br><span class="line">		<span class="keyword">return</span> Lroot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ls</span>(Rroot) = <span class="built_in">merge</span>(Lroot, <span class="built_in">ls</span>(Rroot));</span><br><span class="line">		<span class="built_in">push_up</span>(Rroot);</span><br><span class="line">		<span class="keyword">return</span> Rroot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, x, l, r);</span><br><span class="line">	<span class="built_in">add</span>(x);</span><br><span class="line">	ROOT = <span class="built_in">merge</span>(<span class="built_in">merge</span>(l, cnt), r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除左树*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteall</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l, r, tmp;</span><br><span class="line">	<span class="built_in">split</span>(ROOT, x - <span class="number">1</span>, l, r);</span><br><span class="line">	<span class="keyword">int</span> ans = T[l].size;</span><br><span class="line">	ROOT = r;<span class="comment">//以右树为根</span></span><br><span class="line">	<span class="keyword">return</span> ans;<span class="comment">//返回丢弃的元素数，即T[l].size</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查第k大*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getkth</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T[<span class="built_in">ls</span>(p)].size &gt;= k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">getkth</span>(<span class="built_in">ls</span>(p), k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T[<span class="built_in">ls</span>(p)].size + <span class="number">1</span> == k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getkth</span>(<span class="built_in">rs</span>(p), k - T[<span class="built_in">ls</span>(p)].size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="number">20050418</span>);</span><br><span class="line">	<span class="keyword">int</span> sumout = <span class="number">0</span>;<span class="comment">//总共被丢掉的人数</span></span><br><span class="line">	<span class="keyword">int</span> N, LIM;<span class="comment">//LIM，下界</span></span><br><span class="line">	cin &gt;&gt; N &gt;&gt; LIM;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> opt;</span><br><span class="line">		cin &gt;&gt; opt;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> num;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			<span class="keyword">if</span> (num &lt; LIM)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">insert</span>(num - delta);</span><br><span class="line">            <span class="comment">//相对地，插入的num也会减小delta</span></span><br><span class="line">            </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> num;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			delta += num;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> num;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			delta -= num;</span><br><span class="line">			sumout += <span class="built_in">deleteall</span>(LIM - delta);</span><br><span class="line">            <span class="comment">//相对地，插入的LIM也会减小delta</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> num;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			<span class="keyword">if</span> (T[ROOT].size &lt; num)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; T[<span class="built_in">getkth</span>(ROOT, T[ROOT].size - num + <span class="number">1</span>)].val + delta &lt;&lt; endl;</span><br><span class="line">            <span class="comment">//相应地，查到的第k大也要+delta</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; sumout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h3 id="网络流基础建模——最大流"><a href="#网络流基础建模——最大流" class="headerlink" title="网络流基础建模——最大流"></a>网络流基础建模——最大流</h3><p>这里讲的不是实现，只是一些套路。</p>
<hr>
<script type="math/tex; mode=display">\color{red}{\texttt{FBI WARNING:}}</script><script type="math/tex; mode=display">\color{red}{\texttt{警告：以下内容可能涉及口胡、强迫症、及光敏性癫痫（划）}}</script><script type="math/tex; mode=display">\color{red}{\texttt{请18岁以下儿童在成年人陪同下观看}}</script><hr>
<p>都0202年了，不会真有人认为网络流都是套路题吧？</p>
<p>哦是我啊那没事了。</p>
<h4 id="套路一：构建超级源汇："><a href="#套路一：构建超级源汇：" class="headerlink" title="套路一：构建超级源汇："></a>套路一：构建超级源汇：</h4><p>有的题目，他告诉你谁和谁之间有阿巴阿巴的路径，但硬是不告诉你谁是源，谁是汇。</p>
<p>这时候，朴素的最大流思想可能就会陷入僵局。</p>
<p>但是我们有超级源汇的思想。</p>
<p>我们 <strong>创建一个新点</strong> ，称其为源。</p>
<p>向所有该连的点连边。</p>
<p>汇的思想同理。</p>
<p>建一张图就像这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fzwy996m.png" alt=""></p>
<p>可以看出，这一思想用于处理 <strong>“你……，他……，而我……，我们都有全局的贡献”</strong> 的问题。</p>
<p>下面来看这个命题：</p>
<p>_RUI_R有了去NOI和APIO的资格，zjjws有了去WC和APIO的资格，而我有了去加里敦参加夏令营的资格，我们都有对XJ的贡献。试问，如果一个人只能去打一场比赛，XJ能收获多少参赛名额。_</p>
<p>一眼看出，这是典型的多源多汇模型。</p>
<p>把每个人和自己能参加的比赛连边，这时相当于是跑一个 <strong>二分图最大匹配</strong> 。</p>
<p>而我们要以网络流的思想解决，则需要 <strong>开一个超级源，向所有人连边，开一个超级汇，让所有比赛向它连边</strong> 。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/phk99zjp.png" alt=""></p>
<p>这里超级源连出去的边容量为1，即 限制了每个人最多 <strong>只能打一场比赛</strong> ，也就是 <strong>从一个人流出的流量最多为1</strong> 。</p>
<p>这启发我们，超级源汇在连边时可以有意无意地起到 <strong>限流</strong> 作用。</p>
<h5 id="劲爆例题："><a href="#劲爆例题：" class="headerlink" title="劲爆例题："></a>劲爆例题：</h5><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2756">飞行员配对方案问题</a></p>
<p>典型的二分图最大匹配，一边是英国飞行员，一边是外国飞行员，如果俩人能打配合，就在俩人之间连边。</p>
<p>随手像上面那样建一张图。</p>
<p>这时我们发现，外国飞行员也是人，他也只能和一个人进行配对。</p>
<p><del><strong>外国飞行员</strong> 使用分身术，出现了一个新的 <strong>外国飞行员</strong></del></p>
<p>所有右边的点向超级汇的连边，容量改为 $1$ 。</p>
<p>这样我们就建出了一张图，在这张图上跑一个最大流就珂以了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*dinic组件*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">107</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next, to, val;</span><br><span class="line">&#125; e[MAX * MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].next = head[x];</span><br><span class="line">	e[eid].to = y;</span><br><span class="line">	e[eid].val = w;</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="keyword">int</span> dep[MAX];</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUN(u) for (int i = head[(u)]; i; i = e[i].next)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">	dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	q.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">RUN</span>(u)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (dep[v] || e[i].val == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[T])</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u == T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> in;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">RUN</span>(u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (dep[v] != dep[u] + <span class="number">1</span> || e[i].val == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(in, e[i].val));</span><br><span class="line">		e[i].val -= tmp;</span><br><span class="line">		e[i ^ <span class="number">1</span>].val += tmp;</span><br><span class="line">		in -= tmp;</span><br><span class="line">		out += tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (out == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dep[u] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; num;</span><br><span class="line">	<span class="keyword">int</span> fr, to;</span><br><span class="line">	S = <span class="number">0</span>;<span class="comment">//超级源定为0号</span></span><br><span class="line">	T = num + <span class="number">1</span>;<span class="comment">//超级汇定为num+1号</span></span><br><span class="line">    <span class="comment">/*反正只要是个用不上的点就可以了*/</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; fr &gt;&gt; to &amp;&amp; fr != <span class="number">-1</span> &amp;&amp; to != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">adde</span>(fr, to, <span class="number">1</span>);<span class="comment">//能配合的俩人连一条边</span></span><br><span class="line">		<span class="built_in">adde</span>(to, fr, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">adde</span>(S, i, <span class="number">1</span>);<span class="comment">//超级源向英国飞行员连边</span></span><br><span class="line">		<span class="built_in">adde</span>(i, S, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N + <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">adde</span>(i, T, <span class="number">1</span>);<span class="comment">//外国飞行员向超级汇连边</span></span><br><span class="line">		<span class="built_in">adde</span>(T, i, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*奇怪的dinic，写法因人而异*/</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">bfs</span>();</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += <span class="built_in">dfs</span>(S, INF);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= eid; i++, i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (e[i].to != S &amp;&amp; e[i ^ <span class="number">1</span>].to != S &amp;&amp; e[i].to != T &amp;&amp; e[i].to != T)</span><br><span class="line">        <span class="comment">//输出方案</span></span><br><span class="line">        <span class="comment">//这里的做法是遍历每一条边，查他是否有残量</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (e[i ^ <span class="number">1</span>].val)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; e[i ^ <span class="number">1</span>].to &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; e[i].to &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="套路二：最大流改最小割："><a href="#套路二：最大流改最小割：" class="headerlink" title="套路二：最大流改最小割："></a>套路二：最大流改最小割：</h4><p><del>窝非常擅长鸽。</del></p>
<p>有的题目，他告诉你选了阿巴阿巴就不能选阿巴阿巴。</p>
<p>这时候，朴素的最大流思想可能就会陷入僵局。</p>
<p>但是神仙们证出了最大流等于最小割。</p>
<p>这个问题就转化成了，我 <strong>放弃选一些东西，使我剩下的收益最大</strong> 。</p>
<p>考虑全图中从源点到汇点的一条路径，假设这条路径是由 <strong>好几段拼成</strong> 的。</p>
<p>我想把它割断至无法通流，则必然是割断其中的 <strong>某一段</strong> 。这个“割断”的过程，实则就是相当于 <strong>放弃了这一段的收益</strong> 。</p>
<p>而这条路径上的其它几段得以保留，所以我能获得剩下的这些收益。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/pr82ttfy.png" alt=""></p>
<p>这时，存在两条路径从源点通往汇点的路径，我们要把他们割断，一种可行的做法是割断 $value_{\ 5}$ 使剩下4个 $value$ 得以保留。</p>
<p>当然，还存在一种做法是割断 $value_1,value_3$ 使剩下三个得以保留。</p>
<p>此外，在有的题目中，有的利益是固定利益，是无法丢弃的，这时，我们就可以将这条边的容量设为 <strong>INF</strong> 。</p>
<p>可以看出，最小割模型非常善于处理 “<strong>可以……，但是你得……，这一切值得吗？</strong>”的问题。</p>
<p>下面来看这个命题：</p>
<p>_“我告诉你，但是你得跟我搞姬，这一切值得吗？”_</p>
<p>我们可以看出这里存在一个约束关系， “ <strong>我可以得到题解，但是我有翻车的危险，即‘失去了安全’</strong> ”。</p>
<p>那么很显然我们可以建出一张图，像这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4h37evq5.png" alt=""></p>
<p><del>颜色好评</del>，如果我们选择了题解，那么我们就会失去开车的安全；反之同理。</p>
<h5 id="劲爆例题：-1"><a href="#劲爆例题：-1" class="headerlink" title="劲爆例题："></a>劲爆例题：</h5><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2774">方格取数问题</a></p>
<p>首先，一眼看出模型，“我可以选这个点，但是我就选不了周围这些点了，这一切值得吗？”。</p>
<p>那么我们随便挑出两个相邻的方格，都可以建出这样的图。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/l1mggdnp.png" alt=""></p>
<p>表示要么选 $val_1$ ，要么选 $val_2$ 。</p>
<p>如果我们对于每一个点建一张如上例的图，最终的成品就是这个玩意。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/24xf1ztt.png" alt=""></p>
<p>这时我们发现，这张图根本没有源和汇。/jk</p>
<p>但是我们的内心毫无波澜，甚至一眼出了 <strong>超级源汇</strong> 的思想。</p>
<p>可超级源汇的模型也不是用脚造的，我们需要决定 <strong>谁去连源，谁去连汇</strong> 。</p>
<p>想起了之前飞行员配对的做法，我们可以把这些点分出一张 <strong>二分图</strong> 。</p>
<p>二分图的要求是同一部分内 <strong>无连边</strong> 。正难则反，什么点之间有连边？显然是相邻的点。</p>
<p>那么，无连边的部分，必然是那些不相邻的。</p>
<p>这时，我们就可以用黑白染色的方式，建出如下的图。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/i7k25dmu.png" alt=""></p>
<p>此时，随便挑出一条路径来，依然满足 <strong>最小割</strong> 的样式，可以在这上面跑最大流，来求出这一 <strong>最小的舍弃价值</strong> 。</p>
<p>而我们收获的价值，就是 <strong>所有价值总和-舍弃的价值</strong> 。</p>
<p>代码如下：</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*dinic组件*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next, to;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125; e[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].next = head[x];</span><br><span class="line">	e[eid].to = y;</span><br><span class="line">	e[eid].val = w;</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[MAX];</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUN(u) for (int i = head[u]; i; i = e[i].next)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">	dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	q.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">RUN</span>(u)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (e[i].val == <span class="number">0</span> || dep[v])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[T])</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u == T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> in;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">RUN</span>(u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (e[i].val == <span class="number">0</span> || dep[v] != dep[u] + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(in, e[i].val));</span><br><span class="line">		<span class="keyword">if</span> (in == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		e[i].val -= tmp;</span><br><span class="line">		e[i ^ <span class="number">1</span>].val += tmp;</span><br><span class="line">		in -= tmp;</span><br><span class="line">		out += tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (out == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dep[u] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> M, N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="comment">//获取一个方格的编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x - <span class="number">1</span>) * N + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; M &gt;&gt; N;<span class="comment">//这道题对N,M的定义是和常识相反的</span></span><br><span class="line">    <span class="comment">//申必题（bushi</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	S = <span class="number">0</span>, T = <span class="number">107</span> * <span class="number">107</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> num;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			sum += num;</span><br><span class="line">			<span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>)<span class="comment">//若行+列=奇则染白，连源点</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(S, <span class="built_in">idx</span>(i, j), num);</span><br><span class="line">				<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j), S, <span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*向上下左右四个方向连边*/</span></span><br><span class="line">				<span class="keyword">if</span> (i &gt; <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j), <span class="built_in">idx</span>(i - <span class="number">1</span>, j), INF);</span><br><span class="line">					<span class="built_in">adde</span>(<span class="built_in">idx</span>(i - <span class="number">1</span>, j), <span class="built_in">idx</span>(i, j), <span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (i &lt; M)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j), <span class="built_in">idx</span>(i + <span class="number">1</span>, j), INF);</span><br><span class="line">					<span class="built_in">adde</span>(<span class="built_in">idx</span>(i + <span class="number">1</span>, j), <span class="built_in">idx</span>(i, j), <span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (j &gt; <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j), <span class="built_in">idx</span>(i, j - <span class="number">1</span>), INF);</span><br><span class="line">					<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j - <span class="number">1</span>), <span class="built_in">idx</span>(i, j), <span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (j &lt; N)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j), <span class="built_in">idx</span>(i, j + <span class="number">1</span>), INF);</span><br><span class="line">					<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j + <span class="number">1</span>), <span class="built_in">idx</span>(i, j), <span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">                </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//若行+列=偶则染黑，连汇点</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j), T, num);</span><br><span class="line">				<span class="built_in">adde</span>(T, <span class="built_in">idx</span>(i, j), <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">bfs</span>();</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += <span class="built_in">dfs</span>(S, INF);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; sum - ans &lt;&lt; endl;<span class="comment">//收益为总价值-割</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h4 id="套路二-进阶：其他黑白染色模型："><a href="#套路二-进阶：其他黑白染色模型：" class="headerlink" title="套路二-进阶：其他黑白染色模型："></a>套路二-进阶：其他黑白染色模型：</h4><p>上文的方格取数问题，可以归为一种黑白染色模型中的典型。</p>
<p>而解决这种问题，其要义在于构建一种可行的方式，将所有玩意分成两堆，使得任何 <strong>黑点与白点之间都没有直接连边</strong> 。</p>
<p>听上去很 $simple$ ，实际上的确很 $naive$ 。</p>
<p>就随便挑一道题来看叭～</p>
<p>_以下只阐述如何染色，其他实现细节在此不提_</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3355">骑士共存问题</a></li>
</ul>
<p>就用题目上的原图好了。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/2669.png" alt=""></p>
<p>我们发现 $S$ 在一个黄点，而他的下一步必然是一个红点。（由图可知）</p>
<p>那么我们像方格取数一样，按 <strong>（行+列）的奇偶性</strong> 黑白染色即可。</p>
<p>甚至还能白嫖双倍经验 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4304"><img src="https://cdn.luogu.com.cn/upload/image_hosting/pssyi5aw.png" alt=""></a> 。</p>
<p>\<br>那个表情是超链接……</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5030">长脖子鹿放置</a></li>
</ul>
<p>长脖子鹿不会被别马腿因为长脖子鹿只有鹿腿哈哈哈哈哈哈哈</p>
<p><del>其实一点也不好笑</del></p>
<p>这道题面里还是有图，我们还是征用题面里的图。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/37260.png" alt=""></p>
<p>可以看到这里，一个白点会跳到另一个白点上。我们之前（行+列）奇偶性染色法就不行了。</p>
<p>但我们会想出新方法切了这道题。</p>
<p>因为长脖子鹿跳一下是 $2\times 4$ 的，我们发现，行和列加的都是偶数， <strong>不影响其奇偶性</strong> 。</p>
<p>也就是说，奇行和偶行之间不会有连边。</p>
<p>所以我们将 <strong>奇行染黑，偶行染白</strong> 即可。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4474">王者之剑</a></li>
</ul>
<p>高质量好题/se/se/se（指题面</p>
<p>王固然是天下第一，但是这道题出题人也是脑洞真的大。</p>
<p>我们看见，每隔两秒周围四个地方的宝石都会消失。而这两秒之内我们能干什么，一秒踩在一块有宝石的砖上吸走了宝石，下一秒在一块空砖上赶路前往下一个有宝石的地方。</p>
<p>也就是说，我们吸走了一个地方的宝石， <strong>周围四个位置</strong> 都是必然拿不到了的。</p>
<p>然后，就变成方格取数问题了？？？</p>
<p>我直接震惊。</p>
<ul>
<li>有一道叫 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2172">[国家集训队]部落战争</a> 的题，看上去很像黑白染色，事实上他是最小路径覆盖问题。我们之后会提到。</li>
</ul>
<hr>
<h4 id="套路一-套路二-套路三：最大权闭合子图模型"><a href="#套路一-套路二-套路三：最大权闭合子图模型" class="headerlink" title="套路一+套路二=套路三：最大权闭合子图模型"></a>套路一+套路二=套路三：最大权闭合子图模型</h4><p>“有的题目，他告诉你必须得选阿巴阿巴才能选阿巴阿巴。有时候选阿巴阿巴可能带来负收益。”</p>
<p>这和套路二的最小割模型没有什么区别，如果你是<del>语文王子</del>，你会发现上面这句话其实和套路二表达的是同一个意思。</p>
<p>只不过让人以为这里仿佛有负边权，然后自闭。</p>
<p>我们换一种说法：对于一个正收益的东西，我们要么 <strong>得到这个价值</strong> ，要么 <strong>省下“得到这个价值”所需要的钱</strong> 。</p>
<p>由此一来，最小割的思想就呼之欲出力。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/hctsarux.png" alt=""></p>
<p>即：要么获得价值 $value$ ，要么赚回花费 $cost$ 。</p>
<p>由于一个正收益的物品，可能需要很多种的 <strong>前置花费</strong> ，同时，一个负收益的物品可能同时成为很多物品的 <strong>前置花费</strong> 。</p>
<p>所以我们常常会用到超级源汇的思想 $qwq$ 。</p>
<p>不难看出，最大权闭合子图模型适合解决 <strong>“tyy讲题”</strong> 类型的题。</p>
<p>（<del>生动比喻了有一大堆前置知识的数论 <strong>浅</strong> 谈</del>）</p>
<p>我们来看下面这个命题：</p>
<blockquote>
<p>tyy在讲课，今天他要讲的是杜教筛和min25，其中，杜教筛需要莫反和积性函数的前置知识，min25需要多项式和积性函数的前置知识，学这些前置知识需要你爆掉一定的肝，但是学一个新科技筛法又可以恢复一定的肝，求自己最大收益。</p>
</blockquote>
<p>一眼发现有 “前置知识” 这一 <strong>有 趣</strong> 的玩意。</p>
<p>我们把杜教筛单独拉出来看，有下面的最小割模型：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/hxevwuo8.png" alt=""></p>
<p>（<del>颜色好评</del>）</p>
<p>表示我们要么去学杜教筛 $val_{mifafa}$ ，要么省下 $cost_{mobius}+cost_{multi}$ 的花费。</p>
<p>而放之全图就像这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5hec6crl.png" alt=""></p>
<p><del>迫真英语翻译。</del></p>
<p>这样，我们就可以跑出全图的最小割辣。</p>
<p>但是，我们此时不能直接用总价值减去最小割来求解。</p>
<p>我们此前称学习前置知识的价值，是 <strong>我们省下了多少肝</strong> 。</p>
<p>可我们什么也不学，他又不会白送我们这些肝。换言之，这些肝本就不是我们应得的。</p>
<p>我们本该得的，是学这些筛法所收获的科技知识。</p>
<p><del>明明是你自己要偷懒护肝的。</del></p>
<p>所以我们应该用所有筛法的收益之和，减去最小割，这才是我们最终的答案。</p>
<script type="math/tex; mode=display">ans=val_{mifafa}+val_{min25}-smallest\_cut</script><h5 id="劲爆例题：-2"><a href="#劲爆例题：-2" class="headerlink" title="劲爆例题："></a>劲爆例题：</h5><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3410">拍照</a></p>
<p>一眼看出，我可以获得拍一张照的价值，但是我有带几个人的前置条件。</p>
<p>这很容易就转化为了 <strong>最大权闭合子图</strong> 的模型。</p>
<p>用脚也可以造出同上例一样的图。</p>
<p>（其实用本题样例建出来的图和上一张图是一模一样的。）</p>
<p>然后按部就班做就VAN事了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*dinic组件*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">107</span> * <span class="number">107</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next, val;</span><br><span class="line">&#125; e[MAX];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].to = y;</span><br><span class="line">	e[eid].next = head[x];</span><br><span class="line">	e[eid].val = w;</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[MAX];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUN(u) for (int i = head[(u)]; i; i = e[i].next)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">	dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	q.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">RUN</span>(u)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (dep[v] || !e[i].val)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[T])</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u == T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> in;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">RUN</span>(u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (dep[v] != dep[u] + <span class="number">1</span> || e[i].val == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(in, e[i].val));</span><br><span class="line">		e[i].val -= tmp;</span><br><span class="line">		e[i ^ <span class="number">1</span>].val += tmp;</span><br><span class="line">		in -= tmp;</span><br><span class="line">		out += tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (out == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dep[u] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; M &gt;&gt; N;</span><br><span class="line">	S = <span class="number">0</span>, T = N + M + <span class="number">1</span>;<span class="comment">//超级源汇</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//正收益之和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> num;</span><br><span class="line">		cin &gt;&gt; num;<span class="comment">//照片价值，由源点连边，累加进sum</span></span><br><span class="line">		sum += num;</span><br><span class="line">		<span class="keyword">int</span> l;</span><br><span class="line">		<span class="built_in">adde</span>(S, i, num);</span><br><span class="line">		<span class="built_in">adde</span>(i, S, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> (cin &gt;&gt; l &amp;&amp; l)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">adde</span>(i, l + M, INF);<span class="comment">//向前置条件连边</span></span><br><span class="line">			<span class="built_in">adde</span>(l + M, i, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> num;</span><br><span class="line">		cin &gt;&gt; num;<span class="comment">//前置花费，向汇点连边</span></span><br><span class="line">		<span class="built_in">adde</span>(i + M, T, num);</span><br><span class="line">		<span class="built_in">adde</span>(T, i + M, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">bfs</span>();</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += <span class="built_in">dfs</span>(S, INF);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; sum - ans &lt;&lt; endl;<span class="comment">//跑最小割，出结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="套路四：拆点"><a href="#套路四：拆点" class="headerlink" title="套路四：拆点"></a>套路四：拆点</h4><p>“有的题目，他告诉你他要最大收益，但是一个物品只能用阿巴阿巴次。或者他要最小割，但是割的是点，不是边。”</p>
<p>这是，朴素的最大流/最小割就会陷入僵局。</p>
<p>但是拆点是一个好 办 法。</p>
<p>拆点的要义是：把一个点拆成 <strong>入点</strong> 和 <strong>出点</strong> 两个点，在这两个点之间连上一条 <strong>一定容量 $limit$</strong> 的边。</p>
<p>这样，任何时候，通过这个点的流量都只会控制在 $limit$ 之内。</p>
<p>老百度网盘了<img src="https://cdn.luogu.com.cn/upload/image_hosting/zow878de.png" alt=""></p>
<p>具化到图上，如果我们需要控制通过一个点的流量永远不超过 $limit$ ，则有：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/m8c4a1c0.png" alt=""></p>
<p>$in$ 和 $out$ 都是从同一个点上拆出来的，我们让通过这个点的流量不超过 $limit$ ，实际上就可以把 $in$ 和 $out$ 之间这条边的容量限为 $limit$ 。</p>
<p>不难看出，拆点模型适合处理“<del>购买超级会员享受8倍速度</del>” 的百度云 <strong>限流</strong> 行为。</p>
<p>来看下面这个命题：</p>
<blockquote>
<p>XJ地形可以简化成一张有向无环图。在结点处，会站有值周班同学检查。此时，在他面前跑过的人 <strong>禁止超过</strong>  $W_i$ 。现在给出每个结点处的检查情况，试求最多有多少学生能在去食堂的路上跑步。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U141285">原题链接【12：20】（还没有数据）</a></p>
<p>很显然，这里有明显的限流现象。（ <del>指站在一旁看着高一学生 rush</del> ）</p>
<p>从一个检查点到另一个检查点是随便你怎么跑的，<del>从XJ中学12:20时的情况便可知晓</del>。</p>
<p>言外之意是， <strong>边</strong> 上的限流为 $inf$ 。</p>
<p>而对于一个点上的限流，我们把一个点拆成一个出点和一个入点，两点之间连长度为 <strong>人数限制</strong> 的一条边。</p>
<p>这样，我们就能建出这样一张图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/qgpn1rls.png" alt=""></p>
<p>在这张图上，我们就可以做到通过每个检查点的人数不超过 $limit$ 人。</p>
<p>可以注意到的是，<strong>图上源连的是入点，汇连的是出点，前一个点的出点连的是后一个点的入点</strong>。</p>
<p>而这张图上的最大流，就是本题的答案。</p>
<h4 id="劲爆习题：-2"><a href="#劲爆习题：-2" class="headerlink" title="劲爆习题："></a>劲爆习题：</h4><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1345">[USACO5.4]奶牛的电信Telecowmunication</a></p>
<p>之前是拆点求最大流，而现在是拆点求最小割。</p>
<p>不能割边，则把所有边的边权设成 $inf$  ，这是无可厚非的。</p>
<p>因为我们割的是点，而点在网络流上不好处理，所以我们把一个点拆成两个点，两点之间连容量为 $1$ 的边。</p>
<p><strong>为什么连边权为 $1$ 呢？</strong><img src="https://cdn.luogu.com.cn/upload/image_hosting/hu55cdoh.png" alt=""></p>
<p>我们割一条这种边，相当于我们拆了一台电脑。（可怜的 FarmerJohn /dk）</p>
<p>而题目要求的是拆电脑的数量，那么设边权为 $1$ ，可以正好反映拆的数量。</p>
<p>答案即为全图的最小割。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*dinic组件*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next, to;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125; e[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].next = head[x];</span><br><span class="line">	e[eid].to = y;</span><br><span class="line">	e[eid].val = w;</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[MAX];</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUN(u) for (int i = head[u]; i; i = e[i].next)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">	dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	q.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">RUN</span>(u)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (e[i].val == <span class="number">0</span> || dep[v])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[T])</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u == T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> in;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">RUN</span>(u)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (e[i].val == <span class="number">0</span> || dep[v] != dep[u] + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(in, e[i].val));</span><br><span class="line">		<span class="keyword">if</span> (in == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		e[i].val -= tmp;</span><br><span class="line">		e[i ^ <span class="number">1</span>].val += tmp;</span><br><span class="line">		in -= tmp;</span><br><span class="line">		out += tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (out == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dep[u] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> com[MAX];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	cin &gt;&gt; S &gt;&gt; T;</span><br><span class="line">	S += N;</span><br><span class="line">    <span class="comment">//对于一个点 i ，我们钦定 i 为其入点，i+N 为其出点</span></span><br><span class="line">    <span class="comment">//那么这里直接从源点的出点 (S+N) 开始。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> fr, to;</span><br><span class="line">		cin &gt;&gt; fr &gt;&gt; to;</span><br><span class="line">		<span class="built_in">adde</span>(fr + N, to, INF);</span><br><span class="line">        <span class="comment">//两点之间连边，fr_out 连向 to_in</span></span><br><span class="line">		<span class="built_in">adde</span>(to, fr + N, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">adde</span>(to + N, fr, INF);<span class="comment">//双向边</span></span><br><span class="line">		<span class="built_in">adde</span>(fr, to + N, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">adde</span>(i, i + N, <span class="number">1</span>);<span class="comment">//自己的出点入点连边</span></span><br><span class="line">		<span class="built_in">adde</span>(i + N, i, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">bfs</span>();</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += <span class="built_in">dfs</span>(S, INF);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;<span class="comment">//最小割出结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="套路一-套路四-套路四点五：网络流与LIS"><a href="#套路一-套路四-套路四点五：网络流与LIS" class="headerlink" title="套路一+套路四=套路四点五：网络流与LIS"></a>套路一+套路四=套路四点五：网络流与LIS</h4><p>有的题目，他让你求 <strong>LIS 的条数</strong> ，或者让你求删去哪个数会使 <strong>LIS 的值改变</strong> 。</p>
<p>这里的 LIS 实则是泛指所有转移方程为 $dp[i]=dp[j]+1$ 形式的 $dp$ 。</p>
<p>为什么称其为四点五是因为这一类型的题太少了，但是的的确确是一种新模型。给他一个面子。</p>
<h5 id="我们直接丢出例题："><a href="#我们直接丢出例题：" class="headerlink" title="我们直接丢出例题："></a>我们直接丢出例题：</h5><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2766">最长不下降子序列问题</a></p>
<p>问题一：求一个序列上 LIS 的长度。</p>
<p>问题二：试求一个序列上 LIS 的条数。其中元素不能多次使用。</p>
<p>问题三：试求一个序列上 <strong>不同的</strong> LIS 的条数。其中 $1$ 号和 $N$ 号元素可以多次使用。</p>
<p><del>末 日 三 问</del></p>
<p>在《导弹拦截》那里 <del>打过炮</del> 的人应该会知道，LIS 有一个 $O(n\log n)$ 的优秀做法。</p>
<p>不会也没有关系，因为这道题只能用 $O(n^2)$ 做法。<img src="https://cdn.luogu.com.cn/upload/image_hosting/ma6s1pkz.png" alt=""></p>
<p>求 LIS 的 $n^2$ 做法，状态转移方程如下：</p>
<script type="math/tex; mode=display">dp_{\ i}=\max\{dp_{\ j}\}+1\ (num_i>num_j)</script><p>$dp_i$ 代表：<strong>到 $i$ 位置时的最长上升子序列</strong>。</p>
<p>我们之所以用这种 $n^2$ 方法，是因为我们要知悉每一个位置对应的 $dp$ 值。</p>
<p>一个 $dp$ 值为 $x$ 的位置，肯定能建出一条长为 $x$ 的路径，它是一条以 <strong>这个位置为结束</strong> 的 <strong>上升子序列</strong> 。</p>
<p>而这条路径上的每一条边，必然从 $dp$ 值 <strong>低的位置</strong> 连向 <strong>高的位置</strong> 。</p>
<p>这很好证明。如果从高的位置 $i$ 连向低的位置 $j$ ，有 $dp_i&gt;dp_j$ ：</p>
<p>$i$ 之前必然拖着一条长为 $dp$ 的 <strong>上升序列</strong> 。而 $dp$ 值低顶多只顶得住 $dp_j$ 的长度，却承受不住 $dp_i$ 。（<del>破路</del>）</p>
<p>我们便可以以此，用 $dp$ 值分层，建出一张分层图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/0n61w7i0.png" alt=""></p>
<p>我们推知这条序列的 LIS=3 。</p>
<p>也就是说，数一数这张图上有几条长为 $3$ 的路径，其中一个点只可以使用一次。（<del>唐突数数</del>）</p>
<p>这时，我们可以 <del>转动脑髓，发动眼光</del> ，自己去构造网络流图，使得这一答案能被跑出。</p>
<p>因为是限制了通过 <strong>点</strong> 的流量，所以我们应该用套路四中的 <strong>拆点</strong>。把一个点拆成一个入点和一个出点，两点之间连容量为 $1$ 的边，表示限流为 $1$ 。</p>
<p>因为元素和元素之间没有什么限制，所以其他边容量为 $inf$ 。</p>
<p>而 $dp=1$ 和 $dp=LIS$ 的元素可能有多个，所以需要用到 <strong>超级源汇</strong> 的思想。将 $dp=1$ 的连源， $dp=LIS$ 的连汇。</p>
<p>最后跑最大流出答案。</p>
<p>而第三问，则只需要将 $1$ 号和 $N$ 号元素出入点之间的容量设为 $inf$ 即可。</p>
<p>实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*dinic组件*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next, to;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125; e[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cur[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].next = head[x];</span><br><span class="line">	e[eid].to = y;</span><br><span class="line">	e[eid].val = w;</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[MAX];</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUN(u) for (int i = head[u]; i; i = e[i].next)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">	dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	q.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">RUN</span>(u)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (e[i].val == <span class="number">0</span> || dep[v])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[T])</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(cur, head, <span class="built_in"><span class="keyword">sizeof</span></span>(head));<span class="comment">//这时笔者使用了弧优化</span></span><br><span class="line">    <span class="comment">//可以去学一下</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u == T || !in)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> in;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = cur[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		cur[u] = i;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (e[i].val == <span class="number">0</span> || dep[v] != dep[u] + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(in, e[i].val));</span><br><span class="line"></span><br><span class="line">		e[i].val -= tmp;</span><br><span class="line">		e[i ^ <span class="number">1</span>].val += tmp;</span><br><span class="line">		in -= tmp;</span><br><span class="line">		out += tmp;</span><br><span class="line">		<span class="keyword">if</span> (in == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (out == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dep[u] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> dp[MAX], num[MAX], len = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//num序列上的元素值，len最长上升子序列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (num[j] &lt;= num[i])</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//n方出答案</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		len = <span class="built_in">max</span>(len, dp[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">1</span>)<span class="comment">//特判len=1</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; N &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//即每个元素都是一个LIS</span></span><br><span class="line">        </span><br><span class="line">		<span class="built_in">sort</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + N);</span><br><span class="line">		<span class="keyword">int</span> tot = <span class="built_in">unique</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + N) - num - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//因为第三问要求的是不同的LIS</span></span><br><span class="line">        <span class="comment">//故须去重后输出</span></span><br><span class="line">        </span><br><span class="line">		cout &lt;&lt; tot &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	S = <span class="number">0</span>, T = N * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">/*建各种边*/</span></span><br><span class="line">		<span class="built_in">adde</span>(i, i + N, <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">adde</span>(i + N, i, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (dp[i] == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">adde</span>(S, i, INF);</span><br><span class="line">			<span class="built_in">adde</span>(i, S, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] == len)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">adde</span>(i + N, T, INF);</span><br><span class="line">			<span class="built_in">adde</span>(T, i + N, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= N; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[i] + <span class="number">1</span> == dp[j] &amp;&amp; num[j] &gt;= num[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(i + N, j, <span class="number">1</span>);</span><br><span class="line">				<span class="built_in">adde</span>(j, i + N, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">bfs</span>();</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += <span class="built_in">dfs</span>(S, INF);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;<span class="comment">//出第二问答案</span></span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));<span class="comment">//清空</span></span><br><span class="line">	eid = <span class="number">1</span>;</span><br><span class="line">	S = <span class="number">0</span>, T = N * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*重新建边*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="comment">/*出入点之间*/</span></span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">1</span> || i == N)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">adde</span>(i, i + N, INF);</span><br><span class="line">			<span class="built_in">adde</span>(i + N, i, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">adde</span>(i, i + N, <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">adde</span>(i + N, i, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= N; j++)</span><br><span class="line">		&#123;</span><br><span class="line">        	<span class="comment">/*dp值低的连向高的*/</span></span><br><span class="line">			<span class="keyword">if</span> (dp[i] + <span class="number">1</span> == dp[j] &amp;&amp; num[j] &gt;= num[i])</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">adde</span>(i + N, j, <span class="number">1</span>);</span><br><span class="line">				<span class="built_in">adde</span>(j, i + N, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">   	 <span class="comment">/*源汇连边*/</span></span><br><span class="line">		<span class="keyword">if</span> (dp[i] == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">        	</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">1</span> || i == N)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(S, i, INF);</span><br><span class="line">				<span class="built_in">adde</span>(i, S, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(S, i, <span class="number">1</span>);</span><br><span class="line">				<span class="built_in">adde</span>(i, S, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] == len)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == i || i == N)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(i + N, T, INF);</span><br><span class="line">				<span class="built_in">adde</span>(T, i + N, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(i + N, T, <span class="number">1</span>);</span><br><span class="line">				<span class="built_in">adde</span>(T, i + N, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">bfs</span>();</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += <span class="built_in">dfs</span>(S, INF);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;<span class="comment">//出第三问答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="套路五：最小路径覆盖问题"><a href="#套路五：最小路径覆盖问题" class="headerlink" title="套路五：最小路径覆盖问题"></a>套路五：最小路径覆盖问题</h4><p>有的题目，它给了你一张DAG，要求你用最少的路径去覆盖它上面的每一个点。</p>
<p>听上去有、抽象，看来出题人也是 <del>抽象人</del> 。</p>
<p>我们通过画图来解释这一问题：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/b90eyk77.png" alt=""></p>
<p>这是一张普通的 DAG 。</p>
<p>我们每次选择一条任意长度的路径，并将路径上的所有点染色。</p>
<p>如下是一种方法：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/3lmb71x0.png" alt=""></p>
<p>RT，粉、黄、蓝三条路径使得所有点被染色。这时我们使用的路径数量=3。</p>
<p>然而但凡有一点脑子的人都能看出，这条黄色路径是完全不需要的，我们用2条路径照样可以覆盖，如图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/0rk5db7y.png" alt=""></p>
<p>而最小路径覆盖问题，就是解决“ <strong>找到用最少路径覆盖全图的方案</strong> ”这一问题的。</p>
<p>我们如何用网络流实现这一过程？这就要用到 <strong>最小路径覆盖模型</strong> 力。</p>
<p>先假设你是一个铁憨憨。你把每个点都用一条长度为 $1$ 的路径给覆盖了。</p>
<p>这时来了个 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/user/71491">神仙</a> ，看到你的覆盖方案，非常 $angry$ ，把你代码给删了。</p>
<p>她说你怎么这么蔡，很多点明明可以合并以减少路径数。</p>
<p>你感到非常委屈，说凭什么。</p>
<p>她扔出一个定理：“一张图中，如果一个点只能用在一条路径上， <strong>路径数=点数-点之间匹配数</strong> 。”</p>
<p>“这个很好证明。因为当点之间没有边时，每个点都需要一条路径去覆盖他， <strong>路径数=点数</strong> ；一旦有一条边（x，y）时，相当于能把这两个点合在一起，用 <strong>一条路径</strong> 去覆盖他们俩，所以 <strong>路径数=点数-1</strong> ；以此类推。”</p>
<p>你惊了，“那不就转化成了一道最大匹配了嘛。”</p>
<p>的确，但是这里依然分不出二分图来。我们需要 <del>奇技淫巧</del> 。</p>
<p>把一个点拆成入点和出点，永远是入点向对应的出点连边，就可以保证建出一张二分图来：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/bzhlnt5c.png" alt=""></p>
<p>这是之前那张 DAG 建出来的图。</p>
<p>我们需要的是匹配数，所以图上所有入点和出点之间连的边，容量均为 $1$ ；超级源和超级汇连出的边，容量也均为 $1$ 。</p>
<p>这样跑最大流的答案就是 <strong>最大匹配数的数值</strong> 辣！<img src="https://cdn.luogu.com.cn/upload/image_hosting/pssyi5aw.png" alt=""></p>
<p>所以这就是一道最大匹配题了。</p>
<p>这便是最小路径覆盖的基本算法。</p>
<h5 id="不口嗨了，直接上例题："><a href="#不口嗨了，直接上例题：" class="headerlink" title="不口嗨了，直接上例题："></a>不口嗨了，直接上例题：</h5><p>这时，我们想起了之前提到的一道在讲黑白染色时提到的 <del>不讲武德的</del> 题目：</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2172">[国家集训队]部落战争</a></p>
<p>你以为这是一道黑白染色，只是跳的规则不固定了而已？</p>
<p>那还是大意了呀。</p>
<p>黑白染色题（如方格取数），并没有要求每个点都要被取中。而这里需要。</p>
<p>我们从上往下推进，因为不能回头，所以我们的推进从最顶上一行开始，到最底下一行结束。</p>
<p>而这个推进的过程，要 <strong>覆盖所有的点</strong> 。</p>
<p>这时，便可以用到之前的最小路径覆盖模型了。</p>
<ul>
<li><p>先画 DAG ，点与点之间，<strong>可达即连边</strong>。</p>
</li>
<li><p>再套最小路径覆盖即可。</p>
</li>
</ul>
<p>（实则这两步可以合成一步做）</p>
<p><del>希望国集好自为之，不要搞窝里斗。</del></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*dinic组件*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next, to;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125; e[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cur[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].next = head[x];</span><br><span class="line">	e[eid].to = y;</span><br><span class="line">	e[eid].val = w;</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[MAX];</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUN(u) for (int i = head[u]; i; i = e[i].next)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">	dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	q.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">RUN</span>(u)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (e[i].val == <span class="number">0</span> || dep[v])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dep[T])</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(cur, head, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u == T || !in)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> in;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = cur[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		cur[u] = i;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (e[i].val == <span class="number">0</span> || dep[v] != dep[u] + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(in, e[i].val));</span><br><span class="line"></span><br><span class="line">		e[i].val -= tmp;</span><br><span class="line">		e[i ^ <span class="number">1</span>].val += tmp;</span><br><span class="line">		in -= tmp;</span><br><span class="line">		out += tmp;</span><br><span class="line">		<span class="keyword">if</span> (in == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (out == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dep[u] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, M, R, C;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="comment">//在棋盘上获取结点编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x - <span class="number">1</span>) * M + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Map[<span class="number">57</span>][<span class="number">57</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M &gt;&gt; R &gt;&gt; C;</span><br><span class="line">	S = <span class="number">0</span>, T = N * M * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">char</span> c;</span><br><span class="line">			cin &gt;&gt; c;</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				tot++;<span class="comment">//tot记录需要覆盖的点的个数</span></span><br><span class="line">			&#125;</span><br><span class="line">			Map[i][j] = (c == <span class="string">&#x27;.&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">adde</span>(S, <span class="built_in">idx</span>(i, j), <span class="number">1</span>);<span class="comment">//超级源连所有入点</span></span><br><span class="line">			<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j), S, <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j) + N * M, T, <span class="number">1</span>);<span class="comment">//超级汇连所有出点</span></span><br><span class="line">			<span class="built_in">adde</span>(T, <span class="built_in">idx</span>(i, j) + N * M, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> dis[<span class="number">5</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, R, C, R, -C, C, R, C, -R&#125;;</span><br><span class="line">	<span class="comment">//跳跃规则    </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Map[i][j] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> ii = i + dis[k][<span class="number">0</span>], jj = j + dis[k][<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span> (ii &lt;= <span class="number">0</span> || ii &gt; N || jj &lt;= <span class="number">0</span> || jj &gt; M || Map[ii][jj] == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j), <span class="built_in">idx</span>(ii, jj) + N * M, INF);</span><br><span class="line">				<span class="built_in">adde</span>(<span class="built_in">idx</span>(ii, jj) + N * M, <span class="built_in">idx</span>(i, j), <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//可达即连边</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">bfs</span>();</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += <span class="built_in">dfs</span>(S, INF);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; tot - ans &lt;&lt; endl;<span class="comment">//最少路径数=总点数-匹配点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EX-套路五：其他有趣（？）的最小路径覆盖问题泛讲："><a href="#EX-套路五：其他有趣（？）的最小路径覆盖问题泛讲：" class="headerlink" title="EX-套路五：其他有趣（？）的最小路径覆盖问题泛讲："></a>EX-套路五：其他有趣（？）的最小路径覆盖问题泛讲：</h4><p>天底下哪有裸的网络流，从来都是老阴比居多。</p>
<p>这一现象在“最小路径覆盖问题”上得到了充分的体现。</p>
<p>因为最小路径覆盖的板子局限性太高了，所以他的 <strong>变体</strong> 也就特别的多。</p>
<p>这就和 <del>“因为NEKOPARA官方给时雨的戏份太少，导致时雨的本子特别多”</del>  是一个道理。</p>
<p>我们挑几个范例，来剖析一下出题人的良（sang）苦（xin）用（bing）心（kuang）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2765">魔术球问题</a></li>
</ul>
<p>你的正解不是搜索，ko no 网络流 da ！</p>
<p>首先，我们制定一个总体的计划，逐个地放小球，直到放不下了为止。这时就是答案。</p>
<p>其次，我们想想这是怎么套上最小路径覆盖的。我们把每个球看作一个点，把两个 <strong>相加之和为完全平方数</strong> 的小球，所对应的点之间连边。</p>
<p>这也代表着我们以数 $a$ 为某柱子的顶端，我们就 <strong>可以</strong> 去转移到下一个与 $a$  <strong>有连边</strong> 的数 $b$ 。</p>
<p>建出一张图来就像这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fu63025z.png" alt=""></p>
<p>当我们把 $1$ 放在一个柱子的顶端，在他的上面，我们可以去放 $3$ ，也可以去放 $8$ 。</p>
<p>在图上，相当于我们在 $1$ 这个位置，可以走到 $3$ 也可以走到 $8$ 。</p>
<p>就这样走着走着最终会走出一条路径，这条路径上的每两个邻点之间都 <strong>有边相接</strong> ，意味着相加为完全平方数。</p>
<p>这样的一条路径正好对应了一根柱子。</p>
<p>那做法就很显然了，一个一个加小球，连边，当加某一个小球时，跑出的最小路径覆盖条数 <strong>超过了柱子数</strong> ，那这就是答案。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U141427"><del>青春猪头tyy的下半身不会梦见操场的柱子</del></a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5769">[JSOI2016]飞机调度</a></li>
</ul>
<p>网络瘤少有的黑题，其实还是好打的。</p>
<p>是什么让我们想到这是一道 <strong>“最小路径覆盖问题”</strong> ？</p>
<p><del>题解</del>（闭嘴）</p>
<p>题目中提到“可以增开任意架飞机”，而求的是“最少使用的飞机数”，一个飞机会经过许多点……这使我们想到“最小路径覆盖”。</p>
<p>“最小路径覆盖”需要有 DAG ，否则就是白给。</p>
<p>谁设为点，是机场吗，呐？</p>
<p>一个机场可能多次接收航班，多次送出航班，也就是说一个机场可能会经过多次，这违背了我们DAG的初心。</p>
<p>那到底什么是 <strong>一次性</strong> 的。</p>
<p>在这道题里，只有航班是一次性的了，将其设为点。</p>
<p>谁设为边，点与点之间的转移曰边，我们这里定义：同一架飞机 <strong>飞完一趟航班以后飞另一趟</strong> ，这两趟航班之间就可以连边。</p>
<p>在什么条件下，一架飞机可以飞完一趟以后飞另一趟？ <img src="https://cdn.luogu.com.cn/upload/image_hosting/2ztswi4d.png" alt=""></p>
<p>在前一次飞完以后，能够在 <strong>下一趟开点</strong> 之前，赶到下一趟的 <strong>出发站</strong> 。我们就可以在这两趟航班之间连上边。</p>
<p>而这个判断里面，每一个需要的值都是可求的。</p>
<p>那么有人又要问了：可是题目并没有给出从一个机场赶到另一个机场所需的时间啊！</p>
<p>既然题目给了你这么多航班信息，你就不会用 $floyed$  <strong>传递一下闭包</strong> 吗。<img src="https://cdn.luogu.com.cn/upload/image_hosting/zow878de.png" alt=""></p>
<p>至此此题就转化成一道最小路径覆盖问题力。</p>
<hr>
<h4 id="套路六：虚点的构建："><a href="#套路六：虚点的构建：" class="headerlink" title="套路六：虚点的构建："></a>套路六：虚点的构建：</h4><p>这并不构成一种模型，但是这类型的题挺 多 的，所以单独开出来讲。</p>
<p>所谓虚点者，就是这并不代表某一个元素，而是代表一种 <strong>限制条件</strong> 或者 <strong>额外加成</strong> 。</p>
<p>比如我们说，如果有两个物品 $a$ 和 $b$ ，每个物品有两种状态 $1$ 和 $2$ ，每个状态有不同的价值。</p>
<p>同时，如果我们同时选了 $a1$ 和 $b1$ ，就可以额外获得值为 $c1$ 的价值；如果我们同时选了 $a2$ 和 $b2$ ，就可以额外获得值为 $c2$ 的价值。</p>
<p>首先我们需要创建一个虚点，代表 $c1$ 。</p>
<p>这时，因为我们有 <strong>“你可以选状态1，但你就选不了状态2了，这一切，值得吗”</strong> 。</p>
<p>所以我们应该上最小割！将所有状态 $1$ 连向源，所有状态 $2$ 连向汇！</p>
<p>其次，如果我们选择不割 $a1$ 和 $b1$ ，就能 <strong>保留</strong> $c1$ 。</p>
<p>所以 $c1$ 与 “ $a1$ 和 $b1$ ” 不应站在割边的对立面上。而是当 <strong>能保留a1,b1的条件满足时，一样可以保留c1</strong> 。</p>
<p><del>胡乱</del> 思考得知， $c1$ 应该是从源出来而流向 $a1,b1$ 的。</p>
<p>那建出全图就是这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4nc0stxw.png" alt=""></p>
<p><del>还挺好看。</del></p>
<p>手模几种情况即可验证这张图。</p>
<p>之后就是跑一个最小割的事。</p>
<p>可以看出，建立虚点的套路适用于 “<del>集齐X个干员，组建幻神阵容，获得羁绊 buff</del>” 的隔膜行为。<img src="https://cdn.luogu.com.cn/upload/image_hosting/i1qlnrf1.png" alt=""></p>
<h5 id="下面来康例题："><a href="#下面来康例题：" class="headerlink" title="下面来康例题："></a>下面来康例题：</h5><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1646">[国家集训队]happiness</a></p>
<p>为甚么又是国集……</p>
<p>这道题的限制条件有亿点多，但是好在数据范围极小。</p>
<p>本着神仙 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/user/56384">shadowice1984</a> “<del>大了三分，小网络流；不小不大，斜率优化</del>” 的箴言。我们尝试建图跑。</p>
<p>对于任意两个相邻的人，他们同选某一门会有额外 $buff$ ，这说明我们要建关于 $buff$ 的虚点。</p>
<p>之后的事就很简单了，对于每一种 $buff$ 都建虚点，最后跑最小割即可。</p>
<p>图过于气 势 恢 宏，这里就不放了。</p>
<p>代码放一下：</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LAR = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*网络流板子*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next, to;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125; e[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cur[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].next = head[x];</span><br><span class="line">	e[eid].to = y;</span><br><span class="line">	e[eid].val = w;</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[MAX];</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUN(u) for (int i = head[u]; i; i = e[i].next)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">	dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	q.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">RUN</span>(u)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (e[i].val == <span class="number">0</span> || dep[v])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(cur, head, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">	<span class="keyword">return</span> dep[T] != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u == T || !in)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> in;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = cur[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		cur[u] = i;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (dep[v] != dep[u] + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(in, e[i].val));</span><br><span class="line">		<span class="keyword">if</span> (!tmp)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		e[i].val -= tmp;</span><br><span class="line">		e[i ^ <span class="number">1</span>].val += tmp;</span><br><span class="line">		in -= tmp;</span><br><span class="line">		out += tmp;</span><br><span class="line">		<span class="keyword">if</span> (in == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (out == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dep[u] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*几个数组分别对应该位置选文、选理、相邻都选文、相邻都选理*/</span></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">107</span>][<span class="number">107</span>];</span><br><span class="line"><span class="keyword">int</span> B[<span class="number">107</span>][<span class="number">107</span>];</span><br><span class="line"><span class="keyword">int</span> C[<span class="number">107</span>][<span class="number">107</span>];</span><br><span class="line"><span class="keyword">int</span> D[<span class="number">107</span>][<span class="number">107</span>];</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="comment">//取标号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x - <span class="number">1</span>) * M + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	S = <span class="number">0</span>, T = <span class="number">5</span> * N * M + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; A[i][j];</span><br><span class="line">			sum += A[i][j];</span><br><span class="line">			<span class="built_in">adde</span>(S, <span class="built_in">idx</span>(i, j), A[i][j]);</span><br><span class="line">			<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j), S, <span class="number">0</span>);<span class="comment">//文连源</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; B[i][j];</span><br><span class="line">			sum += B[i][j];</span><br><span class="line">			<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j), T, B[i][j]);</span><br><span class="line">			<span class="built_in">adde</span>(T, <span class="built_in">idx</span>(i, j), <span class="number">0</span>);<span class="comment">//理连汇</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; C[i][j];</span><br><span class="line">			sum += C[i][j];</span><br><span class="line">			<span class="keyword">int</span> u = <span class="number">2</span> * N * M + <span class="built_in">idx</span>(i, j);<span class="comment">//虚点标号</span></span><br><span class="line">            </span><br><span class="line">			<span class="built_in">adde</span>(S, u, C[i][j]);<span class="comment">//价值</span></span><br><span class="line">			<span class="built_in">adde</span>(u, S, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">			<span class="built_in">adde</span>(u, <span class="built_in">idx</span>(i, j), INF);<span class="comment">//当然他自己也要选文</span></span><br><span class="line">			<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j), u, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*虚点连向四个方向的点*/</span></span><br><span class="line">			<span class="keyword">if</span> (j - <span class="number">1</span> &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(u, <span class="built_in">idx</span>(i, j - <span class="number">1</span>), INF);</span><br><span class="line">				<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j - <span class="number">1</span>), u, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (j + <span class="number">1</span> &lt;= M)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(u, <span class="built_in">idx</span>(i, j + <span class="number">1</span>), INF);</span><br><span class="line">				<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j + <span class="number">1</span>), u, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i - <span class="number">1</span> &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(u, <span class="built_in">idx</span>(i - <span class="number">1</span>, j), INF);</span><br><span class="line">				<span class="built_in">adde</span>(<span class="built_in">idx</span>(i - <span class="number">1</span>, j), u, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i + <span class="number">1</span> &lt;= N)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(u, <span class="built_in">idx</span>(i + <span class="number">1</span>, j), INF);</span><br><span class="line">				<span class="built_in">adde</span>(<span class="built_in">idx</span>(i + <span class="number">1</span>, j), u, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; D[i][j];</span><br><span class="line">			sum += D[i][j];</span><br><span class="line">			<span class="keyword">int</span> u = <span class="number">4</span> * N * M + <span class="built_in">idx</span>(i, j);<span class="comment">//虚点标号</span></span><br><span class="line">            </span><br><span class="line">			<span class="built_in">adde</span>(u, T, D[i][j]);<span class="comment">//价值</span></span><br><span class="line">			<span class="built_in">adde</span>(T, u, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">			<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j), u, INF);<span class="comment">//当然他自己也要选理</span></span><br><span class="line">			<span class="built_in">adde</span>(u, <span class="built_in">idx</span>(i, j), <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*向四个方向连边*/</span></span><br><span class="line">			<span class="keyword">if</span> (j - <span class="number">1</span> &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j - <span class="number">1</span>), u, INF);</span><br><span class="line">				<span class="built_in">adde</span>(u, <span class="built_in">idx</span>(i, j - <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (j + <span class="number">1</span> &lt;= M)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(<span class="built_in">idx</span>(i, j + <span class="number">1</span>), u, INF);</span><br><span class="line">				<span class="built_in">adde</span>(u, <span class="built_in">idx</span>(i, j + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i - <span class="number">1</span> &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(<span class="built_in">idx</span>(i - <span class="number">1</span>, j), u, INF);</span><br><span class="line">				<span class="built_in">adde</span>(u, <span class="built_in">idx</span>(i - <span class="number">1</span>, j), <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i + <span class="number">1</span> &lt;= N)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">adde</span>(<span class="built_in">idx</span>(i + <span class="number">1</span>, j), u, INF);</span><br><span class="line">				<span class="built_in">adde</span>(u, <span class="built_in">idx</span>(i + <span class="number">1</span>, j), <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		ans += <span class="built_in">dfs</span>(S, INF);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; sum - ans &lt;&lt; endl;<span class="comment">//总价值-最小割</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><h4 id="套路七：二分与枚举："><a href="#套路七：二分与枚举：" class="headerlink" title="套路七：二分与枚举："></a>套路七：二分与枚举：</h4><p>有的题目，他条件一点都不 <strong>给</strong> ，或者他 <strong>给</strong> 得不够多。</p>
<p>如果我们用传统的套路，我们会寸步难行。</p>
<p>这时，我们如果尝试用 <strong>枚举/二分</strong>  的做法，相当于自己凭空创造了一个条件，这样我们就可以完成一些 <del>板子的套用</del> 模型的构造。</p>
<p>我们可以根据这个条件来建图跑，如果跑出的答案不满足要求，则 <strong>调整图的形态</strong> 再跑。</p>
<p>我们有时只需要改动一些边的参数，但像我这种蒟蒻只会大力重新建图。（<del>这就是我常数特别大的原因之一</del>）</p>
<p>_有关更优秀地改动边，这里埋下一个伏笔。_</p>
<p>您是否还记得之前的一道《魔术球问题》，那题中，我们不断放新球的过程，实际上就属于套路七中的 <strong>枚举</strong> 环节。</p>
<p>这一套路思想就这，重在运用。</p>
<h5 id="劲爆例题"><a href="#劲爆例题" class="headerlink" title="劲爆例题"></a>劲爆例题</h5><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3425">[POI2005]KOS-Dicing</a></p>
<p>这题说要让“<strong>最多的最少</strong>”，想到了二分。</p>
<p>赢最多的人赢多少场，这是有边界的。</p>
<p>我们就可以随手二分赢最多的人的胜场。</p>
<p>那图呢？<img src="https://cdn.luogu.com.cn/upload/image_hosting/hu55cdoh.png" alt=""></p>
<p>我们看到，一场比赛只能有一个 <strong>人赢</strong> 。（雾）</p>
<p>所以表示比赛的点向参与的两者各连 <strong>流量为 1</strong> 的边。源点向所有比赛连 <strong>流量为 1</strong> 的边。</p>
<p>而我们二分到一个人最多赢 $mid$ 场。也就是一个人连向汇点最大为 $mid$ 。</p>
<p>跑出最大流如果 $\geq$ 比赛数，说明是 <strong>可行的</strong> 。尝试用更小的 $mid$ 。</p>
<p>最终会二分出一个答案。</p>
<p>输出方案就看比赛连向谁的那条边是满流即可，谁是满流谁是人赢.</p>
<h2 id="-4"><a href="#-4" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*dinic组件*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next, to;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">&#125; e[MAX &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX], eid = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cur[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[++eid].next = head[x];</span><br><span class="line">	e[eid].to = y;</span><br><span class="line">	e[eid].val = w;</span><br><span class="line">	head[x] = eid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[MAX];</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUN(u) for (int i = head[u]; i; i = e[i].next)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dep));</span><br><span class="line">	dep[S] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	q.<span class="built_in">push</span>(S);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">RUN</span>(u)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span> (e[i].val == <span class="number">0</span> || dep[v])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(cur, head, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">	<span class="keyword">return</span> dep[T] != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u == T || !in)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> in;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = cur[u]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		cur[u] = i;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (dep[v] != dep[u] + <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(in, e[i].val));</span><br><span class="line">		<span class="keyword">if</span> (!tmp)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		e[i].val -= tmp;</span><br><span class="line">		e[i ^ <span class="number">1</span>].val += tmp;</span><br><span class="line">		in -= tmp;</span><br><span class="line">		out += tmp;</span><br><span class="line">		<span class="keyword">if</span> (in == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (out == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dep[u] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> a[MAX], b[MAX];</span><br><span class="line"><span class="keyword">int</span> akioi[MAX], tot = <span class="number">0</span>;<span class="comment">//akioi 数组记录（表示 “这场比赛流向参赛者” 的边）的编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*二分函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));<span class="comment">//暴力清空</span></span><br><span class="line">    </span><br><span class="line">	eid = <span class="number">1</span>;</span><br><span class="line">	S = <span class="number">0</span>, T = <span class="number">20000</span> + N + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*建边*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">adde</span>(S, i, <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">adde</span>(i, S, <span class="number">0</span>);<span class="comment">//源连向比赛</span></span><br><span class="line">		<span class="built_in">adde</span>(i, a[i] + <span class="number">20000</span>, <span class="number">1</span>);</span><br><span class="line">		akioi[i] = eid;</span><br><span class="line">        <span class="comment">//记录下这条边的编号，以后输出方案要用</span></span><br><span class="line">        </span><br><span class="line">		<span class="built_in">adde</span>(a[i] + <span class="number">20000</span>, i, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">adde</span>(i, b[i] + <span class="number">20000</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">adde</span>(b[i] + <span class="number">20000</span>, i, <span class="number">0</span>);<span class="comment">//比赛连向参赛者</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">adde</span>(i + <span class="number">20000</span>, T, x);</span><br><span class="line">		<span class="built_in">adde</span>(T, i + <span class="number">20000</span>, <span class="number">0</span>);<span class="comment">//参赛者连向汇</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		ans += <span class="built_in">dfs</span>(S, INF);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans &gt;= M)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*二分*/</span></span><br><span class="line">	<span class="keyword">int</span> l = M / N, r = M, ans = M;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">judge</span>(mid))</span><br><span class="line">		&#123;</span><br><span class="line">			r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以这个数为答案再跑一遍，生成方案</span></span><br><span class="line">	<span class="built_in">judge</span>(l);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (e[<span class="number">6</span> * (i - <span class="number">1</span>) + <span class="number">4</span>].val == <span class="number">0</span>)<span class="comment">//查询其是否满流</span></span><br><span class="line">        <span class="comment">//（若流向一个人的边的容量变成了0，则它满流）</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h4 id="套路INF：其他不常见技巧"><a href="#套路INF：其他不常见技巧" class="headerlink" title="套路INF：其他不常见技巧"></a>套路INF：其他不常见技巧</h4><ul>
<li><strong>拓扑去环</strong>：</li>
</ul>
<p>试想如果我们建出来的图中有环，跑网络流会得到什么结果。</p>
<p>可能是 $RE$ ，可能是 $TLE$ ，可能是 $WA$ ，总之跑不出正确答案。</p>
<p>有的题目中，环是可以被直接忽略的。这时我们就可以先跑 <strong>拓扑排序</strong> ，把环找出来，在之后建模时直接忽略即可。</p>
<p>比如下面这道题：</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2805">[NOI2009]植物大战僵尸</a></p>
<p>首先，这题基础建模思路就很难想到。（毒瘤题实锤）</p>
<p>对题目中的题意一通抽丝剥茧，我们发现，一个植物要能被吃，需要满足这两个前置条件。（看图）</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/h5t8vgit.png" alt=""></p>
<ul>
<li><p>它右边的都被吃完了（参考这里的大嘴花在坚果墙左边导致不能被吃）。</p>
</li>
<li><p>能攻击到这一位置的植物都被吃完了 （参考这里的坚果墙的位置被大嘴花攻击导致不能被吃</p>
</li>
</ul>
<p>停，你刚刚说了 “<strong>前置</strong>” 是吧。</p>
<p>然后 <strong>最大权闭合子图</strong> 的模型不就呼之欲出了？</p>
<ol>
<li><p>植物 $i$ 的价值设为 $val_i$ ，正权连源，表示收益，负权连汇，表示花费。</p>
</li>
<li><p>如果一个植物 $j$ 保护着 $i$ ， $i$ 向 $j$ 连边 （这里包含了 <strong>j 在 i 右侧</strong> 和 <strong>j 攻击到 i 的位置</strong>  两种情况）</p>
</li>
</ol>
<p>答案就是跑出的总的最大收益。</p>
<p>然后，我们会发现一个残酷的事实，如果你是僵尸，大嘴花和坚果墙你一个都吃不到。（惨）</p>
<p>他们互相保护，在我们建出的图上就形成了一个环。如果我们直接跑会爆炸。</p>
<p>这时我们就需要 <strong>拓扑去环</strong> 了。</p>
<p>在建网络流模型之前，我们需要反向建一张图，能被遍历到的结点证明它不在环上，我们用这种点再来建我们用来跑网络流的图。</p>
<p>之后跑最大权闭合子图即可。</p>
<ul>
<li><strong>退流</strong>：</li>
</ul>
<p>_伏笔消除_</p>
<p>如果我们要在一张跑完网络流的图上，稍作删边，再跑下一次网络流的话，我们可能要暴力重建。</p>
<p>但是其实这并不需要这么高的复杂度， <strong>退流</strong> 就是一种高效解决删边重跑的方法。</p>
<p>笔者突然对自己的认知产生了迷惑，先咕。</p>
<hr>
<p>那网络流部分就告一段落辣。</p>
<hr>
<h3 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h3><p>sto $\color{black}{\texttt{M}\color{red}{\texttt{iFaFaOvO}}}$ orz</p>
<p>杜教筛是一种高端筛法，用以快速处理积性函数的前缀和。</p>
<p>以前 $\color{purple}{\texttt{给}}$ 指导讲过这一高端科技，但是那时候的我连数论分块都没搞清楚，更别说杜教筛了。</p>
<p>昨天入的坑，今天来整理一下 $QvQ$ 。</p>
<hr>
<h4 id="原理？"><a href="#原理？" class="headerlink" title="原理？"></a>原理？</h4><p>假设我们要来筛一个函数 $f$ 。</p>
<p>我们设另一个积性函数 $g$ ，然后把他们俩 <strong>卷</strong> 起来，得到一个 $h$ 。</p>
<p>也就是 $f*g=h$ 。</p>
<p>再设一个 $sumf$ 表示 $g$ 的前缀和。</p>
<p>以上是杜教筛的一些弹药。</p>
<p>关于 $h$ 的前缀和，展开做钬钊氪镭 <strong>卷</strong> 积的形式有：</p>
<script type="math/tex; mode=display">\sum^{n}_{i}h(i)=\sum^{n}_{i}\sum_{d|n} g(d)f(\frac{n}{d})</script><script type="math/tex; mode=display">\Leftrightarrow \sum^{n}_{i}h(i)={\color{red}{ \sum_{d}^{n}} }  g(d)\sum^{\color{red}{\lfloor\frac{n}{d}\rfloor}}_{i} f(i)\quad\texttt{提出并枚举d}</script><script type="math/tex; mode=display">\Leftrightarrow \sum^{n}_{i}h(i)={\color{red}{ \sum_{d}^{n}} }  g(d){\color{royalblue}{sumf(\lfloor\frac{n}{d}\rfloor)}}\quad\texttt{将后半部分预处理}</script><script type="math/tex; mode=display">\Leftrightarrow \sum^{n}_{i}h(i)={\color{green}{sumf(n)\cdot g(1)}}+{ \sum_{d\color{green}{=2}}^{n} }  g(d){\color{royalblue}{sumf(\lfloor\frac{n}{d}\rfloor)}}\quad\texttt{提出d=1}</script><script type="math/tex; mode=display">\Leftrightarrow {\color{green}{sumf(n)\cdot g(1)}}={ \sum^{n}_{i}h(i)-\sum_{d\color{green}{=2}}^{n} }  g(d){\color{royalblue}{sumf(\lfloor\frac{n}{d}\rfloor)}}\quad\texttt{一通移项}</script><p>当前的这个式子启发我们，当我们易求 $h$ 的前缀和时，只需获得一个 $sumf(\lfloor\frac{n}{d}\rfloor)$ ，就能光速整除分块推知 $sumf(n)$ 。</p>
<hr>
<h4 id="数论函数的选择"><a href="#数论函数的选择" class="headerlink" title="数论函数的选择"></a>数论函数的选择</h4><p><del>随缘乱凑（不是）</del></p>
<p>回归算法本身，我们需要的 $g$ ，要求是和 $f$ <strong>卷</strong> 起来以后得到一个易求前缀和的 $h$ 。</p>
<p>所以我们需要通晓一些互 <strong>卷</strong> 关系：</p>
<p>$\mu*1=\epsilon\quad$这个很simple吧，$\mu$ 的一条性质</p>
<p>$\varphi*1=id\quad$ 这个看上去也很simple，$\texttt{\color{black}{R}\color{red}{ui_R}}$神写过一篇<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/RUI-R/ti-xie-u131347-post">文章</a>证过。</p>
<p>$\mu<em>id=\varphi\quad$ 上一条柿子佐佑同 <em>*卷</em></em> $\mu$ 即可</p>
<p>$f(i)=\sum_{i}^{n}(i\cdot\varphi(i)),f<em>id=n^2\quad$ <strong>卷</strong> 积拆开来发现会把$f$ 里的 $i$ 消掉得 $\sum_{d|n}n\cdot\varphi(d)$，然后套 $\varphi</em>1=id$</p>
<p>$f(i)=\sum^n_i(i^k\cdot\varphi(i)),f*id=n^{k+1}\quad$ 上一个柿子的一个推论</p>
<hr>
<h4 id="劲爆例题-1"><a href="#劲爆例题-1" class="headerlink" title="劲爆例题"></a>劲爆例题</h4><ul>
<li><strong>【模板】杜教筛（Sum）</strong></li>
</ul>
<p>首当其 <strong>冲</strong> 的必然是模板。</p>
<p>题目要求 $\mu$ 和 $\varphi$ 的前缀和，我们分别来思♂尻一番。</p>
<p>思♂尻用什么东西来 <strong>卷</strong> $\mu$ ，要求和 $\mu$ <strong>卷</strong> 完以后要得到一个 <strong>易于计算前缀和</strong> 的氡氡。</p>
<p>通过 <del>翻博客</del> 慎重考虑后，我们选择用 $1$ 去 <strong>卷</strong> 它，因为 $\mu*1=\epsilon$ ，而 $\epsilon$ 的前缀和必然是 1。</p>
<p>所以瑇入 $g=1,h=\epsilon$ 我们有：</p>
<script type="math/tex; mode=display">{sum\mu(n)\cdot 1}={ \sum^{n}_{i}\epsilon(i)-\sum_{d=2}^{n} }   sum\mu(\lfloor\frac{n}{d}\rfloor)</script><p>这样我们就解决了 $\mu$ 。</p>
<p>那 $\varphi$ 呐？</p>
<p>其实也很套路，因为 $\varphi*1=id$ ，而 $id$ 的前缀和，高斯哥哥已经帮我们推出公式了，是 $n\cdot(n+1)\div2$ 。</p>
<p>所以瑇入 $g=1,h=id$ 我们有：</p>
<script type="math/tex; mode=display">{sum\varphi(n)\cdot 1}={ \sum^{n}_{i}i-\sum_{d=2}^{n} } sum\varphi(\lfloor\frac{n}{d}\rfloor)</script><p>下面是瑇码，具体实现细节在注释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">6e6</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;<span class="comment">//质数表（STL严重瘾君子）</span></span><br><span class="line"><span class="keyword">int</span> mu[MAX];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> phi[MAX];</span><br><span class="line"><span class="keyword">bool</span> flag[MAX];</span><br><span class="line"><span class="keyword">int</span> summ[MAX];<span class="comment">//mu前缀和</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sump[MAX];<span class="comment">//phi前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span><span class="comment">//先线性预处理一部分的 phi 和 mu</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">6e6</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!flag[i])</span><br><span class="line">		&#123;</span><br><span class="line">			phi[i] = i - <span class="number">1</span>;</span><br><span class="line">			mu[i] = <span class="number">-1</span>;</span><br><span class="line">			v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> M = v.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M &amp;&amp; i * v[j] &lt;= <span class="number">6e6</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			flag[i * v[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % v[j] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				phi[i * v[j]] = <span class="number">1LL</span> * phi[i] * v[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mu[i * v[j]] = -mu[i];</span><br><span class="line">			phi[i * v[j]] = <span class="number">1LL</span> * phi[i] * phi[v[j]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6e6</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		summ[i] = summ[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">		sump[i] = sump[i - <span class="number">1</span>] + <span class="number">1LL</span> * phi[i];<span class="comment">//求出一部分前缀和</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">unordered_map&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; m2;<span class="comment">//这两个map用来保存一些已经求好的前缀和（类似记忆化）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DJSmu</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= <span class="number">6e6</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> summ[x];<span class="comment">//小于6e6的预处理过了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m1[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m1[x];<span class="comment">//已经求过的可以记忆化</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">1</span>;<span class="comment">//epsilon前缀和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span><span class="comment">/*从2开始*/</span>, j; i &gt;= <span class="number">0</span> &amp;&amp; i &lt;= x; i = j + <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		j = x / (x / i);</span><br><span class="line">		ans -= (j - i + <span class="number">1</span>) * <span class="built_in">DJSmu</span>(x / i);<span class="comment">//每次数论分块，减去mu的前缀和，而这个前缀和可以递归搞一搞</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m1[x] = ans;<span class="comment">//记忆化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">DJSphi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= <span class="number">6e6</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> sump[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m2[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m2[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = (x) * (x + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//id前缀和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>, j; i &lt;= x; i = j + <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		j = x / (x / i);</span><br><span class="line">		ans -= (j - i + <span class="number">1</span>) * <span class="built_in">DJSphi</span>(x / i);<span class="comment">//减去phi前缀和</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m2[x] = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="built_in">pre</span>();</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">DJSphi</span>(x) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">DJSmu</span>(x) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_PS：小心爆精（不然就像我一样的下场）_</p>
<p><em>　<em>*象棋与马</em></em></p>
<p><del>题面要素溢出。</del></p>
<p>不难发现，如果一种跳跃规则是可达所有点的，那么它唯一的要求就是有能力达到 <strong>相邻格</strong>，如 $(0,0)$ 达到 $(0,1)$  。</p>
<p>我们意识到，这一步骤其实相当于能否从 $(0,0)$ ，向各个方向<del>瞎jb</del>跳一跳，最后达到 $(0,1)$ 。</p>
<p>设我们一步能跳 $(x,y)$ ，那么 <strong>本质不同</strong> （唐突本质不同）的行走方案有四种：</p>
<script type="math/tex; mode=display">(x,y) (y,x) (-x,y) (−y,x)</script><p>（在纵轴上走负方向其实可以看作走<strong>负数次</strong>正方向）</p>
<p>那么我们有：</p>
<script type="math/tex; mode=display">\begin{cases}ax+by-cx-dy=0\\ay+bx+cy+dx=1\end{cases}</script><p>也就是说我们瞎跳过程中，有 $a$ 次 $(x,y)$ 的跳跃， $b$ 次 $(y,x)$ 的跳跃， $c,d$ 同理。</p>
<p>开始 $\mathbf{dark}$ 力合并两个柿子，提出 $x,y$ 来。</p>
<script type="math/tex; mode=display">x(a+b-c+d)+y(a+b+c-d)=1</script><p>设 $a+b=A,c-d=B$ ，转化式子</p>
<script type="math/tex; mode=display">x(A-B)+y(A+B)=1</script><p>格物致知这个柿子，我们意识到 $x,y$ 一定得 <strong>互质</strong> （一旦二者有非1的公约数，则结果必然 <strong>也有</strong> 这个公约数）。</p>
<p>此外，二者必须 <strong>奇偶性互异</strong> ，否则结果 <strong>必然为偶</strong> 。</p>
<p>因此，二者必然一奇一偶。</p>
<p>设此时答案是 $f(x)$ ，先记着，因为我们限定了 $x$ 的奇偶性，相当于砍掉了一半的答案，所以最后答案 $ans(x)=2\cdot f(x)$。</p>
<p>抓～紧～时～间～容～斥～</p>
<script type="math/tex; mode=display">f(x)=\sum^{x}_{i}\sum^{y}_{j}[i\perp j,i j \texttt{奇偶性互异}]</script><script type="math/tex; mode=display">=\sum^{x}_{i}\sum^{i}_{j}[i\perp j,i\texttt{为偶}\texttt{（因为两者互质所以j为偶甚至不用写）}]+{\sum^{x}_{i}\sum^{i}_{j}[i\perp j,i\texttt{为奇},j \texttt{为偶}]}</script><p>他欧拉反 <strong>演</strong> 起来了：</p>
<script type="math/tex; mode=display">f(x)=\sum^{x}_{i}\varphi(i)[i\texttt{为偶}]+\sum^{x}_{i}\frac{\varphi(i)}{2}[i\texttt{为奇}]</script><script type="math/tex; mode=display">ans(x)=\sum^{x}_{i}2\varphi(i)[i\texttt{为偶}]+\varphi(i)[i\texttt{为奇}]</script><p>因此，我们收获了一个看上去很彳亍的式子，但这还不够，$x\leq10^{11}$。</p>
<p>提出一个 $\varphi(i)$ 来：</p>
<script type="math/tex; mode=display">ans(x)=\sum^{x}_{i}\varphi(i)[i\texttt{为偶}]+\varphi(i)</script><script type="math/tex; mode=display">=\sum^{x}_{i}\varphi(i)[i\texttt{为偶}]+\sum^{x}_{i}\varphi(i)</script><script type="math/tex; mode=display">=ans(\frac{x}{2})+\sum^{x}_{i}\varphi(i)</script><p>后半段可以 <strong>杜教筛</strong> ，前半段 <strong>递归求解</strong> 即可。</p>
<p>按 $\color{purple}{\texttt{给指导}}$ 的话说，这种“自递归函数”是未来数论出题的热点。</p>
<p>（这并不影响数论毒瘤爪巴）</p>
<p>瑇码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">2e7</span> + <span class="number">7</span>;</span><br><span class="line">ll phi[MAX];</span><br><span class="line">ll sum[MAX];</span><br><span class="line"><span class="keyword">bool</span> flag[MAX];</span><br><span class="line">vector&lt;ll&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= <span class="number">2e7</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			phi[i] = i - <span class="number">1</span>;</span><br><span class="line">			v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		ll M = v.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; M &amp;&amp; v[j] * i &lt;= <span class="number">2e7</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			flag[i * v[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % v[j] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				phi[i * v[j]] = phi[i] * v[j];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			phi[i * v[j]] = phi[i] * phi[v[j]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">2e7</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum[i] = (sum[i - <span class="number">1</span>] + phi[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;ll, ull&gt; m;</span><br><span class="line"><span class="function">ull <span class="title">DJS</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= <span class="number">2e7</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> sum[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m.<span class="built_in">count</span>(x))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m[x];</span><br><span class="line">	&#125;</span><br><span class="line">	ull ans = (__int128)(x &amp; <span class="number">1LL</span> ? ((x + <span class="number">1</span>) / <span class="number">2LL</span> * x) : (x / <span class="number">2LL</span> * (x + <span class="number">1</span>)));</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">2</span>, j; i &lt;= x; i = j + <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		j = x / (x / i);</span><br><span class="line">		ans -= <span class="number">1LL</span> * (<span class="built_in">DJS</span>(x / i) * (<span class="number">1LL</span> * j - <span class="number">1LL</span> * i + <span class="number">1LL</span> * <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m[x] = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">solve</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">solve</span>(x / <span class="number">2</span>) + <span class="built_in">DJS</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="built_in">pre</span>();</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		ull a;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">solve</span>(a) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="咕咕咕！"><a href="#咕咕咕！" class="headerlink" title="咕咕咕！"></a>咕咕咕！</h3>
            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2021年08月03日 10:16</p>
        <p>原始链接： <a class="post-url" href="/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5/" title="紫题算法学习实况">https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5/</a></p>
        <footer>
            <a href="https://quest233.github.io">
                <img src="/images/150879.png" alt="quest_2">
                quest_2
            </a>
        </footer>
    </div>
</div>

      
        
            

        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5/&title=《紫题算法学习实况》 — quest233的博客&pic=https://quest233.github.ioimages/150879.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5/&title=《紫题算法学习实况》 — quest233的博客&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《紫题算法学习实况》 — quest233的博客&url=https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5/&via=https://quest233.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://quest233.github.io/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/“知识”决定命运/" class="color4">“知识”决定命运</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%9B%A0%E4%B8%BA%E8%BF%9B%E4%B8%8D%E5%8E%BB%E5%A4%8D%E8%B5%9B%E5%B0%B1%E5%8F%AA%E8%83%BD%E4%BC%91%E5%85%BB%E4%BC%91%E5%85%BB%E7%94%9F%E6%81%AF%EF%BC%8C%E6%95%B4%E7%82%B9%E7%AE%97%E6%B3%95%E5%AD%A6%E5%AD%A6%E3%80%82"><span class="post-toc-text">因为进不去复赛就只能休养休养生息，整点算法学学。</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#2020-10-21%EF%BC%9A%E7%AB%9F%E7%84%B6%E4%B8%8Ehe%E8%80%81%E7%88%B7%E8%AE%B2%E8%AF%BE%E6%92%9E%E8%BD%A6%E4%BA%86%EF%BC%8C%E4%B8%A4%E7%9B%B8%E5%AF%B9%E6%AF%94%E6%98%BE%E7%84%B6%E7%AA%81%E5%87%BA%E7%AA%9D%E7%9A%84%E8%8F%9C"><span class="post-toc-text">2020-10-21：竟然与he老爷讲课撞车了，两相对比显然突出窝的菜</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#2020-11-16%EF%BC%9ACSP-S%E5%8F%88%E5%9E%AB%E5%BA%95%E4%BA%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AE%89%E5%BF%83%E5%86%99%E5%8D%9A%E5%AE%A2%E5%8A%9B"><span class="post-toc-text">2020-11-16：CSP-S又垫底了，可以安心写博客力</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#2020-12-26%EF%BC%9A%E8%AF%A5%E6%96%87%E7%AB%A0%E5%B7%B2%E5%81%9C%E6%9B%B4%EF%BC%8C%E5%85%89%E6%A0%87%E5%87%A0%E4%B9%8E%E5%8D%A1%E7%9A%84%E5%8A%A8%E4%B8%8D%E4%BA%86%E4%BA%86"><span class="post-toc-text">2020-12-26：该文章已停更，光标几乎卡的动不了了</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%82%B9%E5%88%86%E6%B2%BB"><span class="post-toc-text">点分治</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%84%E7%90%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="post-toc-text">处理什么问题：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%80%9D%E6%83%B3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A"><span class="post-toc-text">思想是什么：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%80%E4%B8%AA%E6%A6%82%E5%BF%B5%E5%8F%AB%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%EF%BC%9A"><span class="post-toc-text">这里有一个概念叫树的重心：</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%B2%E7%88%86%E4%B9%A0%E9%A2%98%EF%BC%9A"><span class="post-toc-text">劲爆习题：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%82%B9%E5%88%86%E6%A0%91%EF%BC%88%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB%EF%BC%89"><span class="post-toc-text">点分树（动态点分治）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%84%E7%90%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9A-1"><span class="post-toc-text">处理什么问题：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%80%9D%E6%83%B3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A-1"><span class="post-toc-text">思想是什么：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%B2%E7%88%86%E4%B9%A0%E9%A2%98%EF%BC%9A-1"><span class="post-toc-text">劲爆习题：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%97%A0%E6%97%8B-treap"><span class="post-toc-text">无旋 $treap$</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%99%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A"><span class="post-toc-text">这是什么：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%80%9D%E6%83%B3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A-2"><span class="post-toc-text">思想是什么：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%9A%E7%9F%A5%E9%81%93%E6%99%AE%E9%80%9A-treap-%E7%9A%84%E5%BD%A2%E6%80%81%E4%B8%8E%E6%80%A7%E8%B4%A8%E3%80%82"><span class="post-toc-text">前置知识：知道普通 $treap$ 的形态与性质。</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%97%A0%E6%97%8B-treap-%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="post-toc-text">无旋 $treap$ 的特性：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%8A%A0%E7%82%B9%EF%BC%9A"><span class="post-toc-text">加点：</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%88%A0%E7%82%B9%EF%BC%9A"><span class="post-toc-text">删点：</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E6%9F%A5%E7%AC%AC-k-%E5%A4%A7%EF%BC%9A"><span class="post-toc-text">查第 $k$ 大：</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E6%8E%92%E5%90%8D%EF%BC%9A"><span class="post-toc-text">获取元素排名：</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E6%9F%A5%E5%89%8D%E9%A9%B1%EF%BC%9A"><span class="post-toc-text">查前驱：</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E6%9F%A5%E5%90%8E%E7%BC%80%EF%BC%9A"><span class="post-toc-text">查后缀：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link"><span class="post-toc-text">1
2
3
4
5
6
7
8
int nxt(int K)
&amp;#123;
	int l, r;
	split(ROOT, K, l, r);&#x2F;&#x2F;将大于x的部分分离出来
	int ans &#x3D; T[getkth(r, 1)].val;&#x2F;&#x2F;取第1位
	ROOT &#x3D; merge(l, r);
	return ans;
&amp;#125;
</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%B2%E7%88%86%E4%B9%A0%E9%A2%98"><span class="post-toc-text">劲爆习题:</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#-1"><span class="post-toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define ls(a) T[(a)].son[0]
#define rs(a) T[(a)].son[1]
const int MAX &#x3D; 1e5 + 7;
int N, ROOT, cnt &#x3D; 0;
struct node
&amp;#123;
	int son[2];
	int fa;
	int val;
	int prio;
	int size;
&amp;#125; T[MAX];

&#x2F;*创造新点*&#x2F;
void add(int x)
&amp;#123;
	cnt++;
	T[cnt].size &#x3D; 1;
	T[cnt].val &#x3D; x;
	T[cnt].prio &#x3D; rand();
	ls(cnt) &#x3D; rs(cnt) &#x3D; 0;
&amp;#125;

&#x2F;*整合子树信息*&#x2F;
void push_up(int p)
&amp;#123;
	T[p].size &#x3D; T[ls(p)].size + T[rs(p)].size + 1;
&amp;#125;

&#x2F;*分裂*&#x2F;
void split(int p, int x, int &amp;L, int &amp;R)
&amp;#123;
	if (!p)
	&amp;#123;
		L &#x3D; 0;
		R &#x3D; 0;
		return;
	&amp;#125;
	if (T[p].val &lt;&#x3D; x)
	&amp;#123;
		L &#x3D; p;
		split(rs(p), x, rs(p), R);
	&amp;#125;
	else
	&amp;#123;
		R &#x3D; p;
		split(ls(p), x, L, ls(p));
	&amp;#125;
	push_up(p);
&amp;#125;

&#x2F;*合并*&#x2F;
int merge(int Lroot, int Rroot)
&amp;#123;
	if (!Lroot)
	&amp;#123;
		return Rroot;
	&amp;#125;
	if (!Rroot)
	&amp;#123;
		return Lroot;
	&amp;#125;
	if (T[Lroot].prio &lt; T[Rroot].prio)
	&amp;#123;
		rs(Lroot) &#x3D; merge(rs(Lroot), Rroot);
		push_up(Lroot);
		return Lroot;
	&amp;#125;
	else
	&amp;#123;
		ls(Rroot) &#x3D; merge(Lroot, ls(Rroot));
		push_up(Rroot);
		return Rroot;
	&amp;#125;
&amp;#125;

&#x2F;*插入操作*&#x2F;
void insert(int x)
&amp;#123;
	int l, r;
	split(ROOT, x, l, r);
	add(x);
	ROOT &#x3D; merge(merge(l, cnt), r);
&amp;#125;

&#x2F;*删除操作*&#x2F;
void erase(int x)
&amp;#123;
	int l, r, p;
	split(ROOT, x, l, p);
	split(l, x - 1, l, r);
	r &#x3D; merge(ls(r), rs(r));
	ROOT &#x3D; merge(merge(l, r), p);
&amp;#125;

&#x2F;*查第K大*&#x2F;
int getkth(int p, int K)
&amp;#123;
	if (K &lt;&#x3D; T[ls(p)].size)
	&amp;#123;
		return getkth(ls(p), K);
	&amp;#125;
	if (K &#x3D;&#x3D; T[ls(p)].size + 1)
	&amp;#123;
		return p;
	&amp;#125;
	return getkth(rs(p), K - T[ls(p)].size - 1);
&amp;#125;

&#x2F;*获取排名*&#x2F;
int getrank(int p, int K)
&amp;#123;
	int l, r;
	split(ROOT, K - 1, l, r);
	int ans &#x3D; T[l].size + 1;
	ROOT &#x3D; merge(l, r);
	return ans;
&amp;#125;

&#x2F;*获取前驱*&#x2F;
int pre(int K)
&amp;#123;
	int l, r;
	split(ROOT, K - 1, l, r);
	int ans &#x3D; T[getkth(l, T[l].size)].val;
	ROOT &#x3D; merge(l, r);
	return ans;
&amp;#125;

&#x2F;*获取后继*&#x2F;
int nxt(int K)
&amp;#123;
	int l, r;
	split(ROOT, K, l, r);
	int ans &#x3D; T[getkth(r, 1)].val;
	ROOT &#x3D; merge(l, r);
	return ans;
&amp;#125;


int main()
&amp;#123;
	srand(20050418);&#x2F;&#x2F;窝npy的生日ww
	int Q;
	cin &gt;&gt; Q;
	while (Q--)
	&amp;#123;
		int opt, num;
		cin &gt;&gt; opt;
		if (opt &#x3D;&#x3D; 1)
		&amp;#123;
			cin &gt;&gt; num;
			insert(num);
		&amp;#125;
		if (opt &#x3D;&#x3D; 2)
		&amp;#123;
			cin &gt;&gt; num;
			erase(num);
		&amp;#125;
		if (opt &#x3D;&#x3D; 3)
		&amp;#123;
			cin &gt;&gt; num;
			cout &lt;&lt; getrank(ROOT, num) &lt;&lt; endl;
		&amp;#125;
		if (opt &#x3D;&#x3D; 4)
		&amp;#123;
			cin &gt;&gt; num;
			cout &lt;&lt; T[getkth(ROOT, num)].val &lt;&lt; endl;
		&amp;#125;
		if (opt &#x3D;&#x3D; 5)
		&amp;#123;
			cin &gt;&gt; num;
			cout &lt;&lt; pre(num) &lt;&lt; endl;
		&amp;#125;
		if (opt &#x3D;&#x3D; 6)
		&amp;#123;
			cin &gt;&gt; num;
			cout &lt;&lt; nxt(num) &lt;&lt; endl;
		&amp;#125;
	&amp;#125;
&amp;#125;
</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81%E5%9F%BA%E7%A1%80%E5%BB%BA%E6%A8%A1%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="post-toc-text">网络流基础建模——最大流</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A5%97%E8%B7%AF%E4%B8%80%EF%BC%9A%E6%9E%84%E5%BB%BA%E8%B6%85%E7%BA%A7%E6%BA%90%E6%B1%87%EF%BC%9A"><span class="post-toc-text">套路一：构建超级源汇：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8A%B2%E7%88%86%E4%BE%8B%E9%A2%98%EF%BC%9A"><span class="post-toc-text">劲爆例题：</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A5%97%E8%B7%AF%E4%BA%8C%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%B5%81%E6%94%B9%E6%9C%80%E5%B0%8F%E5%89%B2%EF%BC%9A"><span class="post-toc-text">套路二：最大流改最小割：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8A%B2%E7%88%86%E4%BE%8B%E9%A2%98%EF%BC%9A-1"><span class="post-toc-text">劲爆例题：</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#-2"><span class="post-toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define int long long
const int MAX &#x3D; 1e5 + 7;
const int INF &#x3D; 1e18;

&#x2F;*dinic组件*&#x2F;
struct edge
&amp;#123;
	int next, to;
	int val;
&amp;#125; e[MAX &lt;&lt; 1];
int head[MAX], eid &#x3D; 1;
void adde(int x, int y, int w)
&amp;#123;
	e[++eid].next &#x3D; head[x];
	e[eid].to &#x3D; y;
	e[eid].val &#x3D; w;
	head[x] &#x3D; eid;
&amp;#125;
int dep[MAX];
int flag &#x3D; 0;
queue&lt;int&gt; q;
int S, T;
#define RUN(u) for (int i &#x3D; head[u]; i; i &#x3D; e[i].next)
void bfs()
&amp;#123;
	memset(dep, 0, sizeof(dep));
	dep[S] &#x3D; 1;
	while (!q.empty())
	&amp;#123;
		q.pop();
	&amp;#125;
	q.push(S);
	while (!q.empty())
	&amp;#123;
		int u &#x3D; q.front();
		q.pop();
		RUN(u)
		&amp;#123;
			int v &#x3D; e[i].to;
			if (e[i].val &#x3D;&#x3D; 0 || dep[v])
			&amp;#123;
				continue;
			&amp;#125;
			dep[v] &#x3D; dep[u] + 1;
			q.push(v);
		&amp;#125;
	&amp;#125;
	if (dep[T])
	&amp;#123;
		flag &#x3D; 1;
	&amp;#125;
&amp;#125;
int dfs(int u, int in)
&amp;#123;
	if (u &#x3D;&#x3D; T)
	&amp;#123;
		return in;
	&amp;#125;
	int out &#x3D; 0;
	RUN(u)
	&amp;#123;
		int v &#x3D; e[i].to;
		if (e[i].val &#x3D;&#x3D; 0 || dep[v] !&#x3D; dep[u] + 1)
		&amp;#123;
			continue;
		&amp;#125;
		int tmp &#x3D; dfs(v, min(in, e[i].val));
		if (in &#x3D;&#x3D; 0)
		&amp;#123;
			return out;
		&amp;#125;
		e[i].val -&#x3D; tmp;
		e[i ^ 1].val +&#x3D; tmp;
		in -&#x3D; tmp;
		out +&#x3D; tmp;
	&amp;#125;
	if (out &#x3D;&#x3D; 0)
	&amp;#123;
		dep[u] &#x3D; 0;
	&amp;#125;
	return out;
&amp;#125;
int M, N;
int idx(int x, int y)&#x2F;&#x2F;获取一个方格的编号
&amp;#123;
	return (x - 1) * N + y;
&amp;#125;
signed main()
&amp;#123;
	cin &gt;&gt; M &gt;&gt; N;&#x2F;&#x2F;这道题对N,M的定义是和常识相反的
    &#x2F;&#x2F;申必题（bushi
    
	int sum &#x3D; 0;
	S &#x3D; 0, T &#x3D; 107 * 107 + 1;
	for (int i &#x3D; 1; i &lt;&#x3D; M; i++)
	&amp;#123;
		for (int j &#x3D; 1; j &lt;&#x3D; N; j++)
		&amp;#123;
			int num;
			cin &gt;&gt; num;
			sum +&#x3D; num;
			if ((i + j) &amp; 1)&#x2F;&#x2F;若行+列&#x3D;奇则染白，连源点
			&amp;#123;
				adde(S, idx(i, j), num);
				adde(idx(i, j), S, 0);
                
                &#x2F;*向上下左右四个方向连边*&#x2F;
				if (i &gt; 1)
				&amp;#123;
					adde(idx(i, j), idx(i - 1, j), INF);
					adde(idx(i - 1, j), idx(i, j), 0);
				&amp;#125;
				if (i &lt; M)
				&amp;#123;
					adde(idx(i, j), idx(i + 1, j), INF);
					adde(idx(i + 1, j), idx(i, j), 0);
				&amp;#125;
				if (j &gt; 1)
				&amp;#123;
					adde(idx(i, j), idx(i, j - 1), INF);
					adde(idx(i, j - 1), idx(i, j), 0);
				&amp;#125;
				if (j &lt; N)
				&amp;#123;
					adde(idx(i, j), idx(i, j + 1), INF);
					adde(idx(i, j + 1), idx(i, j), 0);
				&amp;#125;
                
			&amp;#125;
			else&#x2F;&#x2F;若行+列&#x3D;偶则染黑，连汇点
			&amp;#123;
				adde(idx(i, j), T, num);
				adde(T, idx(i, j), 0);
			&amp;#125;
		&amp;#125;
	&amp;#125;
	int ans &#x3D; 0;
	while (1)
	&amp;#123;
		flag &#x3D; 0;
		bfs();
		if (flag &#x3D;&#x3D; 0)
		&amp;#123;
			break;
		&amp;#125;
		ans +&#x3D; dfs(S, INF);
	&amp;#125;
	cout &lt;&lt; sum - ans &lt;&lt; endl;&#x2F;&#x2F;收益为总价值-割
&amp;#125;
</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A5%97%E8%B7%AF%E4%BA%8C-%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%85%B6%E4%BB%96%E9%BB%91%E7%99%BD%E6%9F%93%E8%89%B2%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="post-toc-text">套路二-进阶：其他黑白染色模型：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A5%97%E8%B7%AF%E4%B8%80-%E5%A5%97%E8%B7%AF%E4%BA%8C-%E5%A5%97%E8%B7%AF%E4%B8%89%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%E6%A8%A1%E5%9E%8B"><span class="post-toc-text">套路一+套路二&#x3D;套路三：最大权闭合子图模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8A%B2%E7%88%86%E4%BE%8B%E9%A2%98%EF%BC%9A-2"><span class="post-toc-text">劲爆例题：</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A5%97%E8%B7%AF%E5%9B%9B%EF%BC%9A%E6%8B%86%E7%82%B9"><span class="post-toc-text">套路四：拆点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%B2%E7%88%86%E4%B9%A0%E9%A2%98%EF%BC%9A-2"><span class="post-toc-text">劲爆习题：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A5%97%E8%B7%AF%E4%B8%80-%E5%A5%97%E8%B7%AF%E5%9B%9B-%E5%A5%97%E8%B7%AF%E5%9B%9B%E7%82%B9%E4%BA%94%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%B5%81%E4%B8%8ELIS"><span class="post-toc-text">套路一+套路四&#x3D;套路四点五：网络流与LIS</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%88%91%E4%BB%AC%E7%9B%B4%E6%8E%A5%E4%B8%A2%E5%87%BA%E4%BE%8B%E9%A2%98%EF%BC%9A"><span class="post-toc-text">我们直接丢出例题：</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A5%97%E8%B7%AF%E4%BA%94%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98"><span class="post-toc-text">套路五：最小路径覆盖问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%8D%E5%8F%A3%E5%97%A8%E4%BA%86%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BE%8B%E9%A2%98%EF%BC%9A"><span class="post-toc-text">不口嗨了，直接上例题：</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#EX-%E5%A5%97%E8%B7%AF%E4%BA%94%EF%BC%9A%E5%85%B6%E4%BB%96%E6%9C%89%E8%B6%A3%EF%BC%88%EF%BC%9F%EF%BC%89%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%E6%B3%9B%E8%AE%B2%EF%BC%9A"><span class="post-toc-text">EX-套路五：其他有趣（？）的最小路径覆盖问题泛讲：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A5%97%E8%B7%AF%E5%85%AD%EF%BC%9A%E8%99%9A%E7%82%B9%E7%9A%84%E6%9E%84%E5%BB%BA%EF%BC%9A"><span class="post-toc-text">套路六：虚点的构建：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%8B%E9%9D%A2%E6%9D%A5%E5%BA%B7%E4%BE%8B%E9%A2%98%EF%BC%9A"><span class="post-toc-text">下面来康例题：</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#-3"><span class="post-toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define int long long
const int LAR &#x3D; 10000;
const int MAX &#x3D; 5e5 + 7;
const int INF &#x3D; 1e18;

&#x2F;*网络流板子*&#x2F;
struct edge
&amp;#123;
	int next, to;
	int val;
&amp;#125; e[MAX &lt;&lt; 1];
int head[MAX], eid &#x3D; 1;
int cur[MAX];
void adde(int x, int y, int w)
&amp;#123;
	e[++eid].next &#x3D; head[x];
	e[eid].to &#x3D; y;
	e[eid].val &#x3D; w;
	head[x] &#x3D; eid;
&amp;#125;
int dep[MAX];
int flag &#x3D; 0;
queue&lt;int&gt; q;
int S, T;
#define RUN(u) for (int i &#x3D; head[u]; i; i &#x3D; e[i].next)
bool bfs()
&amp;#123;
	memset(dep, 0, sizeof(dep));
	dep[S] &#x3D; 1;
	while (!q.empty())
	&amp;#123;
		q.pop();
	&amp;#125;
	q.push(S);
	while (!q.empty())
	&amp;#123;
		int u &#x3D; q.front();
		q.pop();
		RUN(u)
		&amp;#123;
			int v &#x3D; e[i].to;
			if (e[i].val &#x3D;&#x3D; 0 || dep[v])
			&amp;#123;
				continue;
			&amp;#125;
			dep[v] &#x3D; dep[u] + 1;
			q.push(v);
		&amp;#125;
	&amp;#125;
	memcpy(cur, head, sizeof(head));
	return dep[T] !&#x3D; 0;
&amp;#125;
int dfs(int u, int in)
&amp;#123;
	if (u &#x3D;&#x3D; T || !in)
	&amp;#123;
		return in;
	&amp;#125;
	int out &#x3D; 0;
	for (int i &#x3D; cur[u]; i; i &#x3D; e[i].next)
	&amp;#123;
		cur[u] &#x3D; i;
		int v &#x3D; e[i].to;
		if (dep[v] !&#x3D; dep[u] + 1)
		&amp;#123;
			continue;
		&amp;#125;
		int tmp &#x3D; dfs(v, min(in, e[i].val));
		if (!tmp)
		&amp;#123;
			continue;
		&amp;#125;
		e[i].val -&#x3D; tmp;
		e[i ^ 1].val +&#x3D; tmp;
		in -&#x3D; tmp;
		out +&#x3D; tmp;
		if (in &#x3D;&#x3D; 0)
		&amp;#123;
			return out;
		&amp;#125;
	&amp;#125;
	if (out &#x3D;&#x3D; 0)
	&amp;#123;
		dep[u] &#x3D; 0;
	&amp;#125;
	return out;
&amp;#125;

&#x2F;*几个数组分别对应该位置选文、选理、相邻都选文、相邻都选理*&#x2F;
int A[107][107];
int B[107][107];
int C[107][107];
int D[107][107];
int N, M;
int idx(int x, int y)&#x2F;&#x2F;取标号
&amp;#123;
	return (x - 1) * M + y;
&amp;#125;

signed main()
&amp;#123;
	cin &gt;&gt; N &gt;&gt; M;
	int sum &#x3D; 0;
	S &#x3D; 0, T &#x3D; 5 * N * M + 1;
	for (int i &#x3D; 1; i &lt;&#x3D; N; i++)
	&amp;#123;
		for (int j &#x3D; 1; j &lt;&#x3D; M; j++)
		&amp;#123;
			cin &gt;&gt; A[i][j];
			sum +&#x3D; A[i][j];
			adde(S, idx(i, j), A[i][j]);
			adde(idx(i, j), S, 0);&#x2F;&#x2F;文连源
		&amp;#125;
	&amp;#125;
	for (int i &#x3D; 1; i &lt;&#x3D; N; i++)
	&amp;#123;
		for (int j &#x3D; 1; j &lt;&#x3D; M; j++)
		&amp;#123;
			cin &gt;&gt; B[i][j];
			sum +&#x3D; B[i][j];
			adde(idx(i, j), T, B[i][j]);
			adde(T, idx(i, j), 0);&#x2F;&#x2F;理连汇
		&amp;#125;
	&amp;#125;
	for (int i &#x3D; 1; i &lt;&#x3D; N; i++)
	&amp;#123;
		for (int j &#x3D; 1; j &lt;&#x3D; M; j++)
		&amp;#123;
			cin &gt;&gt; C[i][j];
			sum +&#x3D; C[i][j];
			int u &#x3D; 2 * N * M + idx(i, j);&#x2F;&#x2F;虚点标号
            
			adde(S, u, C[i][j]);&#x2F;&#x2F;价值
			adde(u, S, 0);
            
			adde(u, idx(i, j), INF);&#x2F;&#x2F;当然他自己也要选文
			adde(idx(i, j), u, 0);
            
            &#x2F;*虚点连向四个方向的点*&#x2F;
			if (j - 1 &gt; 0)
			&amp;#123;
				adde(u, idx(i, j - 1), INF);
				adde(idx(i, j - 1), u, 0);
			&amp;#125;
			if (j + 1 &lt;&#x3D; M)
			&amp;#123;
				adde(u, idx(i, j + 1), INF);
				adde(idx(i, j + 1), u, 0);
			&amp;#125;
			if (i - 1 &gt; 0)
			&amp;#123;
				adde(u, idx(i - 1, j), INF);
				adde(idx(i - 1, j), u, 0);
			&amp;#125;
			if (i + 1 &lt;&#x3D; N)
			&amp;#123;
				adde(u, idx(i + 1, j), INF);
				adde(idx(i + 1, j), u, 0);
			&amp;#125;
		&amp;#125;
	&amp;#125;
	for (int i &#x3D; 1; i &lt;&#x3D; N; i++)
	&amp;#123;
		for (int j &#x3D; 1; j &lt;&#x3D; M; j++)
		&amp;#123;
			cin &gt;&gt; D[i][j];
			sum +&#x3D; D[i][j];
			int u &#x3D; 4 * N * M + idx(i, j);&#x2F;&#x2F;虚点标号
            
			adde(u, T, D[i][j]);&#x2F;&#x2F;价值
			adde(T, u, 0);
            
			adde(idx(i, j), u, INF);&#x2F;&#x2F;当然他自己也要选理
			adde(u, idx(i, j), 0);
            
            &#x2F;*向四个方向连边*&#x2F;
			if (j - 1 &gt; 0)
			&amp;#123;
				adde(idx(i, j - 1), u, INF);
				adde(u, idx(i, j - 1), 0);
			&amp;#125;
			if (j + 1 &lt;&#x3D; M)
			&amp;#123;
				adde(idx(i, j + 1), u, INF);
				adde(u, idx(i, j + 1), 0);
			&amp;#125;
			if (i - 1 &gt; 0)
			&amp;#123;
				adde(idx(i - 1, j), u, INF);
				adde(u, idx(i - 1, j), 0);
			&amp;#125;
			if (i + 1 &lt;&#x3D; N)
			&amp;#123;
				adde(idx(i + 1, j), u, INF);
				adde(u, idx(i + 1, j), 0);
			&amp;#125;
		&amp;#125;
	&amp;#125;
	int ans &#x3D; 0;
	while (bfs())
	&amp;#123;
		ans +&#x3D; dfs(S, INF);
	&amp;#125;
	cout &lt;&lt; sum - ans &lt;&lt; endl;&#x2F;&#x2F;总价值-最小割
&amp;#125;

</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A5%97%E8%B7%AF%E4%B8%83%EF%BC%9A%E4%BA%8C%E5%88%86%E4%B8%8E%E6%9E%9A%E4%B8%BE%EF%BC%9A"><span class="post-toc-text">套路七：二分与枚举：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8A%B2%E7%88%86%E4%BE%8B%E9%A2%98"><span class="post-toc-text">劲爆例题</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#-4"><span class="post-toc-text">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define int long long
const int MAX &#x3D; 5e5 + 7;
const int INF &#x3D; 1e18;

&#x2F;*dinic组件*&#x2F;
struct edge
&amp;#123;
	int next, to;
	int val;
&amp;#125; e[MAX &lt;&lt; 1];
int head[MAX], eid &#x3D; 1;
int cur[MAX];
void adde(int x, int y, int w)
&amp;#123;
	e[++eid].next &#x3D; head[x];
	e[eid].to &#x3D; y;
	e[eid].val &#x3D; w;
	head[x] &#x3D; eid;
&amp;#125;
int dep[MAX];
int flag &#x3D; 0;
queue&lt;int&gt; q;
int S, T;
#define RUN(u) for (int i &#x3D; head[u]; i; i &#x3D; e[i].next)
bool bfs()
&amp;#123;
	memset(dep, 0, sizeof(dep));
	dep[S] &#x3D; 1;
	while (!q.empty())
	&amp;#123;
		q.pop();
	&amp;#125;
	q.push(S);
	while (!q.empty())
	&amp;#123;
		int u &#x3D; q.front();
		q.pop();
		RUN(u)
		&amp;#123;
			int v &#x3D; e[i].to;
			if (e[i].val &#x3D;&#x3D; 0 || dep[v])
			&amp;#123;
				continue;
			&amp;#125;
			dep[v] &#x3D; dep[u] + 1;
			q.push(v);
		&amp;#125;
	&amp;#125;
	memcpy(cur, head, sizeof(head));
	return dep[T] !&#x3D; 0;
&amp;#125;
int dfs(int u, int in)
&amp;#123;
	if (u &#x3D;&#x3D; T || !in)
	&amp;#123;
		return in;
	&amp;#125;
	int out &#x3D; 0;
	for (int i &#x3D; cur[u]; i; i &#x3D; e[i].next)
	&amp;#123;
		cur[u] &#x3D; i;
		int v &#x3D; e[i].to;
		if (dep[v] !&#x3D; dep[u] + 1)
		&amp;#123;
			continue;
		&amp;#125;
		int tmp &#x3D; dfs(v, min(in, e[i].val));
		if (!tmp)
		&amp;#123;
			continue;
		&amp;#125;
		e[i].val -&#x3D; tmp;
		e[i ^ 1].val +&#x3D; tmp;
		in -&#x3D; tmp;
		out +&#x3D; tmp;
		if (in &#x3D;&#x3D; 0)
		&amp;#123;
			return out;
		&amp;#125;
	&amp;#125;
	if (out &#x3D;&#x3D; 0)
	&amp;#123;
		dep[u] &#x3D; 0;
	&amp;#125;
	return out;
&amp;#125;
int N, M;
int a[MAX], b[MAX];
int akioi[MAX], tot &#x3D; 0;&#x2F;&#x2F;akioi 数组记录（表示 “这场比赛流向参赛者” 的边）的编号

&#x2F;*二分函数*&#x2F;
bool judge(int x)
&amp;#123;
	memset(head, 0, sizeof(head));&#x2F;&#x2F;暴力清空
    
	eid &#x3D; 1;
	S &#x3D; 0, T &#x3D; 20000 + N + 1;
    
    &#x2F;*建边*&#x2F;
	for (int i &#x3D; 1; i &lt;&#x3D; M; i++)
	&amp;#123;
		adde(S, i, 1);
		adde(i, S, 0);&#x2F;&#x2F;源连向比赛
		adde(i, a[i] + 20000, 1);
		akioi[i] &#x3D; eid;
        &#x2F;&#x2F;记录下这条边的编号，以后输出方案要用
        
		adde(a[i] + 20000, i, 0);
		adde(i, b[i] + 20000, 1);
		adde(b[i] + 20000, i, 0);&#x2F;&#x2F;比赛连向参赛者
	&amp;#125;
	for (int i &#x3D; 1; i &lt;&#x3D; N; i++)
	&amp;#123;
		adde(i + 20000, T, x);
		adde(T, i + 20000, 0);&#x2F;&#x2F;参赛者连向汇
	&amp;#125;
	int ans &#x3D; 0;
	while (bfs())
	&amp;#123;
		ans +&#x3D; dfs(S, INF);
	&amp;#125;
	if (ans &gt;&#x3D; M)
	&amp;#123;
		return 1;
	&amp;#125;
	return 0;
&amp;#125;
signed main()
&amp;#123;
	cin &gt;&gt; N &gt;&gt; M;
	for (int i &#x3D; 1; i &lt;&#x3D; M; i++)
	&amp;#123;
		cin &gt;&gt; a[i] &gt;&gt; b[i];
	&amp;#125;
    
    &#x2F;*二分*&#x2F;
	int l &#x3D; M &#x2F; N, r &#x3D; M, ans &#x3D; M;
	while (l &lt; r)
	&amp;#123;
		int mid &#x3D; (l + r) &gt;&gt; 1;
		if (judge(mid))
		&amp;#123;
			r &#x3D; mid;
		&amp;#125;
		else
		&amp;#123;
			l &#x3D; mid + 1;
		&amp;#125;
	&amp;#125;
	cout &lt;&lt; l &lt;&lt; endl;
    
    &#x2F;&#x2F;以这个数为答案再跑一遍，生成方案
	judge(l);
	for (int i &#x3D; 1; i &lt;&#x3D; M; i++)
	&amp;#123;
		if (e[6 * (i - 1) + 4].val &#x3D;&#x3D; 0)&#x2F;&#x2F;查询其是否满流
        &#x2F;&#x2F;（若流向一个人的边的容量变成了0，则它满流）
		&amp;#123;
			cout &lt;&lt; 1 &lt;&lt; endl;
		&amp;#125;
		else
		&amp;#123;
			cout &lt;&lt; 0 &lt;&lt; endl;
		&amp;#125;
	&amp;#125;
&amp;#125;
</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A5%97%E8%B7%AFINF%EF%BC%9A%E5%85%B6%E4%BB%96%E4%B8%8D%E5%B8%B8%E8%A7%81%E6%8A%80%E5%B7%A7"><span class="post-toc-text">套路INF：其他不常见技巧</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9D%9C%E6%95%99%E7%AD%9B"><span class="post-toc-text">杜教筛</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="post-toc-text">原理？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="post-toc-text">数论函数的选择</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%B2%E7%88%86%E4%BE%8B%E9%A2%98-1"><span class="post-toc-text">劲爆例题</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%92%95%E5%92%95%E5%92%95%EF%BC%81"><span class="post-toc-text">咕咕咕！</span></a>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2021/04/17/%E7%B4%AB%E9%A2%98%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%AE%9E%E5%86%B5-II/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          紫题算法学习实况 II
        
      </span>
    </a>
  
  
    <a href="/2021/04/17/%E6%99%BE%E8%A1%A3%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">晾衣架学习笔记</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
          <div id="uyan_frame"></div>
  <script src="http://v2.uyan.cc/code/uyan.js?uid=true"></script>

    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2021 quest_2<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://quest233.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 0
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/solutions/" style="font-size: 20px;">solutions</a> <a href="/tags/water/" style="font-size: 10px;">water</a> <a href="/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/" style="font-size: 15px;">“知识”决定命运</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/2021/04/17/About/#more">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/solutions/" style="font-size: 20px;">solutions</a> <a href="/tags/water/" style="font-size: 10px;">water</a> <a href="/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/" style="font-size: 15px;">“知识”决定命运</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>