<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="referrer" content="no-referrer" />
  
  <title>浅谈简单数据结构 | quest233的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="quest_2" />
  
  <meta name="description" content="是鬼畜数据结构专题～ 我是不会告诉你我打前两次NOIP&#x2F;CSP的时候对这些东西都一无所知的（雾）。 这些有（du）趣（liu）的数据结构题往往伴随着各种鬼畜操作，各种诡异询问。毕竟裸的板子题越来越少了（哭），还是应该灵活运用。 分 块蛮好打的数据结构，算是里面比较不毒瘤一点的了，理解也不难，下面稍微讲解一下他的思想。 基本思想？有一区间长为 $n$ ，我们把他分成 $\sqrt{n}$ 个块，那由">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈简单数据结构">
<meta property="og:url" content="https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="quest233的博客">
<meta property="og:description" content="是鬼畜数据结构专题～ 我是不会告诉你我打前两次NOIP&#x2F;CSP的时候对这些东西都一无所知的（雾）。 这些有（du）趣（liu）的数据结构题往往伴随着各种鬼畜操作，各种诡异询问。毕竟裸的板子题越来越少了（哭），还是应该灵活运用。 分 块蛮好打的数据结构，算是里面比较不毒瘤一点的了，理解也不难，下面稍微讲解一下他的思想。 基本思想？有一区间长为 $n$ ，我们把他分成 $\sqrt{n}$ 个块，那由">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/p948fw94.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/uaxdsf0b.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/n8d607kl.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/h4uw07hj.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/ce3qwvey.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/6q6m0pcl.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/swhfdktm.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/26bnlj5i.png">
<meta property="og:image" content="https://cdn.luogu.com.cn/upload/image_hosting/482mmx80.png">
<meta property="article:published_time" content="2021-04-17T05:33:28.000Z">
<meta property="article:modified_time" content="2021-04-17T08:14:33.403Z">
<meta property="article:author" content="quest_2">
<meta property="article:tag" content="“知识”决定命运">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.luogu.com.cn/upload/image_hosting/p948fw94.png">
  
  
    <link rel="icon" href="images/62224.png">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">quest_2&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/2021/04/17/About/#more">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/150879.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        quest_2&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        “知识”决定命运
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-浅谈简单数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      浅谈简单数据结构
    </h1>
    <div class="post-title-bar">
      <ul>
          
        <li>
          <i class="fa fa-calendar"></i>  2021-04-17
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <p>是鬼畜数据结构专题～</p>
<p><del>我是不会告诉你我打前两次NOIP/CSP的时候对这些东西都一无所知的（雾）。</del></p>
<p>这些有（du）趣（liu）的数据结构题往往伴随着各种鬼畜操作，各种诡异询问。毕竟裸的板子题越来越少了（哭），还是应该灵活运用。</p>
<h3 id="分-块"><a href="#分-块" class="headerlink" title="分 块"></a>分 块</h3><p>蛮好打的数据结构，算是里面比较不毒瘤一点的了，理解也不难，下面稍微讲解一下他的思想。</p>
<h4 id="基本思想？"><a href="#基本思想？" class="headerlink" title="基本思想？"></a>基本思想？</h4><p>有一区间长为 $n$ ，我们把他分成 $\sqrt{n}$ 个块，那由此一来每个块里就有 $n\div \sqrt{n}=\sqrt{n}$ 个数（倘若不能整分，就在末尾保留一个元素个数不满 $\sqrt{n}$ 的零头块），在处理过程中我们遵循“多块拆分处理，整块直接处理，零块暴力处理”的策略，以区间修改为例，我们先来体味一下这句话的意思。</p>
<p>我们把整条序列比作一个国家，分出的几个块比作城市，进行的修改比作 $\color{red}\colorbox{white}{政策}$ （zzmg警告）。</p>
<p>给出政策实行的范围在 $l,r$ 之间，要在这个范围里实施“羟基计划”（<del>草</del>）。我们想采用分块，怎么做？</p>
<p>下面三层情况：</p>
<p>$Case 1:$不多不少的一块，即这个政策正好坐落在一个城市上（惨 城市 惨），对于城市里的每个学生，我们不用一个一个告知“羟基计划”实行了。我们只要在政府网上发个公告，也就是在块上打个 $tag$ ，<strong>修改整块的有关信息</strong>（比如 $sum$ ），表示这个块里的元素被修改了，这样我们就不用把这一政策下放到个人，有效地减小了复杂度。</p>
<p>$Case 2:$国家打算对一个城市的部分人实施这一政策（\jk），那我们发公告的法子就行不通了（<del>有误伤可能</del>）。怎么搞，<strong>暴力即可</strong>，封顶 $\sqrt{n}$ 的工作量我们还承受不了嘛？直接告诉个人，你被选入了“羟基计划”（\kel）。我们甚至还可以再贪一把，如果政策在这个城市的受众面实在太广（指修改的元素多于 $\dfrac{\sqrt{n}}{2}$ ），也可以用发公告公布政策的施行方法，再悄悄告诉那些实则不参加计划的学生，他们是破格生（\fad）。比如先在块的总和上加上（参与羟基计划的人数* 1）， $tag+1$ ，再对那些其实不用加的元素暴力 $-1$ 。</p>
<p>$Case 3:$国家打算大面积施行“羟基计划”（危）。范围包含许多连续的”试点城市“和许多不在“试点城市”的“试点人”（<del>自己编的</del>）。怎么搞？我们已经知道了对单城市和城市内个人的操作套路，那我们把这个长区间<strong>拆分成一些整块和一些零块</strong>，对于这些东西分别按 $Case 1,2$ 的套路处理即可。</p>
<h4 id="实现？好写即正义！"><a href="#实现？好写即正义！" class="headerlink" title="实现？好写即正义！"></a>实现？好写即正义！</h4><p>一些细节需要稍加注意：</p>
<ol>
<li>可以<strong>预处理</strong>一下每一个程序位于哪一块内，以及每个块的左右界。我们以一道单点修改、区间查询最大值的题为例，实现如下（这里的处理方法还是挺值得玩味的，可以用特殊值帮助记忆？）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sqr=<span class="built_in">sqrt</span>(n);</span><br><span class="line">	m=n/sqr;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		block[i]=(i<span class="number">-1</span>)/sqr+<span class="number">1</span>;<span class="comment">//预处理所在块</span></span><br><span class="line">		<span class="keyword">if</span>(num[maxx[block[i]]]&lt;num[i])</span><br><span class="line">		maxx[block[i]]=i;<span class="comment">//预处理MAX</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		L[i]=(i<span class="number">-1</span>)*sqr+<span class="number">1</span>;</span><br><span class="line">		R[i]=i*sqr;<span class="comment">//预处理左右界</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(n%sqr)</span><br><span class="line">	&#123;</span><br><span class="line">		L[m+<span class="number">1</span>]=R[m]+<span class="number">1</span>;</span><br><span class="line">		R[m+<span class="number">1</span>]=n;<span class="comment">//预处理最后的零头块上下界</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>珂以<strong>定义两种</strong> $\operatorname{check}$ 函数，(1)对应块内个体处理（$Case 2$），(2)对应全部处理（$Case 3$），(2)在运行中会调用(1)来处理他分出的散块情况。 $\operatorname{check}$ 也是如此。这里放一份区间加的部分代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_2</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span><span class="comment">//Case 2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>((r-l+<span class="number">1</span>)&gt;(R[block[l]]-L[block[l]]+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">     &#123;<span class="comment">//超过一半就处理另外一半，贪一把</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = L[block[l]]; i &lt; l;i++)</span><br><span class="line">          &#123;</span><br><span class="line">               num[i] -= v;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = R[block[r]]; i &gt; r;i--)</span><br><span class="line">          &#123;</span><br><span class="line">               num[i] -= v;</span><br><span class="line">          &#125;<span class="comment">//告知另外一半破格生</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r;i++)</span><br><span class="line">          &#123;</span><br><span class="line">               num[i] += v;<span class="comment">//告知计划内的人</span></span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     sum[block[l]] += v * (r - l + <span class="number">1</span>);</span><br><span class="line">     <span class="comment">//发公告</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_1</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(block[l]==block[r])</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">update_2</span>(l, r, v);</span><br><span class="line">     &#125;/检测到Case <span class="number">2</span>，块内处理</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">else</span><span class="comment">//Case 3</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">update_2</span>(l, R[block[l]], v);</span><br><span class="line">          <span class="built_in">update_2</span>(L[block[r]], r, v);</span><br><span class="line">          <span class="comment">//边角部分采用Case 2策略</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = block[l] + <span class="number">1</span>; i &lt; block[r];i++)</span><br><span class="line">          &#123;</span><br><span class="line">               tag[i] += v;</span><br><span class="line">               sum[i] += v * (R[i] - L[i] + <span class="number">1</span>);</span><br><span class="line">               <span class="comment">//发公告</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//整块部分采用Case 1策略</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>数据结构的题目还是尽量多写函数，否则会 <strong>很 难 调</strong>！！！（血的教训） 。</li>
</ol>
<h4 id="这里放一份分块经典代码，主函数部分还是诸位视题目而写～"><a href="#这里放一份分块经典代码，主函数部分还是诸位视题目而写～" class="headerlink" title="这里放一份分块经典代码，主函数部分还是诸位视题目而写～"></a>这里放一份分块经典代码，主函数部分还是诸位视题目而写～</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span> + <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> L[MAXN], R[MAXN], sum[MAXN], tag[MAXN];</span><br><span class="line"><span class="keyword">int</span> block[MAX], num[MAX];</span><br><span class="line"><span class="keyword">int</span> n, m, M, sqr;</span><br><span class="line"><span class="keyword">int</span> mode;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     sqr = <span class="built_in">sqrt</span>(n);</span><br><span class="line">     m = n / sqr;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          block[i] = (i - <span class="number">1</span>) / sqr + <span class="number">1</span>;</span><br><span class="line">          sum[block[i]] += num[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          L[i] = (i - <span class="number">1</span>) * sqr + <span class="number">1</span>;</span><br><span class="line">          R[i] = i * sqr;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (n % sqr)</span><br><span class="line">     &#123;</span><br><span class="line">          L[m + <span class="number">1</span>] = R[m] + <span class="number">1</span>;</span><br><span class="line">          R[m + <span class="number">1</span>] = n;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> ((r - l + <span class="number">1</span>) &gt; ((R[block[l]] - L[block[l]] + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>))</span><br><span class="line">     &#123;</span><br><span class="line">          res = sum[block[l]];</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = L[block[l]]; i &lt; l; i++)</span><br><span class="line">               res -= num[i] + tag[block[i]];</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt;= R[block[l]]; i++)</span><br><span class="line">               res -= num[i] + tag[block[i]];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">          &#123;</span><br><span class="line">               res += num[i] + tag[block[i]];</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (block[l] == block[r])</span><br><span class="line">     &#123;</span><br><span class="line">          res = <span class="built_in">check_2</span>(l, r);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          res += <span class="built_in">check_2</span>(l, R[block[l]]);</span><br><span class="line">          res += <span class="built_in">check_2</span>(L[block[r]], r);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = block[l] + <span class="number">1</span>; i &lt; block[r]; i++)</span><br><span class="line">          &#123;</span><br><span class="line">               res += sum[i];</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ((r - l + <span class="number">1</span>) &gt; (R[block[l]] - L[block[l]] + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = L[block[l]]; i &lt; l; i++)</span><br><span class="line">          &#123;</span><br><span class="line">               num[i] -= v;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = R[block[l]]; i &gt; r; i--)</span><br><span class="line">          &#123;</span><br><span class="line">               num[i] -= v;</span><br><span class="line">          &#125;</span><br><span class="line">          tag[block[l]] += v;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">          &#123;</span><br><span class="line">               num[i] += v;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     sum[block[l]] += v * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (block[l] == block[r])</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">update_2</span>(l, r, v);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">update_2</span>(l, R[block[l]], v);</span><br><span class="line">          <span class="built_in">update_2</span>(L[block[r]], r, v);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = block[l] + <span class="number">1</span>; i &lt; block[r]; i++)</span><br><span class="line">          &#123;</span><br><span class="line">               tag[i] += v;</span><br><span class="line">               sum[i] += v * (R[i] - L[i] + <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树-状-数-组"><a href="#树-状-数-组" class="headerlink" title="树 状 数 组"></a>树 状 数 组</h3><p><strong>极其好打</strong>又<strong>极其难懂</strong>的数据结构，能解决绝大部分的<strong>单点修改、区间查询</strong>的题目，但是在笔者理解不能的年代，这东西是真的噩梦。所以笔者这里尽量描述得易于理解～（说句闲话：据不可靠消息，在某次浴谷网校的课上，当一位学生提问树状数组的原理是，<del>LXL</del>当场谔谔）</p>
<h4 id="令人谔谔的思想"><a href="#令人谔谔的思想" class="headerlink" title="令人谔谔的思想"></a>令人谔谔的思想</h4><p>我们树状数组运用的思想主要是<strong>前缀和</strong>的思想，数组如其名，其结构层次就像一棵树，节点保存的都是<strong>一个区间的前缀和</strong>。就像下面这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/p948fw94.png" alt=""></p>
<p>这是一个树状数组保存值的方式，发现了吗， $A$ 数组里保存的值往往都是一个部分的值，这也就是他能做到高效区间求和（往往是 $\log{N}$ 级别）的奥秘。看上去就像一场不太公平的比赛？（<del>雾</del>）</p>
<p>我们干脆拿这种有保送资格的 公 平 竞 争 来举例子。</p>
<p>诡异的存储方式必然带来了诡异的操作方法，如何得知一个选手晋级后要参加的下场比赛成了处理的一大问题，我们来康康图上。</p>
<p>以 $1$ 为例，他从 $1$ 出发，下一场比赛在 $2$ 号位置，两个位置相差 $1$ 。再从 $2$ 出发，下一场比赛在 $4$ ，两个位置相差 $2$ 。再到 $8$ ，走 $4$ 步。$1$ 走一步， $2$ 走两步，$4$ 走四步？很难找出规律。</p>
<p>考虑从构建树状数组的方法入手吧， $1$ 所表示的区间位于赛程树的第一层， $3$ 表示的区间也在第一层，还有 $5$ 和 $7$ ，他们的下一场比赛都是在下一个位置。他们有什么共同特点，没错，都是奇数。奇数在二进制下表现的通性是什么？没错，表示 $2^0$ 的那一位上都是 $1$ 。</p>
<p>或许我们已经看出一点端倪了，同样的， $2$ 和 $6$ 位于赛程树的第二层，他们的下一场比赛在 $2$ 步之后， $2$ 和 $6$ 的二进制有什么特性?没错，表示 $2^0$ 的一位上是 $0$ ，但表示 $2^1$ 的一位上是 $1$ 。</p>
<p>我知道了（<del>，但你出言不逊是</del>）！下一场比赛与当前的距离，就是<strong>当前位置编号在二进制下，最靠后的不是 $0$ 的位置所表示 $2$ 的次幂值</strong>！那我们就有了这样的图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/uaxdsf0b.png" alt=""></p>
<p>（字有点小？）</p>
<p>怎么快速得到这个距离？有一个奇技淫巧或许是一种方法。 </p>
<p>$\operatorname {lowbit}(a)=a\And-a$ 。这样可以取到 $a$ 最靠后的非 $0$ 位（为什么？好像有用到计算机补码的知识，笔者初赛从来都是挨打，<del>我不会</del>）。</p>
<p>知道了每名选手要打什么比赛，我们现在要对选手实力进行调整了，调整了一个选手的实力，必然会对他之后要打的比赛的格局产生影响（也就是改变了其它包含他的区间的值），所以我们要进行 $\log{N}$ 的单点修改（别觉得亏，为了区间查询的效率，这里的复杂度还是值得牺牲的），也就是修改所有他要打的比赛。具体做法就是从<strong>修改点</strong> $pos$ <strong>往上跳</strong> $\operatorname{lowbit}$ ，直到 $pos \geq N$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (x &lt;= N)</span><br><span class="line">     &#123;</span><br><span class="line">          tree[x] += k;<span class="comment">//修改比赛格局</span></span><br><span class="line">          x += <span class="built_in">lowbit</span>(x);<span class="comment">//跳lowbit</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来才是树状数组的绝妙之处—— $\log{N}$ 区间查询，其实理解了前缀和的思想就很容易了，无非是 <strong>$r$ 的前缀和减上 $l-1$ 的前缀和</strong>。单点前缀和在树状数组上怎么求？其实是<strong>单点修改的反向</strong>，从 $pos$ <strong>往下跳</strong> $\operatorname{lowbit}$ ，直到 $pos \leq 0$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          res += tree[x];<span class="comment">//总和加上这个位置表达的前缀和</span></span><br><span class="line">          x -= <span class="built_in">lowbit</span>(x);<span class="comment">//跳lowbit</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*然后主函数里调用时是这样的*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s == <span class="string">&quot;Query&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fr = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> to = <span class="built_in">read</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">query</span>(to) - <span class="built_in">query</span>(fr - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//前缀和传统艺能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>希望加深记忆的读者也可以在树状数组上跑一跑，模拟一下，康康是不是这么回事。</p>
<h4 id="有一说一，这代码真的好打"><a href="#有一说一，这代码真的好打" class="headerlink" title="有一说一，这代码真的好打"></a>有一说一，这代码真的好打</h4><p>下面是一道单点修改，区间求和的板子题代码～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">200007</span>;</span><br><span class="line"><span class="keyword">int</span> N, M, tree[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (x &lt;= N)</span><br><span class="line">     &#123;</span><br><span class="line">          tree[x] += k;</span><br><span class="line">          x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          res += tree[x];</span><br><span class="line">          x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> bj = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">     <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               bj = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          ch = <span class="built_in">getchar</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">     &#123;</span><br><span class="line">          num = num * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">          ch = <span class="built_in">getchar</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> bj ? -num : num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= T; j++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(tree));</span><br><span class="line">          N = <span class="built_in">read</span>();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="keyword">int</span> num = <span class="built_in">read</span>();</span><br><span class="line">               <span class="built_in">update</span>(i, num);</span><br><span class="line">          &#125;</span><br><span class="line">          string s;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">          <span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp; s != <span class="string">&quot;End&quot;</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="keyword">if</span> (s == <span class="string">&quot;Add&quot;</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="keyword">int</span> p = <span class="built_in">read</span>();</span><br><span class="line">                    <span class="keyword">int</span> num = <span class="built_in">read</span>();</span><br><span class="line">                    <span class="built_in">update</span>(p, num);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (s == <span class="string">&quot;Sub&quot;</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="keyword">int</span> p = <span class="built_in">read</span>();</span><br><span class="line">                    <span class="keyword">int</span> num = <span class="built_in">read</span>();</span><br><span class="line">                    <span class="built_in">update</span>(p, -num);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (s == <span class="string">&quot;Query&quot;</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="keyword">int</span> fr = <span class="built_in">read</span>();</span><br><span class="line">                    <span class="keyword">int</span> to = <span class="built_in">read</span>();</span><br><span class="line">                    cout &lt;&lt; <span class="built_in">query</span>(to) - <span class="built_in">query</span>(fr - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>三 $\operatorname{while}$ 怒切绿/蓝/紫题</del>。</p>
<h3 id="线-段-树"><a href="#线-段-树" class="headerlink" title="线 段 树"></a>线 段 树</h3><p>极其<strong>难打且难调</strong>的数据结构，但是可以处理的<strong>操作和询问却极其广泛</strong>（毕竟能力越大，责任越大）。思想是不难的，起码比树状数组简单（确信）。</p>
<h4 id="就这思想"><a href="#就这思想" class="headerlink" title="就这思想"></a>就这思想</h4><p>还是那样，我们依旧拿“<del>羟基计划</del>”来说事。（zzmg警告）</p>
<p>线段树，结构如其名，像树一样。对于他内部的存储方式，向来百家争鸣。我们可以理解为构建各级机构的过程。笔者在这里推出一种最为风靡且作者本人认为最优的的建树方式：</p>
<h6 id="建树方法：结构体指针配合位运算装B法："><a href="#建树方法：结构体指针配合位运算装B法：" class="headerlink" title="建树方法：结构体指针配合位运算装B法："></a>建树方法：结构体指针配合位运算装B法：</h6><p>先把图上了！</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/n8d607kl.png" alt=""></p>
<p>这里的 $\mathtt{number}$ 数组是我们要存的值们，也就是对各人的“羟基计划”的各种方案。 $\mathtt{tree}$ 是我们最终建好的庞大的官僚体系 （<del>八月肃反名单警告</del>）。这里很容易看出，线段树是一个<strong>以空间换时间</strong>的典型数据结构。</p>
<p>体系上，每一个<strong>叶子节点</strong>都是针对于<strong>一个人</strong>的方案，每一个<strong>非叶子节点</strong>都是一个官员，负责<strong>一个区间</strong>。我们规定一个官员结点 $x$ 管辖的两个儿子（儿子可能是个人，也可能是另一个官员），他们所在的地址分别位于 $\mathtt{tree}$ 数组的 $2<em>x$ 与 $2</em>x+1$ ，用位运算装波小b，就是 $x&lt;&lt;1$ 和 $x&lt;&lt;1|1$ 。（据说是<del>会快的</del>）</p>
<p>我们这样来表示一些变量，一个结点有关的值有：$ls$：左儿子的编号， $rs$：右儿子的编号， $val$ ：值（<del>“羟基计划”的方案</del>）。</p>
<p>在实现上，我们采用<strong>递归二分</strong>的思想，往函数里传一个左边界 $l$ ，一个右边界 $r$ 。每次，我们把这个边界圈出的范围<strong>分成两半</strong>，对分出的两部分，<strong>分别进行递归</strong>，继续收缩范围。</p>
<p>还是那句话，递归的终点一定得要设置。如果左右<strong>边界合一</strong>，很明显，我们把范围收紧到了一格的位置，也就是收缩到了<strong>叶子节点</strong>上，他属于<strong>个人</strong>，直接赋值，直接向他告知“羟基计划”，然后 $return$ 走人。</p>
<p>这一部分实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左右儿子</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(ll now,ll l,ll r)</span><span class="comment">//建树</span></span></span><br><span class="line"><span class="function"><span class="comment">//参数分别为根，左边界，右边界</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*这里可以放一些tag的初始化，现在用不上*/</span></span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;<span class="comment">//叶子节点，赋值走人</span></span><br><span class="line">		val[now]=num[l];	</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	 &#125; </span><br><span class="line">	<span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;<span class="comment">//二分</span></span><br><span class="line">	<span class="built_in">build</span>(<span class="built_in">ls</span>(now),l,mdl);</span><br><span class="line">	<span class="built_in">build</span>(<span class="built_in">rs</span>(now),mdl+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//分别处理左右两半部分</span></span><br><span class="line">    <span class="comment">/*这里可以放一些整合子节点信息的操作*/</span></span><br><span class="line">	<span class="comment">/*我们叫他push_up*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\operatorname{push}$_$\operatorname{up}$ 是我们<strong>整合一个结点俩儿子的信息</strong>的操作，也就是官员下访群众收集信息的操作。比如我们要求区间和，我们的 $\operatorname{push}$ _ $\operatorname{up}$ 就是使目前的 $now$ 结点的 $val$ 值等于两个子节点的 $val$ 之和。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	val[pos] = (val[<span class="built_in">ls</span>(pos)] + val[<span class="built_in">rs</span>(pos)]);</span><br><span class="line">    <span class="comment">//整合信息</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为什么要专门把他放在一个函数里？因为我们之后的操作里还要用到（伏笔～）。</p>
<p><strong>这样建树的优势</strong>：建树较有序，使其常数更小（或许？），子结点位置不固定，方便一些操作。</p>
<h6 id="区间修改：一劳永逸懒标记下传法："><a href="#区间修改：一劳永逸懒标记下传法：" class="headerlink" title="区间修改：一劳永逸懒标记下传法："></a>区间修改：一劳永逸懒标记下传法：</h6><p>先谈思想，举个例子，我们要让 1～4 之间的所有人参加“羟基计划”。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/h4uw07hj.png" alt=""></p>
<p>我们从根结点（<del>中央JY部</del>） 开始更新，往下走。</p>
<p>树上，JY部有两个子机构，XX省JY厅(1)分管 $1$~$4$，XX省JY厅(2)分管 $5$~$6$ ，我们要修改的区间是 $1$~$4$ ，只只位于 XX省JY厅(1)的管辖范围（即发布“羟基计划”只是厅(1)的任务），所以我们往 XX省JY厅(1)的方向往下走。</p>
<p>XX省JY厅(1)有两个下属， XX市JY局(1)分管 $1$~$2$ ， XX市JY局(2)分管$3$~$4$ 。“羟基计划”与省里每个人都有关系，还记得我们分块的时候对于这种情况是如何操作的嘛？是了，发公告。如果一个部门的管辖区间被我们要修改的目标区间完全包含，我们直接在<strong>表示这个管辖区间的非叶子节点</strong>（也就是官员结点）上打 $tag$ ，如果还有什么这个管辖区间有关的值，比如 $sum$ 、$max$ ，也<strong>一并修改</strong>。我们这里就在XX省JY厅(1)上打上标记</p>
<p>那这样被修改的官员结点下属里别的官员呢，比如这里的 XX市JY局(1)和XX市JY局(2) ，我们要进行<strong>标记下传</strong>的操作了。通俗点说，就是让下面的局(1)局(2) 也得到这个公告。</p>
<p>我们标记下传的这个操作在里面叫做 $\operatorname{push}$_$\operatorname{down}$ ，实现是这样的：</p>
<p>（提醒：以下的 $sum$ 就是我们之前看到的那个 $val$ ，后面的代码同）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lft,<span class="keyword">int</span> rgt,<span class="keyword">int</span> tg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tag[x]+=tg;</span><br><span class="line">    <span class="comment">//tag的传递这样实现</span></span><br><span class="line">	sum[x]+=tg*(rgt-lft+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这里以sum为例，是“这个管辖区间有关的值的修改”的一个例证</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> lft,<span class="keyword">int</span> rgt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mdl=(lft+rgt)&gt;&gt;<span class="number">1</span>;<span class="comment">//二分</span></span><br><span class="line">	<span class="built_in">work</span>(<span class="built_in">ls</span>(x),lft,mdl,tag[x]);</span><br><span class="line">	<span class="built_in">work</span>(<span class="built_in">rs</span>(x),mdl+<span class="number">1</span>,rgt,tag[x]);</span><br><span class="line">    <span class="comment">//对两部分进行tag的传递工作</span></span><br><span class="line">	tag[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//清空这里的标记，毕竟已经传达给下属了，这里的公告可以销毁了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改的全过程只有下传是不够的，我们修改了 $1$~$4$ ，那 $1$~$6$ 这个结点怎么办，很显然，我们需要让 $1$~$6$ 这个结点再次<strong>整合他下属的信息</strong>，整合信息的做法我记得我们之前提到过，就是所谓的 $\operatorname{push}$_$\operatorname{up}$ （伏笔消除！）。所以，一个区间修改就是下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> needl,<span class="keyword">int</span> needr,<span class="keyword">int</span> lft,<span class="keyword">int</span> rgt,<span class="keyword">int</span> x,<span class="keyword">int</span> tg)</span></span></span><br><span class="line"><span class="function"><span class="comment">//参数特别说明：needl是我们要修改的区间，是不会变的。</span></span></span><br><span class="line"><span class="function"><span class="comment">//lft是我们递归到的左边界，会变。（r同理）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(needl&lt;=lft&amp;&amp;needr&gt;=rgt) </span><br><span class="line">	&#123;</span><br><span class="line">    <span class="comment">//完全包含时的有关处理</span></span><br><span class="line">		tag[x]+=tg;</span><br><span class="line">		sum[x]+=tg*(rgt-lft+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_down</span>(x,lft,rgt);</span><br><span class="line">    <span class="comment">//标记下传</span></span><br><span class="line">	<span class="keyword">int</span> mdl=(lft+rgt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(needl&lt;=mdl) <span class="built_in">change</span>(needl,needr,lft,mdl,<span class="built_in">ls</span>(x),tg);</span><br><span class="line">	<span class="keyword">if</span>(needr&gt;mdl) <span class="built_in">change</span>(needl,needr,mdl+<span class="number">1</span>,rgt,<span class="built_in">rs</span>(x),tg);</span><br><span class="line">    <span class="comment">//二分递归，这里要判断这个羟基计划和这个下属到底有没有关系</span></span><br><span class="line">    <span class="comment">//就和一开始我们不走XX省JY厅(2)是一个道理</span></span><br><span class="line">	<span class="built_in">push_up</span>(x);</span><br><span class="line">    <span class="comment">//整合信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（<del>说句闲话：线段树是有一个公告向下属传达的过程的，而分块直接就是发公告，让下面人自己去看，可见线段树国的官员比分块国负责任</del>）</p>
<h6 id="区间查询：层层递归包括即返回法："><a href="#区间查询：层层递归包括即返回法：" class="headerlink" title="区间查询：层层递归包括即返回法："></a>区间查询：层层递归包括即返回法：</h6><p>笔者个人觉得线段树的区间查询和区间修改还是蛮像的，大体说一下流程：</p>
<p>上级要检查 $4$~$5$ 的“羟基计划”实行情况。</p>
<p>假设我们之前已经在代表 $1$~$4$ 的官员结点上打了一个 $+1\ tag$ 。</p>
<p>老规矩，如果当前官员结点的管辖区间被完全包含，直接返回，比如我们要求一段区间的 $sum$ ，我们这个时候就应该返回被包含的管辖区间的总 $sum$ 。</p>
<p>我们之前有过很多区间修改的操作，往下走的路其实百废待兴，留了一些 $tag$ 。所以，还是要标记下传，为领导的检查开辟好道路（雾）。</p>
<p>二分我们的目标区间，递归这一操作，每次更新答案，比如我们要求一段区间的 $max$ ，这个时候 $ans$ 就可以等于 </p>
<script type="math/tex; mode=display">max (ans,check(needl,needr,lft,mdl,ls(x)\ )\ )</script><p>应该很好理解的叭（<del>心虚</del>）……</p>
<p>上个代码品品（区间求和）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> needl,<span class="keyword">int</span> needr,<span class="keyword">int</span> lft,<span class="keyword">int</span> rgt,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> answer=<span class="number">0</span>;<span class="comment">//答案</span></span><br><span class="line">	<span class="keyword">if</span>(needl&lt;=lft&amp;&amp;needr&gt;=rgt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> sum[x];<span class="comment">//被包含，返回对应区间的sum</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">push_down</span>(x,lft,rgt);</span><br><span class="line">    <span class="comment">//标记下传</span></span><br><span class="line">    <span class="keyword">int</span> mdl=(lft+rgt)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(needl&lt;=mdl) answer+=<span class="built_in">check</span>(needl,needr,lft,mdl,<span class="built_in">ls</span>(x));</span><br><span class="line">	<span class="keyword">if</span>(needr&gt;mdl) answer+=<span class="built_in">check</span>(needl,needr,mdl+<span class="number">1</span>,rgt,<span class="built_in">rs</span>(x));</span><br><span class="line">    <span class="comment">//二分递归</span></span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="就这实现："><a href="#就这实现：" class="headerlink" title="就这实现："></a>就这实现：</h4><p>放一下板子题（<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3372">线段树1</a>） ，要求区间修改，区间求和。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">500005</span>], sum[<span class="number">500001</span>], tag[<span class="number">500001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     sum[x] = sum[<span class="built_in">ls</span>(x)] + sum[<span class="built_in">rs</span>(x)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lft, <span class="keyword">int</span> rgt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     tag[x] = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (lft == rgt)</span><br><span class="line">     &#123;</span><br><span class="line">          sum[x] = a[lft];</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> mdl = (lft + rgt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">     <span class="built_in">build</span>(<span class="built_in">ls</span>(x), lft, mdl);</span><br><span class="line">     <span class="built_in">build</span>(<span class="built_in">rs</span>(x), mdl + <span class="number">1</span>, rgt);</span><br><span class="line">     <span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lft, <span class="keyword">int</span> rgt, <span class="keyword">int</span> tg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     tag[x] += tg;</span><br><span class="line">     sum[x] += tg * (rgt - lft + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> lft, <span class="keyword">int</span> rgt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> mdl = (lft + rgt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">     <span class="built_in">work</span>(<span class="built_in">ls</span>(x), lft, mdl, tag[x]);</span><br><span class="line">     <span class="built_in">work</span>(<span class="built_in">rs</span>(x), mdl + <span class="number">1</span>, rgt, tag[x]);</span><br><span class="line">     tag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> needl, <span class="keyword">int</span> needr, <span class="keyword">int</span> lft, <span class="keyword">int</span> rgt, <span class="keyword">int</span> x, <span class="keyword">int</span> tg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (needl &lt;= lft &amp;&amp; needr &gt;= rgt)</span><br><span class="line">     &#123;</span><br><span class="line">          tag[x] += tg;</span><br><span class="line">          sum[x] += tg * (rgt - lft + <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">push_down</span>(x, lft, rgt);</span><br><span class="line">     <span class="keyword">int</span> mdl = (lft + rgt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (needl &lt;= mdl)</span><br><span class="line">          <span class="built_in">change</span>(needl, needr, lft, mdl, <span class="built_in">ls</span>(x), tg);</span><br><span class="line">     <span class="keyword">if</span> (needr &gt; mdl)</span><br><span class="line">          <span class="built_in">change</span>(needl, needr, mdl + <span class="number">1</span>, rgt, <span class="built_in">rs</span>(x), tg);</span><br><span class="line">     <span class="built_in">push_up</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> needl, <span class="keyword">int</span> needr, <span class="keyword">int</span> lft, <span class="keyword">int</span> rgt, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (needl &lt;= lft &amp;&amp; needr &gt;= rgt)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> sum[x];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> mdl = (lft + rgt) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">     <span class="built_in">push_down</span>(x, lft, rgt);</span><br><span class="line">     <span class="keyword">if</span> (needl &lt;= mdl)</span><br><span class="line">          answer += <span class="built_in">check</span>(needl, needr, lft, mdl, <span class="built_in">ls</span>(x));</span><br><span class="line">     <span class="keyword">if</span> (needr &gt; mdl)</span><br><span class="line">          answer += <span class="built_in">check</span>(needl, needr, mdl + <span class="number">1</span>, rgt, <span class="built_in">rs</span>(x));</span><br><span class="line">     <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n, m;</span><br><span class="line">     cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          cin &gt;&gt; a[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">int</span> opt;</span><br><span class="line">          cin &gt;&gt; opt;</span><br><span class="line">          <span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="keyword">int</span> a, b, k;</span><br><span class="line">               cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;</span><br><span class="line">               <span class="built_in">change</span>(a, b, <span class="number">1</span>, n, <span class="number">1</span>, k);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (opt == <span class="number">2</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="keyword">int</span> a, b;</span><br><span class="line">               cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">               cout &lt;&lt; <span class="built_in">check</span>(a, b, <span class="number">1</span>, n, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看过上面思路部分的大体就能懂了（<del>吧？</del>）</p>
<h3 id="珂-朵-莉-树-mathtt-O-D-T"><a href="#珂-朵-莉-树-mathtt-O-D-T" class="headerlink" title="珂 朵 莉 树 ($\mathtt{O\ D\ T}$)"></a>珂 朵 莉 树 ($\mathtt{O\ D\ T}$)</h3><h4 id="FBI-WARNING-下方可能出现大量暴力片段，无关人员请迅速撤离"><a href="#FBI-WARNING-下方可能出现大量暴力片段，无关人员请迅速撤离" class="headerlink" title="FBI WARNING:下方可能出现大量暴力片段，无关人员请迅速撤离"></a>FBI WARNING:下方可能出现大量暴力片段，无关人员请迅速撤离</h4><p>这里的一部分来自笔者之前的题解吖！</p>
<p>珂朵莉树是一种比线段树<strong>更好打</strong>，比树状数组<strong>更易理解</strong>，比分块<strong>更暴力</strong>的和树一点关系没有的数据结构，作为一个名字里带<strong>树</strong>的数据结构，他是用 $set$ 维护的（笑）。</p>
<p>珂朵莉树支持的操作其实不少：区间修改、查找 $k$ 大值、区间赋值、区间询问$\dots\dots$其复杂度趋向 $m\log{n}$ 。为什么？我们随后会讲。我们现在只需要知道，珂朵莉树可以切许许多多标程是线段树的题目，并且时不时<strong>爆踩标程</strong>（雾）。</p>
<p>先来讲解珂朵莉树的有关思想：珂朵莉树的一个重要思想就是找集合里<strong>需要修改的部分推平</strong>（暴力的气息），再<strong>添加</strong>这个被推平区间的新点进入集合。（即把<strong>用不着的清除，留下一个新的代表</strong>）。而从整个集合里找到需要修改的部分，并对其单独修改，靠的是分裂 $\operatorname{split}$ ：</p>
<p>（注：这个集合里的元素都代表一个区间，用结构体实现）</p>
<p>非常玄学的算法，我们画个图尝试理解流程。</p>
<p>以下 $\mathtt{poster}$ 是我的结构体名，主要是因为我最初接触 ODT 的时候写的是一道和海报有关的题……</p>
<p><strong>一、从整个区间里分裂出要修改区间</strong></p>
<p>首先我们需要找到目标位置所在 $\mathtt{poster}$</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ce3qwvey.png" alt=""></p>
<p>这里我们二分找到下一个 $\mathtt{poster}$ 的起点。那么下一个 $\mathtt{poster}$ 对应的迭代器减去 1 ，就是 $pos$ 所在的这个 $\mathtt{poster}$ 的位置。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6q6m0pcl.png" alt=""></p>
<p>将 $pos$ 在的这个 $\mathtt{poster}$ 分割成 $l$~$pos-1$ 和 $pos$~$r$ 两个 $\mathtt{poster}$ 。这样我们就可以单独处理一部分的区间了。具体操作就是<strong>直接删掉</strong>这整个大块区间，然后再<strong>插入</strong>两个小块的区间（暴力气息逐渐浓厚）。实现如下～</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IT set<span class="meta-string">&lt;node&gt;</span>::iterator<span class="comment">//纯粹懒得打</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> l, r;</span><br><span class="line">     <span class="keyword">mutable</span> <span class="keyword">int</span> val;</span><br><span class="line"><span class="comment">//我们知道set里的普通元素是不能修改的，这里的mutable可以解决这一问题。</span></span><br><span class="line">     <span class="built_in">node</span>(<span class="keyword">int</span> a=<span class="number">0</span>,<span class="keyword">int</span> b=<span class="number">0</span>,<span class="keyword">int</span> c=<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          l = a;</span><br><span class="line">          r = b;</span><br><span class="line">          val = c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node a)<span class="keyword">const</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> l &lt; a.l;</span><br><span class="line">     &#125;<span class="comment">//重载运算符&lt;，便于处理区间时从左到右处理</span></span><br><span class="line">&#125;;</span><br><span class="line">set&lt;node&gt; s;</span><br><span class="line"><span class="function">IT <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将“pos所在 poster ”分裂成“以pos为界线”的两个小 poster</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     IT it= s.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(pos, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">     <span class="comment">//取下一个 poster 头的位置，也就是“这次要分裂的poster”的右限</span></span><br><span class="line">     <span class="keyword">if</span>(it!=s.<span class="built_in">end</span>()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="comment">//他不是最后一段poster（指位置最后），且他自己就是下一个poster的开头</span></span><br><span class="line">          <span class="keyword">return</span> it;</span><br><span class="line"><span class="comment">//pos已经在我们“要更改的poster ，即*it”里了</span></span><br><span class="line"><span class="comment">//到时候处理“*it自己所在的poster”</span></span><br><span class="line">     &#125;</span><br><span class="line">     it--;<span class="comment">//应处理上一个poster，这才是“pos所在的poster”</span></span><br><span class="line">     <span class="keyword">int</span> L = it-&gt;l, R = it-&gt;r, VAL = it-&gt;val;</span><br><span class="line">     s.<span class="built_in">erase</span>(it);<span class="comment">//这里到下个poster之前的这些位置就先删了</span></span><br><span class="line">     s.<span class="built_in">insert</span>(<span class="built_in">node</span>(L, pos<span class="number">-1</span>, VAL));</span><br><span class="line">     <span class="comment">//将我们删除的这个区间的前半部分（l~pos-1)加入集合</span></span><br><span class="line">     <span class="keyword">return</span> s.<span class="built_in">insert</span>(<span class="built_in">node</span>(pos, R, VAL)).first;</span><br><span class="line">     <span class="comment">//将我们删除的这个区间的后半部分(pos~r)加入集合</span></span><br><span class="line">     <span class="comment">//不会有人不知道insert是有pair返回值的，而且返回值的first是插入的位置的吧！(yygq)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二、暴力给一个区间赋上新值</strong></p>
<p>这才是整个赋值实现里最精彩的部分，不如看一下图。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/swhfdktm.png" alt=""></p>
<p>我们要把 $x-&gt;y$ 赋值成 $val$ ，倘若我们已经把“ $x$ 到他的区间末尾”，“ $y$ 到他的区间头”这两段区间单独分离出来了，他们加在一起就是我们要赋值的区间。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/26bnlj5i.png" alt=""></p>
<p>对于这两小块，我们<strong>暴力推平</strong>他们，<strong>暴力插入</strong>一个新区间，<strong>暴力赋值</strong>为 $val$ （<del>毁灭即重建</del>）</p>
<p>这一思想体现在代码里就像下面这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     IT it2 = <span class="built_in">split</span>(r + <span class="number">1</span>), it1 = <span class="built_in">split</span>(l);</span><br><span class="line">     <span class="comment">//因为我们处理时是默认是左闭右开的区间，所以要找到r+1</span></span><br><span class="line">     <span class="comment">//先找r+1防的是分离l的时候不小心把r+1所在区间删了</span></span><br><span class="line">     s.<span class="built_in">erase</span>(it1, it2);</span><br><span class="line">     <span class="comment">//这段都扬喽</span></span><br><span class="line">     s.<span class="built_in">insert</span>(<span class="built_in">node</span>(l, r, val));</span><br><span class="line">     <span class="comment">//插回一个新代表，代表的val是我们要赋的新值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>三、暴力修改我们的区间</strong></p>
<p>这里的大体思想极其简单：把<strong>要修改的部分</strong>里的最左边，从他原来所属的 $\mathtt{poster}$ 分离出来。最右边也从他原来所属的区间分离出来。再把最左边到最右边中间的每一个 $\mathtt{poster}$ <strong>暴力修改</strong>。</p>
<p>（<del>暴力气息扑面而来</del>）</p>
<p>如图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/482mmx80.png" alt=""></p>
<p>我们把左边分离出来，右边分离出来，中间的每一段，我们直接修改他的 $val$ 。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     IT it2 = <span class="built_in">split</span>(r + <span class="number">1</span>), it1 = <span class="built_in">split</span>(l);</span><br><span class="line">     <span class="comment">//把左右界确定好，以相同的原因先it2再it1</span></span><br><span class="line">     <span class="keyword">for</span> (IT i = it1; i != it2; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          i-&gt;val += k;<span class="comment">//暴力修改</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就短$\dots\dots$</p>
<p><strong>四、暴力查找区间第k大</strong></p>
<p>这里我们的做法是： $\operatorname{sort}$ 。</p>
<p>没错，真就  $\operatorname{sort}$ 。不过既然到了珂朵莉树这里，又要进行一些<strong>本地化处理</strong>。</p>
<p>我们大体流程是这样的：</p>
<ol>
<li><p>取出这段区间里所有 $\mathtt{poster}$ ，将其化为 <code>&lt;权值，拥有该权值的区间长度&gt;</code> 的 <code>pair</code> ，并存进一个 <code>vector</code> ，也就是对于一个 $\mathtt{poster}$ 化成一个 <code>make_pair(val,r-l+1)</code> 的元素。</p>
</li>
<li><p>对这个区间暴力 $\operatorname{sort}$ 。</p>
</li>
<li><p>从 $begin$ 往 $end$ 开搜，每次我们跑过一个元素，就把 $k$ （区间第k大的那个k）减去这个元素的 $second$ ，相当于我们跑过了这些元素，消耗里这么多排名。跑过一个以后，我们看看 $k$ 是不是变得小于 0 。小于0则说明我们跑过头了，那我们刚刚跑过的那个元素，不就是我们要找的嘛， $return$ 了。</p>
</li>
</ol>
<p>实现不难了吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rankk</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;<span class="comment">//开vector!</span></span><br><span class="line">     IT it2 = <span class="built_in">split</span>(r + <span class="number">1</span>), it1 = <span class="built_in">split</span>(l);<span class="comment">//分出左右界</span></span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span> (IT i = it1; i != it2; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">int</span> l = i-&gt;l, r = i-&gt;r, val = i-&gt;val;</span><br><span class="line">          v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(val, r - l + <span class="number">1</span>));</span><br><span class="line">          <span class="comment">//权值val，以及“以val为权值的区间”里的单点个数</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">     <span class="comment">//violence!!!</span></span><br><span class="line">     <span class="keyword">for</span> (VIT i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); i++)</span><br><span class="line">     &#123;</span><br><span class="line">          k -= i-&gt;second;</span><br><span class="line">          <span class="comment">//跑过一个元素</span></span><br><span class="line">          <span class="keyword">if</span> (k &lt;= <span class="number">0</span>)<span class="comment">//跑过头，也就是找到了</span></span><br><span class="line">               <span class="keyword">return</span> i-&gt;first;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>妙过头了。</del></p>
<p>我们再来考虑之前的复杂度问题，为什么珂朵莉树可以逼近甚至超越线段树？其实很好解释，我们的 $set$ 里的元素可不是始终有 $N$ 个，我们经过 $\operatorname{assign}$ 的<strong>清除元素留代表</strong>的工作，已经在不断地<strong>消减我们的工作量</strong>，最终这里的工作量是趋于 $\log{n}$ 的（玄学）。</p>
<p>这里放一下ODT板子题也是其发源地 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF896C">CF896C</a> （这道题以前是个黑，刚刚变成紫了，呜呜呜～）的完整代码叭。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IT set<span class="meta-string">&lt;node&gt;</span>::iterator</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIT vector<span class="meta-string">&lt;pair&lt;int, int&gt;</span>&gt;::iterator</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">int</span> l, r;</span><br><span class="line">     <span class="keyword">mutable</span> <span class="keyword">int</span> val;</span><br><span class="line">     <span class="built_in">node</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span><br><span class="line">     &#123;</span><br><span class="line">          l = a, r = b, val = c;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node a) <span class="keyword">const</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> l &lt; a.l;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;node&gt; s;</span><br><span class="line"><span class="keyword">int</span> MOD;</span><br><span class="line"><span class="keyword">int</span> n, m, seed, vmax;</span><br><span class="line"><span class="function">IT <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     IT it = s.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(pos, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">     <span class="keyword">if</span> (it != s.<span class="built_in">end</span>() &amp;&amp; it-&gt;l == pos)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> it;</span><br><span class="line">     &#125;</span><br><span class="line">     it--;</span><br><span class="line">     <span class="keyword">int</span> l = it-&gt;l, r = it-&gt;r, val = it-&gt;val;</span><br><span class="line">     s.<span class="built_in">erase</span>(it);</span><br><span class="line">     s.<span class="built_in">insert</span>(<span class="built_in">node</span>(l, pos - <span class="number">1</span>, val));</span><br><span class="line">     <span class="keyword">return</span> s.<span class="built_in">insert</span>(<span class="built_in">node</span>(pos, r, val)).first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     IT it2 = <span class="built_in">split</span>(r + <span class="number">1</span>), it1 = <span class="built_in">split</span>(l);</span><br><span class="line">     s.<span class="built_in">erase</span>(it1, it2);</span><br><span class="line">     s.<span class="built_in">insert</span>(<span class="built_in">node</span>(l, r, val));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     IT it2 = <span class="built_in">split</span>(r + <span class="number">1</span>), it1 = <span class="built_in">split</span>(l);</span><br><span class="line">     <span class="keyword">for</span> (IT i = it1; i != it2; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          i-&gt;val += k;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rankk</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">     IT it2 = <span class="built_in">split</span>(r + <span class="number">1</span>), it1 = <span class="built_in">split</span>(l);</span><br><span class="line">     v.<span class="built_in">clear</span>();</span><br><span class="line">     <span class="keyword">for</span> (IT i = it1; i != it2; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">int</span> l = i-&gt;l, r = i-&gt;r, val = i-&gt;val;</span><br><span class="line">          v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(val, r - l + <span class="number">1</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">     <span class="keyword">for</span> (VIT i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); i++)</span><br><span class="line">     &#123;</span><br><span class="line">          k -= i-&gt;second;</span><br><span class="line">          <span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">return</span> i-&gt;first;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> exp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (exp == <span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> a % MOD;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> tmp = <span class="built_in">quick_pow</span>(a, exp / <span class="number">2</span>);</span><br><span class="line">     <span class="keyword">if</span> (exp % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">return</span> (tmp * tmp) % MOD;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in"><span class="keyword">return</span></span> ((tmp * tmp) % MOD * a) % MOD;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">powsum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> exp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     IT it2 = <span class="built_in">split</span>(r + <span class="number">1</span>), it1 = <span class="built_in">split</span>(l);</span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (IT i = it1; i != it2; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">int</span> l = i-&gt;l, r = i-&gt;r, val = i-&gt;val;</span><br><span class="line">          res = (res + (r - l + <span class="number">1</span>) * <span class="built_in">quick_pow</span>(val % MOD, exp) % MOD) % MOD;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> ret = seed;</span><br><span class="line">     seed = (seed * <span class="number">7</span> + <span class="number">13</span>) % <span class="number">1000000007</span>;</span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;m, &amp;seed, &amp;vmax);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">int</span> num = <span class="built_in">rnd</span>() % vmax + <span class="number">1</span>;</span><br><span class="line">          s.<span class="built_in">insert</span>(<span class="built_in">node</span>(i, i, num));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">int</span> op = (<span class="built_in">rnd</span>() % <span class="number">4</span>) + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> l = (<span class="built_in">rnd</span>() % n) + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> r = (<span class="built_in">rnd</span>() % n) + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">               <span class="built_in">swap</span>(l, r);</span><br><span class="line">          <span class="keyword">int</span> x;</span><br><span class="line">          <span class="keyword">if</span> (op == <span class="number">3</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               x = (<span class="built_in">rnd</span>() % (r - l + <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               x = (<span class="built_in">rnd</span>() % vmax) + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (op == <span class="number">4</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               MOD = (<span class="built_in">rnd</span>() % vmax) + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">update</span>(l, r, x);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">assign</span>(l, r, x);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (op == <span class="number">3</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               cout &lt;&lt; <span class="built_in">rankk</span>(l, r, x) &lt;&lt; endl;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (op == <span class="number">4</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               cout &lt;&lt; <span class="built_in">powsum</span>(l, r, x) &lt;&lt; endl;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比平衡树好打多了～</p>
<p><strong>这里友情提醒</strong>：珂朵莉树基本上永远不是我们做一道题目的唯一解或者首选项，因为他的复杂度 <strong>是 假 的</strong>。有可能会被卡（不过出题人如果不刻意卡他应该还好），所以ODT一般是我们的第二屏障，要是正解真的写不出来，还是可以期待<del>暴力碾标算的</del>奇迹的。（<del>逃</del></p>
<hr>
<p>终于写完辣！这里列举的只是一些较为基础的数据结构，普及选手顺手拿个1=应该是游刃有余，提高的话，想要往上走走还是要往深里学（<del>或许</del></p>
<hr>
<h3 id="第1008行题解撒花～～～"><a href="#第1008行题解撒花～～～" class="headerlink" title="第1008行题解撒花～～～"></a>第1008行题解撒花～～～</h3>
            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2021年04月17日 16:14</p>
        <p>原始链接： <a class="post-url" href="/2021/04/17/%E6%B5%85%E8%B0%88%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="浅谈简单数据结构">https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></p>
        <footer>
            <a href="https://quest233.github.io">
                <img src="/images/150879.png" alt="quest_2">
                quest_2
            </a>
        </footer>
    </div>
</div>

      
        
            

        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&title=《浅谈简单数据结构》 — quest233的博客&pic=https://quest233.github.ioimages/150879.png" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&title=《浅谈简单数据结构》 — quest233的博客&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《浅谈简单数据结构》 — quest233的博客&url=https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&via=https://quest233.github.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://quest233.github.io/2021/04/17/%E6%B5%85%E8%B0%88%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/“知识”决定命运/" class="color4">“知识”决定命运</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%86-%E5%9D%97"><span class="post-toc-text">分 块</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9F"><span class="post-toc-text">基本思想？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%A5%BD%E5%86%99%E5%8D%B3%E6%AD%A3%E4%B9%89%EF%BC%81"><span class="post-toc-text">实现？好写即正义！</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%99%E9%87%8C%E6%94%BE%E4%B8%80%E4%BB%BD%E5%88%86%E5%9D%97%E7%BB%8F%E5%85%B8%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%B8%BB%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86%E8%BF%98%E6%98%AF%E8%AF%B8%E4%BD%8D%E8%A7%86%E9%A2%98%E7%9B%AE%E8%80%8C%E5%86%99%EF%BD%9E"><span class="post-toc-text">这里放一份分块经典代码，主函数部分还是诸位视题目而写～</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A0%91-%E7%8A%B6-%E6%95%B0-%E7%BB%84"><span class="post-toc-text">树 状 数 组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%A4%E4%BA%BA%E8%B0%94%E8%B0%94%E7%9A%84%E6%80%9D%E6%83%B3"><span class="post-toc-text">令人谔谔的思想</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9C%89%E4%B8%80%E8%AF%B4%E4%B8%80%EF%BC%8C%E8%BF%99%E4%BB%A3%E7%A0%81%E7%9C%9F%E7%9A%84%E5%A5%BD%E6%89%93"><span class="post-toc-text">有一说一，这代码真的好打</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BA%BF-%E6%AE%B5-%E6%A0%91"><span class="post-toc-text">线 段 树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B0%B1%E8%BF%99%E6%80%9D%E6%83%B3"><span class="post-toc-text">就这思想</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%BB%BA%E6%A0%91%E6%96%B9%E6%B3%95%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E9%85%8D%E5%90%88%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A3%85B%E6%B3%95%EF%BC%9A"><span class="post-toc-text">建树方法：结构体指针配合位运算装B法：</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%EF%BC%9A%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E6%87%92%E6%A0%87%E8%AE%B0%E4%B8%8B%E4%BC%A0%E6%B3%95%EF%BC%9A"><span class="post-toc-text">区间修改：一劳永逸懒标记下传法：</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%EF%BC%9A%E5%B1%82%E5%B1%82%E9%80%92%E5%BD%92%E5%8C%85%E6%8B%AC%E5%8D%B3%E8%BF%94%E5%9B%9E%E6%B3%95%EF%BC%9A"><span class="post-toc-text">区间查询：层层递归包括即返回法：</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B0%B1%E8%BF%99%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="post-toc-text">就这实现：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%8F%82-%E6%9C%B5-%E8%8E%89-%E6%A0%91-mathtt-O-D-T"><span class="post-toc-text">珂 朵 莉 树 ($\mathtt{O\ D\ T}$)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#FBI-WARNING-%E4%B8%8B%E6%96%B9%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F%E6%9A%B4%E5%8A%9B%E7%89%87%E6%AE%B5%EF%BC%8C%E6%97%A0%E5%85%B3%E4%BA%BA%E5%91%98%E8%AF%B7%E8%BF%85%E9%80%9F%E6%92%A4%E7%A6%BB"><span class="post-toc-text">FBI WARNING:下方可能出现大量暴力片段，无关人员请迅速撤离</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%AC%AC1008%E8%A1%8C%E9%A2%98%E8%A7%A3%E6%92%92%E8%8A%B1%EF%BD%9E%EF%BD%9E%EF%BD%9E"><span class="post-toc-text">第1008行题解撒花～～～</span></a></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2021/04/17/%E6%B5%85%E8%B0%88%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          浅谈简单小数学题
        
      </span>
    </a>
  
  
    <a href="/2021/04/17/%E5%88%9D%E8%B5%9B%E6%A8%A1%E6%8B%9F%E6%8C%A8%E6%89%93%E7%BA%AA%E5%AE%9E/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">初赛模拟挨打纪实</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
          <div id="uyan_frame"></div>
  <script src="http://v2.uyan.cc/code/uyan.js?uid=true"></script>

    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2021 quest_2<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://quest233.github.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 0
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/solutions/" style="font-size: 20px;">solutions</a> <a href="/tags/water/" style="font-size: 10px;">water</a> <a href="/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/" style="font-size: 15px;">“知识”决定命运</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/2021/04/17/About/#more">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/solutions/" style="font-size: 20px;">solutions</a> <a href="/tags/water/" style="font-size: 10px;">water</a> <a href="/tags/%E2%80%9C%E7%9F%A5%E8%AF%86%E2%80%9D%E5%86%B3%E5%AE%9A%E5%91%BD%E8%BF%90/" style="font-size: 15px;">“知识”决定命运</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>